# 3.领域驱动的什么？

在前一章中，我给了你一些我们在本章和其他章节中继续探索的东西，关于 DDD 建立的思想和概念。在这个过程中，我希望能够激起你在 Laravel 学习领域驱动设计的兴趣。我们将继续探索 DDD 提出的策略和方法，然后讨论如何使用 Laravel 实现这些想法。

在这一章中，我们将更多地关注 DDD 提供的核心定义和策略，并且给出一些领域驱动设计的高层次概述以及它的内容是如何分解的。我的目的是给你足够的知识，用你在现实世界中构建一个基于 DDD 的项目所需的基本核心实践和过程武装你。我将为您提供在任何领域构建软件时可能会遇到的示例问题，并且我将为您提供各种解决方案，这些解决方案将突出一些不同的组件，并说明它们定义的各种概念和上下文。

## 软件的本质

软件很少会自我实现。相反，它是达到目的的一种手段...做某事的方法。很少为了*编码而写代码。*您很可能不会遇到太多最终产品是代码本身的情况，除非您正在为一本书编写代码，或者在一篇博客文章中强调一段源代码，甚至编写一个开源库。通常情况下，你的软件的目的是做一些与构建软件无关的事情。

例如，开展电子邮件活动的营销公司希望跟踪统计有多少用户打开了该电子邮件，有多少用户点击了该电子邮件中的广告，有多少用户实际购买了该产品，等等。这些报告具有很大的商业价值，有助于推动商业决策，并验证营销活动作为一个整体是否符合某些跟踪目标。首席执行官和其他高管经常使用这些数据来做出影响公司健康和重点的重要决策。

对于利益相关者和公司的 CEO 来说，他们想看到的只是他们的报告。他们很可能不太关心这些报告是如何构建的，而是这些报告对他们来说是可见的，并且是准确的。对他们和其他企业来说，代码只是收集数据、计算数字和生成报告的一种手段。他们通常不关心诸如单元测试、安全性(不幸的是)、架构、编码风格、编程语言或系统的任何其他技术方面...他们只想要漂亮的报告。

开发和业务目标之间的分歧如此之大，以至于大多数时候，在各个部门之间有一种单独的语言来描述相同的业务概念。在极端的情况下，围绕软件系统的部门本身变得如此分离，以至于他们每个人都有一个语言版本，开始是一个单一的定义，但发展到包括几个上下文有偏见的定义。每一个定义都对应于它们被构思的部门的中心焦点或方面，以这种方式来创建伪概念，这意味着*几乎*与它们的祖先一样的东西，但是有足够的细微差别，以至于该概念在整个组织中不成立。

业务主管/利益相关者*和*关心的是诸如报告准确性、用户界面设计、网站可用性、性能和总体用户体验，因为这是用户所看到的。在任何与技术相关的业务或软件努力的这两个基本方面之间，肯定会有，而且很可能永远会有一些摩擦:业务的需求和软件的质量。当质量因为时间的原因而得到补偿时，我在第 [1](01.html) 章中讨论的事情开始变成现实，你最终会以不开心的开发人员、比通常更长的周转时间、意想不到的火灾和一大堆其他糟糕的事情而告终，最终会变成一团烂泥。

## 金三角

图 3-1 代表了一个流行的图表，用来表达软件开发工作的三个主要方面之间的权衡。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig1_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig1_HTML.jpg)

图 3-1

软件开发的金三角

在图 [3-1](#Fig1) 中，对于一个给定的软件项目，你只能得到三个理想结果中的两个:开发的速度(时间)、源代码的质量(质量)和成本(费用)。我们可以根据表 [3-1](#Tab1) 来确定结果的可能性。

表 3-1

金三角组合的可能结果

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

选择#1

 | 

选择#2

 | 

结果

 | 

真实世界的例子

 |
| --- | --- | --- | --- |
| 质量 | 时间 | 快速构建的高质量产品不会很便宜。 | 快速应用开发 |
| 时间 | 费用 | 快速廉价的产品质量会很差。 | 创业公司的旗舰应用 |
| 费用 | 质量 | 高质量的廉价产品需要时间来制造。 | 开源软件 |
| 质量 | 质量 | 一个超高质量的产品是要及时和昂贵的。 | 企业软件 |
| 时间 | 时间 | 一个超快的产品将会很贵而且缺乏质量。 | 任何微软软件 |
| 费用 | 费用 | 一个超级便宜的产品将会是低质量和耗时的。 | 外包海外开发 |

## 什么和如何

软件既是具体化的东西，也是抽象的东西。软件开发工作的结果是决定项目是否成功的最明显的方式。在 web 开发的情况下，web 应用程序中的自定义页面——包括其计算、外观、交互和条件——可以通过使用浏览器与应用程序进行交互来判断其正确性和完整性。用户体验几乎总是高层和主管们优先考虑的事情，一个页面的表现是证明花了十几个小时或更多时间完成的工作确实完成了的手段。因此，在这方面有一个具体化的概念:当你能在屏幕上看到一个模态时，为一个网页开发一个模态的结果就应该完成了，它的行为正是需求所规定的。这个区域可以被认为是。

软件在外部的行为方式(例如，从最终用户的角度看，它的外观和功能)并不一定表明在内部塑造它的代码的质量或结构。构成用户体验的代码可能非常糟糕，写得也很糟糕(例如，如果标准的安全措施因为时间的原因而被抛弃，或者验证的实践没有在 HTML 表单中实现)，但是外部可能会也可能不会实际反映这一事实，因为代码本身与作为代码结果而存在的元素、框架和功能有概念上的差异。应用程序的这个内部区域可以被认为是 *how。*

如何在系统中测试通常是最困难的事情。这是因为直到我们开始遇到错误和奇怪的问题时，才知道代码写得有多好，这些问题似乎已经解决了很多次，但仍然出现在应用程序中。how 包括所有实际的代码，并且是关于代码本身质量问题的答案的真实来源，这并不总是像它在浏览器中显示的那样。你不能简单地看一张表格就断定 CSRF 保护措施没有被用来阻止 XSS 袭击。您必须检查文档并查看表单的代码，寻找某种类型的 CSRF 令牌或编码字符串。

当“如何做”和“做什么”之间相差太远时，问题就会出现。虽然产品经理和执行官通常更关心应用程序是什么，但是开发团队和工程人员关心的是(或者应该是)如何。例如，如果我们构建的模型看起来和工作起来都很棒，产品经理就会签字同意，对他们来说，这是一个很好的开始。

现在让我们说，在开发过程中，我们在代码中的某个地方留下了一个巨大的安全持有，它只在特定的条件下出现。以这段代码为例:

```
<?php

if ($request->parameter == 3) {
     //to remove!
     exec(‘cat .env’);
}

```

假设在我们构建的模型上有一个表单或输入，在这个表单上有一个带有下拉框的输入框，用于选择和设置表单元素。在开发这个模型时，我们进行了前面的检查，因为我们有兴趣看到(无论出于什么原因)在`.env`文件上发出`cat`命令的结果(`.env`文件是保存您的应用程序的所有私有配置值的文件，不是存储库的一部分)，但前提是名为`parameter`的表单变量等于 3。是的，我完全知道这个例子中的代码有多糟糕，但它只是一个例子；不要看太多。

这是一个严重的安全缺陷，它基本上显示了整个`.env`文件，其中包含我们所有的数据库密码和我们的应用程序运行所需的其他秘密数据。我们绝不会向任何用户透露这些信息，所以这是一个相当大的问题。这类似于导致切尔诺贝利核事故的问题。原本可以防止这种灾难的安全措施和实践被关闭，以“测试”系统。当问题真正出现时，它以巨大爆炸的形式出现，从反应堆核心释放出大量有毒的放射性物质。显然，我们的问题是*多*少损失惨重，但你明白了这一点。

产品经理很容易忽视这一点，他认为一切“看起来”都没问题，因为事实就是如此。然而，在幕后，是一个根深蒂固的问题，这个问题开始时只是为了开发而进行的简单测试，在他们推出最终的软件后并没有得到适当的解决。防止上述情况的责任完全落在开发团队的肩上。在这种情况下，应用程序的“是什么”(它是包含某种按预期工作的形式的模型)被验证为处于良好的状态，但是“如何”从来没有被另一个开发人员适当地审查过，这使我们对标准和实践产生了疑问，这些标准和实践要么在开始时没有实施，要么在该软件的开发过程中被完全忽略。

Note

作为对这个安全问题的额外思考，考虑现实情况:代码缺乏所有形式的*代码审查*；如果没有，错误就会被发现。还能做些什么来防止这个缺陷呢？单元测试。如果这个特性有足够的单元测试来覆盖模态逻辑的这一部分(当然应该)，那么在合并到主分支之前进行的一个简单的自动化测试就会以一种相当明显的方式指出这个问题(在这种情况下，显示`.env`文件的内容)！

如何构建软件来实现*它实际做什么是我称为开发的*抽象*方面的领域。我成为程序员的原因是因为我对解决问题的*方式*感兴趣。我总是着迷于必须做出的决定，以及如何使用编程语言的工具和功能作为解决复杂问题的手段。这门科学有一定的艺术。不管最终的范例和最佳实践的实现如何，您都应该注意编写足够多的单元测试，以便应用程序中的每一部分代码都可以被相应的测试覆盖。这些测试作为自动化套件的一部分运行，该套件在每次将拉请求合并到主分支时被触发。一个好的 CI/CD 系统对于软件开发团队来说是无价的。*

 *开发软件需要思维、学习和编码的平衡。代码并不是解决问题的唯一手段，很多问题可以(也应该)通过*解决，而不需要*诉诸代码。

Note

代码是最后的手段。如果除了多写代码还有其他可行的方案*就不要多写代码了。每一行代码都是必须维护和重构的另一行，每当我们编写代码时，我们都冒着将新的错误引入系统的风险。*

## DDD 概念的分解

DDD 涵盖的主题错综复杂，深入浅出，红皮书和蓝皮书都有详细讨论。我的目标是让你知道我们将在本书中关注什么，并让你熟悉我们需要覆盖的 DDD 的不同领域，以便使用 DDL 构建一个有用的系统。

请注意，图 3-2 中的图表省略了被称为*蒸馏*的整个 DDD 部分。这一部分中的概念包括重构策略和如何实现某些模式来逐步淘汰遗留软件，以及其他方法来细化您的领域模型，并获得一个更准确的模型，该模型用无处不在的语言中的适当术语来表达业务。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig2_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig2_HTML.jpg)

图 3-2

DDL 概念图

在图 [3-2](#Fig2) 中，我们有一个三角形的三个点(这三个点与金三角没有关系，只是为了让你知道)，它们之间的相互作用用线条描述，并简要描述了它们之间的关系。然而，请注意，它们似乎都与无处不在的语言泡沫密切相关。那是因为它们*都应该来源于或者直接使用无处不在的语言里面的物品。*

战略设计将包括完成领域驱动设计的策略，以及包括最佳实践和高级架构讨论。它还包含着手设计您的领域模型的过程和方法(比如让一位领域专家在附近澄清任何缺点或复杂的逻辑区域，这些对于进入公司的新员工来说可能不完全理解)。我们在 DDD 的战略设计部分获得的知识将被用于制作和提炼一种正确的通用语言，这种语言将被整个公司使用，以传达实际商业模式中存在的各种含义。这些知识也将用于驱动我们应用程序的开发(在我们的例子中，使用 Laravel 框架来构建这些概念和过程)。

战术设计是我们需要的所有技术结构和考虑因素，以便建立我们通过位于 DDD 的战略设计支柱中的工具和方法实现的所有不同的对象、策略和结构。我们将使用它们作为一种手段，将无处不在的语言中的对象和作用于这些对象的业务流程转换成允许它们在 web 应用程序中运行的实际代码。战术设计经常被表达为 UML 图或者其他 OOP 类型的图和图像，以帮助说明创建领域驱动设计中涉及的复杂概念...DDL 也是如此。在我们的 Laravel 应用程序中，战术设计中的组件将直接对应于它帮助建模的代码。最后，我们的 Laravel 应用程序将是我们使用战术设计构建的这些对象和流程的实现。

Note

战术设计流程只能在初始知识发现/粗略建模阶段完成后*才能完成。你只能从战术设计的角度开始对领域建模(例如，使用实际的代码*结构*，比如仓库、工厂、实体、集合等等。)在您至少对您试图用代码重新创建的真实世界系统有了部分了解之后。这本书的内容将以这种方式工作。*

在图 [3-1](#Fig1) 的第三个气泡中，我们有我们的 Laravel 应用程序。这个应用程序将是许多关于系统核心功能和需求的讨论、会议和计划会议的结果。它将是与我们正在构建的组件或系统有任何联系的几个(如果不是全部)部门协作的产物。

## 领域建模的过程

人们常说，领域建模与其说是一门科学，不如说是一门艺术。这当然源于软件独特的流体状态。它的不断扩展的结构和可延展的趋势提供了无限的可能性，这只有在存在法律、限制、过程和约束的情况下才是有用的，这些法律、限制、过程和约束有助于为工作空间提供某种上下文，并将概念的混合划分到封装的逻辑边界的容器中，这对于程序员来说更容易理解。

这带来了另一个好的观点:从本质上讲，软件开发的复杂性只对我们这些阅读和操作它的人来说是不同的，而对实际执行和运行它的机器来说不是。我们在领域设计中建立的区别、封装、清晰度、符号、规范和描述，以及代码中相应的实现，都是专门为人类消费而制定的。另一方面，从理论上讲，机器更愿意被源源不断地输入 1 和 0，这样它们就可以做它们被创造出来要做的低级处理。他们不关心函数名或类名称空间结构，它们是为了我们开发人员在以后修改代码时阅读和洞察而存在的。

在开发应用程序时记住这一点是有好处的，因为我们需要善待下一个看代码的人。当我们忘记对`doSomethingOdd()`进行额外的调用时，它也可以作为一个很好的提醒，直到我们看到这样一个冗长的注释:

```
/** !!!!IMPORTANT!!!! DO NOT, NOT CALL THIS FUNCTION! ITS MANDATORY*/
$this->value = doSomethingOdd() . doSomethingOdd();

```

信不信由你，这是我参与的一个真实项目的样本！它完全没有意义，并且给下一个必须阅读它的人增加了许多困惑。

变量、类和对象的名称可以让开发人员了解代码中发生了什么，根据复杂性，可以写在每一行来描述每一行的作用。它们或多或少是解释性的注释，有助于用简单的英语描述过程的细节。虽然注释非常有用，但是过度使用注释会破坏代码，降低可读性和开发速度。但评论绝不是无用的。不管你喜不喜欢，随着新功能的产生和新问题的增加，即使是最小的应用程序也总是面临着复杂性增加的风险。最后，找到注释和它们所描述的源代码之间的平衡是很重要的。

### 不要做什么

构建应用程序时最糟糕的事情就是错误地管理复杂性——无论是高估还是低估。当复杂性在项目中具体化时，试图避免复杂性的做法被证明与过度设计软件来处理*预期的*复杂性一样糟糕。对于后者，往往会发生的是你浪费了宝贵的开发时间来创建一些可能是或可能不是未来实际关注的东西，而你本可以将这些时间花在*真正的*应用需求上。除此之外，当第一次对一个“可能”的系统建模时所做的假设和前提条件很可能已经随着对底层业务规则(域模型)的细化和更新而改变了。只有在扔掉了大量系统无法使用的构建代码之后，您才意识到您可能必须完全重写系统的这一部分，因为您构建的解决方案不再满足新的问题范围。

避免复杂性是一种在开发过程中会出现的现象，并且通常开发人员没有意识到这一点，至少一开始没有。最初，开发人员从良好的意图出发，坚持最佳实践和良好的架构结构，但往往有些犹豫，并违背这些最佳实践(在某些情况下通过引入反模式)。但是，如果解决方案实际上*有效*，它就会被发货。如果团队定期参与代码审查，并不断努力完善和改进核心业务模型，这不是一个问题，因为他们最终会重构代码，并实现比第一个版本更好、更有知识的解决方案，而第一个版本只是第一个工作的东西。

然而，当重构不是开发软件的标准实践时，这些问题将会表现为一大团泥巴，上面充斥着陈旧过时的评论，通常不会让读者更好地了解实际发生了什么。在一些极端的情况下，逻辑可能会达到这样一个程度，即在同一个文件、类或模型中包含许多不同的关注点的整体结构中，被强加了太多的复杂性。如果没有大量的重构工作，增加复杂性甚至不再可能，重构工作通常会持续几周或几个月。

从本质上讲，这种可怕的情况会变成现实有两个主要原因第一个原因是没有遵循最佳实践。第二种情况是，在没有足够的领域知识和经验的情况下构建解决方案，而这些知识和经验对于正确地对业务领域(以及那些模型上的操作)建模是必要的。

如果从事软件工作的人没有正确理解软件背后的商业概念，并且没有投入精力为这些概念建立概念基础，他们会不顾一切地尝试任何可能有助于完成他们需要做的事情的解决方案。当这种情况发生时，代码会被随机地插入到各处，以测试各种东西或转储出只在特定条件或特定状态下实际存在的变量值(由于 PHP 和 web 开发的无状态特性)。测试变得如此复杂和繁琐，以至于测试本身在某些时候几乎被完全忽略，在系统代码库的测试覆盖范围中留下了一个大的缺口，并慢慢地恶化了 CI/CD 管道以及您的 DevOps 工程师花费数周时间准备的所有酷东西，因为它们完全无用。

如果发生这种情况，它*几乎总是指向缺乏清晰的边界，通常是由于在领域级别上违反了关注点分离*或者使用了在通用语言中没有正确定义的不正确的组件。

当“调试代码”的概念等同于依靠旧的“dump and die”或`print_r($var);die;`命令来戳代码并试图弄清楚在代码执行中的这个特定位置发生了什么时，您知道您正在处理这些地狱般的应用程序中的一个，因为环境是以这样一种方式制造的，任何错误输出都几乎不存在，更不用说缺乏任何正确调试代码的手段。

## 处理复杂性

领域架构完全是关于在复杂性出现时处理它，并且首先将简单的实例放在适当的位置，随着获得关于业务领域的额外洞察力，对那些实例的关注和积极的改进。DDD 有各种技术和步骤来帮助我们开始为我们的应用程序建立一个坚实的基础。

### DDD 流

我发现在我的日常 web 开发项目中实现 DDD 的最好方法是遵循这个一般过程。请记住，这些步骤与 DDD 的技术方面无关(我们将在后面讨论)。

1.  深入了解你正在工作的领域。让自己沉浸其中，这样你就能对该领域的问题、解决方案和架构了如指掌。例如，如果你在医疗计费行业工作，你可能已经记住了 CPT 代码，并且可以背诵医疗病人资格地址。如果你从事金融行业，你可能知道贷款是如何构成的，以及如何在资产的生命周期内分配成本折旧。

2.  与领域专家一起创造一种无处不在的语言。由于你很可能*而不是*在你工作的领域里(特别是如果你刚刚开始你的 web 开发生涯)，你将需要依靠专家来构建一套通用的、公司范围的术语和定义，以及关于它们之间可能存在的关系的准确描述和文档。

3.  根据您在第 1 步和第 2 步中获得的派生学习和对系统的部分理解，按照企业解决方案空间描述的以及您最初理解的那样，构建系统的粗略设计。即使最初的设计有缺失的部分，或者最初没有清楚地指出分隔各个部分的界限，也要获得某种基于核心领域模型的概念化设计，并用无处不在的语言进行描述。

4.  **经常重构和细化模型的设计，很快失败。**因为我们重视敏捷开发实践，并且热衷于迭代开发，所以我们根据对业务领域的理解不断更新我们的模型。领域模型的设计应该总是反映领域本身最新获得和接受的知识。我们通过“快速失败”来做到这一点如果我们在开发某个系统时尽可能快地失败，我们被迫同样快地修复这些失败，每一个都丰富领域模型并精炼其结构(即使作为如何*而不是*做某事的一种方式)。

5.  **每当获得对领域模型的新见解时，重复步骤 4，并创建一系列可重复的步骤，这些步骤可用于持续地将领域变更部署到您的生产环境中(CI/CD 管道)。有一个好的持续部署管道可以让我们在对领域的概念理解和实现它的代码之间保持一定程度的连续性。**

每隔一段时间，往往会发生的是，在领域模型本身(一个过程，一个假定属性的重新定义映射，或者甚至是一个无处不在的语言中的项目的错误标识)中，将会有一个重要的被忽略的步骤的实现，它将大到足以强制进行重大的更新或重构来适应。它最有可能是对一些不相关的事情发生的认识，例如，一个事件被激发的效果，它使侦听器分散在多个有界的上下文中。喊出“重构我”的变更是首先要考虑的，因为它们通常掩盖了真正的深层含义，并且可能没有在当前实现的领域中得到充分的体现。

对领域的每一次细化都是创建一个领域的又一小步，这个领域代表了业务的核心价值，反映了它的沉着，并概念化了它存在的本质。这意味着应用程序的每一次更新或更改都很重要，因为每一次更新或更改都代表了对业务模型的一些洞察或理解。

#### 深入你工作的领域

如果有的话，你很可能对你刚被雇佣参与的领域知之甚少。你很可能熟悉软件开发(至少我希望如此，如果你真的得到了一份开发工作的话)，并且掌握了各种模式、框架、工具和习惯用法来帮助管理逐渐进入应用程序范围的复杂性。尽管如此，很有可能你对你工作的核心业务领域知之甚少。

我鼓励你最大程度地拥抱你公司的领域。你的目标应该是最终成为领域专家，并获得业务领域模型的深入知识。那么你将被认为是你工作的公司的资产，并且处于一个很好的位置来为该公司设计领域驱动的设计。

如果不是这样，你不知道你在做什么，你将很难为任何项目实现领域驱动的设计。毕竟，当您对领域模型本身知之甚少甚至一无所知的时候，您怎么可能构建只存在于促进它们所代表的相应业务对象的实现细节呢？这个问题的答案和几乎任何可以想象到的领域的问题的答案是一样的:你受你的领域专家的支配，因为他们是收集关于领域和业务的足够信息的关键，以实际上制作一个代表它的领域模型。与领域专家的交流肯定会有帮助，但是根据领域的复杂性，他们很容易被一个新的开发人员淹没，并且他们可能需要时间来真正掌握信息。

#### 与领域专家一起创造一种无处不在的语言

领域专家最终会成为开发人员最好的朋友，因为领域专家掌握着业务各个方面的真相，通常是在他们的头脑中。作为开发人员，我们的工作是将这些信息从他们的头脑中提取出来，放入软件中，这样知识就可以与应用程序的所有其他方面共享。从领域专家那里获取信息有一定的方法，我在下面的列表中总结了这些方法:

*   尽量不要用复杂的技术细节和开发人员行话来淹没他们。相反，尝试匹配专家用来描述业务的术语和语言，模仿他们用来描述系统的业务方面的上下文和组件。

*   做好确保澄清任何不清楚或难以理解的概念或商业模式的元素。

*   使用领域专家自己的行话作为形成通用语言的基础，并使通用语言中的结果条目存在于一个狭窄的范围内，以便其定义不会被误认为是业务方言中的另一个术语。

*   致力于建立清晰的领域模型术语定义，以及公司范围内公认的一组细节，这些细节属于使其独一无二的定义。

#### 构建一个粗略的、幼稚的领域设计

一旦您对领域的高级方面有了某种感觉，就用它来创建一个领域模型的框架草图。这将最初是一个天真的尝试，描述业务如何在技术层面上运作，但不要太关心它对于早期版本来说有多小。请记住，领域驱动的设计实际上永远不会“完成”一旦我们为 DDD 准备好了所有需要的东西，我们就可以使用与持续集成/持续部署(CI/CD)相关的技术来确保我们的领域模型不断地被精炼、更新，并且随着团队获得的新的洞察力在应用程序本身中被描绘出来(通过它在代码中的实现)而变得更好。

Note

最初，您的领域模型可以由写在纸上的各种文档、绘图和注释构成。它可以由你需要的任何东西组成，以便成功地描述业务领域，用模型来满足它。

#### 经常重构(经常失败)

伟大的托马斯·爱迪生在经过大约 10，000 次的尝试，终于成功地发明了一个能用的灯泡之后，说了这样一句话:

> *“我没有失败。我刚刚发现了一万种行不通的方法。生活中的许多失败都是因为人们在放弃时没有意识到自己离成功有多近。”*
> 
> —爱迪生

在成功的过程中，失败是不可避免的。重要的是，你从这些失败中吸取教训，并利用这些知识帮助找到可行的解决方案。因此，“快速失败”的概念不是为了成功，而是为了失败。在一次又一次的失败中，你对如何*而不是*做某事有了一个很好的想法，这会让你离成功更近一步，因为如果有的话，这是一个如何不去做的例子。因此，显而易见的是，失败得越快，你就会越快意识到实际可行的解决方案。

这是敏捷开发中的一个重要概念，因为敏捷的核心意味着不断地给予和接受反馈。信息和知识的流动应该在各个方向自由流动，从开发人员到领域专家，再到高层管理人员。快速失败给你获得洞察力的能力，即使是以*不能*快速工作的形式，这样知识可以被封装在领域模型和所有使用它的人之中。在这些领域有帮助的行业工具是 SaaS，如 Atlassian 的 Asana，再加上吉拉的任务管理和构建定制文档和操作方法库的 Confluence。其他好的产品有用于设计的 Invision，用于存储库管理的 GitHub 和 Bitbucket，用于数据库导航/设计的 MySQL Workbench 或 Sequal Pro，以及用于团队沟通和协作的 Slack。

## 技术方面

到目前为止，我一直将我们的讨论集中在 DDD 的战略部分。软件系统的“技术方面”可以被认为是*如何*并且基本上是一组结构，供您用作工具(模板)以代码形式实现您的领域模型。这些工具包括我们将讨论的各种概念，它们都基于可靠的最佳实践。

在本书中，我将为您提供一些工具，这些工具将有助于使您的代码与业务需求保持一致，从而使软件成为业务本身的翻版。我将向您展示如何依靠您无处不在的语言来构建组件，这些组件将以领域驱动的方式驱动您的应用程序和软件开发。您将学会关注业务本身的各个方面，并使用这些知识来构建您的初始领域模型的框架。然后，您将使用 DDD 提供的技术设计和实践，在代码中实际表达这些领域概念，并定义对它们的任何操作、使用它们的服务或它们所代表的数据库模式。

框架为你提供了控制器、路径、响应和其他各种各样的东西，这些东西是用来作为工具来促进应用程序中对象的交互和使用的。这些工具通常采用某种形式的对象设计模式。这些是存在于对象/类级别的模式，它们是通用的。在领域驱动设计中，有许多组件是使用一个或多个这些设计模式来建模的。例如，DDD 提出了以下架构组件来帮助您的领域层中的对象的交互和使用:

*   实体

*   工厂

*   仓库

*   价值对象

*   总计

*   域事件

*   域服务

*   模块

这些都是重要的概念，目的是通过使用最佳实践，促进领域模型，分离系统的不同关注点，并建立系统中对象存在和交互方式的一些标准。它们足够通用，不会将您工作的实际领域或上下文作为任何特定类型或方式。它们旨在为典型的 web 开发或软件应用程序项目中出现的常见业务问题提供与领域无关的解决方案。

就领域驱动的 Laravel 而言，它们对我们意味着什么，它们基本上是 DDL 的思想和实现的关键，因此被给予了充分的讨论空间(每个都用了整整一章来介绍和讨论更好的细节)。我们将研究这些并在 Laravel 中创建合理的实现，使用我们将在下一章创建的定制框架。

现在，我将使用下面的项目给你一点我到目前为止所讨论的内容的背景。

## 示例项目 3-1:仓库管理

这个示例项目将介绍一个虚构的仓库管理应用程序，我们负责从头开始开发。这个例子将作为一种指南来帮助捕捉软件的意图，获得解决软件问题所需的背景信息的知识，并形成一种无处不在的语言，然后我们将把它转换成一种粗略的架构，使其在现实世界中工作。我们将主要关注我们正在设计的系统的信息收集和高级形态。实际上，直到本书的后面，我们才开始编写使用 Laravel 框架的代码。我在示例中确实使用了 PHP 代码来演示各种概念，但是这些想法在本质上更加通用。在这一点上不需要以前有过 Laravel 的经验(但绝不会伤害！).

在知识收集阶段，我们希望以一种非平凡的、非技术性的方式关注模型。通过最初用简单的英语和流程图/图表对项目建模，我们通过延迟来摆脱设计系统需要运行的所有类、接口和对象图的开销。这允许我们用每个人(不仅仅是开发人员)都能理解的术语对领域建模。然后，我们将为所有这些常见的业务术语创建一个目录；这就是所谓的无处不在的语言。

这个业务术语和概念的目录很重要，因为它是我们将用来对系统的所有相关方面进行建模的文字基础，并且同样地，将被组织的所有成员用来传达业务思想和描述内部操作。这种语言是这个领域的核心。

Note

请理解，只有通过与领域专家和组织的其他成员进行无数次的讨论、辩论、研究和规划会议，才能完美地定义术语表中的项目。我在现实世界中看到的一种方法是让每个部门的一个人与领域专家和开发人员在同一个房间里。神奇的事情会发生。对于这个例子，我省略了这个方面。

### 需求概述

我们将建立一种仓库管理系统。假设我们有一个客户，他希望实现日常流程的自动化，以提高效率、发运更多产品并赚更多钱。他们已经有了一个模拟的、古老的系统，结合了印刷纸和手工流程。尽管订单和运输由电子商务平台管理，但该系统缺乏任何跟踪功能或库存管理，因此是手工完成的。该应用程序的所谓报告功能包括一个彩色的 Excel 电子表格，其中有各种公式和求和，只有在对公式计算中涉及的后续单元格进行正确输入后，才能进行计算。更重要的是，他们最近扩建了一个更大的仓库，这给工人完成新订单带来了新的挑战。该仓库(现在大得多)缺乏适当的产品位置管理解决方案，因此履行流程大大减慢，仅完成一个大订单就需要 10 到 45 分钟。

基本上，我们的工作是创建一个新的系统，为典型仓库的标准问题提供一个全面的解决方案，同时通过设计一个新的位置方案来解决正确的产品位置管理问题，使工人更容易找到产品并完成订单。我们将讨论如下内容:

*   订单管理
    *   库存更新/审计

    *   订单跟踪生命周期/工作流程

*   存货管理
    *   项目跟踪
        *   仓库中的位置

        *   数量
            *   *保留量*:已经被预定的产品数量

            *   *:产品在库存中准备出售的数量*

            **   *期望*:订购(延期交货)的产品数量* 

    **   项目生命周期流程/工作流* 
**   完成
    *   挑选和打包

    *   运输系统

    *   订单履行流程/工作流程* 

 *这些是我们将在这个例子中关注的中心概念。

#### 订单管理

仓库通过接收订单并向客户发货来赚钱。成功处理和运送订单所需的时间对利润有着重大影响，因此仓库需要准确、可重复和快速的订单工作流，以便实现收入目标。

目前，该仓库有一个接受订单和付款的电子商务平台，因此我们不必关心订单的下达和计费，这使我们可以专注于管理和跟踪订单的履行及其生命周期，从跟踪处理订单时必须进行的库存调整，到挑选和包装订单上的行项目并将其运送给客户。这个过程就是*订单工作流程*。

需要跟踪订单工作流环境中的状态。订单是在其整个生命周期中经历不同阶段的实体。图 [3-3](#Fig3) 显示了订单所经历的生命周期的基本流程(基于我们对订购流程正常流程的初始假设)。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig3_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig3_HTML.jpg)

图 3-3

订单工作流程/生命周期

基本上，我们有一个相当简单的订单流。你可以很容易地称之为*订单生命周期*(事件建模为图中的线条)或*订单流程*，因为它实际上并没有那么重要。重要的是在整个文档和通用语言(UL)中保持名称一致。领域专家在通用业务相关行话中使用的术语和软件模型在 UL 中约定的概念方面必须保持一致。

这通常等同于就使用哪些术语来指代哪些业务对象达成共识，并在整个组织中使用一致同意的措辞和定义。我们不能在我们的 UL 中有重复的定义，主要是因为它增加了不必要的定义副本，这只是系统中可能被错误、误传或误解的一个额外的东西。更简单和更好的方法是清楚地定义一个术语的定义，它不会以相同的形式在另一个术语的定义中共享。

Note

我们最终将在软件中创建的东西应该是生活在业务领域中的所有真实的、标准的对象和过程的镜像。有时，对一个领域进行建模会暴露出需要解决的逻辑或流程中的错误，这样相同的错误就不会出现在代码中。

回到图 [3-3](#Fig3) ，订单在在线电子商务系统上发出，仓库收到订单，并在使用自动银行和支付网关插件确认订单付款后，立即将其标记为订单待处理阶段。在此阶段，订单不被视为有资格完成(等待挑选&包装后的剩余步骤)。他们有资格进入提货&包装步骤的方式是，仓库工人核实订单上的产品实际上有库存，并且每件商品的数量可以说明。

一旦发生这种情况，订单就进入提货和包装阶段，在这里它现在位于“提货清单”上，并排队等待在仓库中实际找到商品(也称为*提货*)并将其放入箱子中运输给客户(*包装*)。发生这种情况后，可能会有一些额外的验证步骤，以确保箱子中的物品是正确的，并且数量正确，例如在将箱子打包发给客户之前直接进行人工二次检查。除此之外，包裹已经准备好运送，由快递公司(UPS，FedEx，无论什么)提供的日常取件服务运走。此时，订单最终进入订单完成阶段。这似乎是一个非常简单和半完整的模型(至少对于这个例子来说)。

Note

到目前为止，该项目的范围被有意地缩小了，这样我就可以演示如何着手在软件中建模一个领域(或者至少从哪里开始),而不用占用宝贵的页面空间来描述仓库管理系统的每个复杂方面。

#### 存货管理

现在我们已经勾勒出了订单工作流的基本轮廓，我们可以开始研究系统中的更多细节了。在现实世界中，特性和需求可能随时出现，并且在规模、范围或重要性方面完全不可预测。出于我们的目的，我们将不得不在系统中构建更多的复杂性，这将是促进和管理仓库库存的附加组件的形式(因为这是仓库*所做的*)，当然。

这意味着我们必须考虑仓库中的所有物品，以便我们能够正确管理实际数量，并获得问题的答案，帮助做出企业赖以成功的决策。库存管理的一个很好的例子是知道何时订购额外的库存，因为(很明显)如果我们没有任何库存，我们就无法完成订单。负责在典型仓库中购买卡车货物的团队使用该库存管理*上下文*提供的数据作为一种手段，来确定哪些货物需要在供应商订单上，以及应该订购多少。(这可以通过查看库存管理组件提供的*延期交货*数量清单以及涵盖过去 30 天的销售报告来确定，该清单显示了产品的近期需求。)

事实上，我们的电子商务团队很可能依赖于某种关于仓库在任何给定时间的库存产品数量的报告或通知，以便他们可以在网站上正确列出产品，并将没有库存的产品标记为“售完”(尽管这将是一些自动化的好地方)。这是一个微小的细节，在实际项目中，需要额外的澄清，因为我们有相同的数据驱动多种需求，这些需求在任何给定的时间都可能与事实的来源不同步，在这种情况下，事实的来源是仓库中实际产品的数量。我们暂时忽略这个细节，稍后再来讨论。

就像前面描述的订单管理组件有一个工作流(或状态机)一样，库存组件也有一个工作流，只适用于一个项目或产品的上下文。这里需要注意的是，库存管理组件之间必须有一些协作。

知识收集是软件建模时最重要的事情之一。它最终塑造了对象的内部结构(关于它们的命名空间)，并且是创建可用 UL 的第一步。在这个例子中，我们要稍微作弊一下，假装我们已经和领域专家讨论了足够多的内容来构建一个粗略的 UL。

#### 完成

因此，我们已经介绍了系统的订单管理方面，它将处理订单的生命周期，并跟踪从收到订单到发货的整个过程。我们还有系统的库存管理方面，它保存仓库内所有产品的记录和计数，以及它们的位置(这是一个重要的细节)。

履行将被“吸收”到订单工作流中，该工作流基本上包含最初被列为“履行”的所有项目履行流程只是一个通过其工作流程的活动订单。该工作流程的步骤如下:

1.  在订单上找到每个产品。

2.  抓取或挑选指定数量的物品(受影响的物品数量将列在“预期数量”下)。

3.  将上述物品放入包装盒中，密封包装，并通过快递寄出。

到目前为止，这似乎相当简单。有一点你可能还没有考虑到，那就是第一步的介入。在现实生活中，我在许多仓库中看到货架上产品的适当“地图”或位置参考。通常，这些知识包含在领域专家的头脑中，由于缺乏适当的文档，使得教导新员工变得极其困难。这里有一个痛点。

在我们的例子中，假设这个痛点存在，仓库工人花了太多的时间来找到产品，以便他们可以运送订单。这种情况的根本原因是缺乏一个合适的编码系统或产品地图，以帮助工人快速找到和选择货架上的商品。因此，我们需要能够充分跟踪一个项目在仓库中的位置。

### 从哪里开始

这看起来像是一下子要处理很多，但是在现实世界中，像这样的需求通常要复杂和详细得多，并且在从头开始创建一个新系统的情况下，它们似乎都是一下子向你扑来的。有时这可能会让人不知所措，我们经常太急于将这种知识从我们的大脑转移到现实世界。在这种情况下，将需求中列出的每一个关注点作为一个单独的组来开始系统的架构解决方案可能很有诱惑力(图 [3-4](#Fig4) )。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig4_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig4_HTML.jpg)

图 3-4

可能的架构分组

但是请想一想:我们已经将履行从系统的订单管理关注点中分离出来，它们确实是独立的需求，但是它们应该是同一上下文的一部分。在这种情况下，我们要做的是跟踪订单从进入仓库到离开(即发货)的生命周期。生命周期有多个阶段，从技术上讲，整个生命周期(工作流)可以被认为是订单的履行。

更好地理解堆积如山的需求和领域知识并开始区分实际需要做什么的一个方法是找到问题空间和解决方案空间在哪里。

#### 问题空间

问题空间可以被认为是公司想要解决的所有事情。它包含需求，并被分解为域和子域。在我们的例子中，问题空间包含我们的仓库管理软件的三个主要组成部分:订单管理、库存管理和履行。基本上，图 [3-5](#Fig5) 中的图表可以很好地代表问题空间，或被认为是完整的项目所需的主要目标/验收标准，只要它在一个子域中有两个相似的要求。从现在开始，我们将把问题空间中的这三个项目称为模型的子域。一旦我们做了这样的调整，我们就会明白，事实上，有两个子域可以从需求列表中派生出来。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig5_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig5_HTML.jpg)

图 3-5

问题空间

#### 解空间

如果你还没猜到的话，解空间是解决我们之前列出的子域中的问题的结果。为了知道从哪里开始根据项目的需求建模您的解决方案，您可以为每个子域建模一个解决方案组(也称为*有界上下文*)。在我们的例子中，我们得出结论，这个项目存在两个有界的上下文，每个子域一个(图 [3-6](#Fig6) )。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig6_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig6_HTML.jpg)

图 3-6

通过子域定义的解空间

Note

一般的经验法则是每个有界上下文有一个子域，但是如果项目不是非常复杂，那么可能不需要所有的子域(每个问题空间都需要一个有界上下文来解决)。

在以这种方式分割项目时，我们可以清楚地了解到*需要完成哪些*工作(尽管没有任何特定子域优先级的指示)。我们还可以得到一个领域模型结构的基本概念，我们需要创建这个模型来以逻辑和领域驱动的方式充分地解决问题。这意味着努力实现可重用性，并通过细化和重构创建一个丰富、健壮的领域模型，最终建立一个领域的可靠表示，建模为软件组件。

#### 创造一种无处不在的语言

既然我们已经定义了我们的项目需要解决的问题，以及解决这些问题需要哪些解决方案，我们就可以开始为软件创建一种无处不在的语言，这种语言来源于领域知识。

请注意(正如我所提到的),真正的 UL 只有在与领域专家进行了无数次的讨论之后，并且在领域中实现或产生了额外的洞察力时，通过重构业务术语的定义才能实现。

我们需要马上定义两个重要的术语。

*   *Order* :一个收到的表单，包含客户要求的产品及其相应数量的列表

*   *库存*:所有每件产品在仓库的*位置*和可供销售的*数量*的日志

添加完这些之后，我们还应该添加一些额外的术语。

*   *产品*:仓库中销售的单品；包含项目的价格、名称和简短描述等数据

*   *订单行*:属于一个订单的单行，由一个产品和该产品的数量组成

Note

请记住，这些不是我们的域对象，也绝对不是我们将在代码中使用的类，尽管其中一些很可能是，比如一个`Order`和`Product`。

UL 可以说是软件设计中最重要的事情。它是我们正在构建的整个平台的基础，将在整个公司范围内以定义如何与业务相关的方式为人所知。我们需要随时更新我们的模型，即使这意味着删除或更改 UL 中的术语，以更好地反映它们所源自的业务概念。

实现这一点的方法是不断地将 UL 和域模型作为一个整体进行重构，以最好地表示业务操作中涉及的业务对象和流程。即使在每次冲刺和每次拉取请求中，我们也在不断地重构应用程序，使其变得更好。我们希望我们的 UL 也是这样，这就是为什么我会在我们进行的过程中对它进行修正和修改。

#### 定义要构建的内容

因此，我们有一个粗略的 UL，它似乎反映了用于描述问题空间和解决方案的总体措辞。它们在 UL(可以是文档、电子表格、纯文本文件或纸张)中清楚地表达出来，并且用领域专家和开发人员已经同意的术语来定义。那全是肉汁！

下一步是了解为完成应用程序所需的特性而发生(和需要发生)的操作。我们可以利用这个例子开始时给出的需求，用它们来描述我们希望应用程序做什么，以及它应该如何做。最好用简单的英语组成完整的句子，用无处不在的语言来描述每个需求。我们从用户的角度出发来形成句子，以捕捉他们的需求(这些被称为*用户故事*)。

*   作为一名运营助理，我希望能够快速导航到产品在仓库中的位置，并能够快速识别货架上的产品，以便准备好订单进行发货。

*   作为一名仓库管理员，我希望能够在仓库中找到一件商品，并以一种非侵入性的方式调整它的库存，这样我就可以让每一个正在增长的仓库都有存货。

*   作为销售代表，我希望能够快速识别产品及其库存水平，以便与客户协调订单。

*   作为运营经理，我需要实时跟踪产品数量，包括我们当前拥有的数量、从供应商处订购的数量以及正在订购的数量，以便我可以解决业务问题。

浏览这些用户故事，我们可以对我们将要创建的功能有一个很好的想法，并且可以开始按照领域驱动设计中使用的一些可靠的模式来组合一些实际的架构。

图 [3-7](#Fig7) 显示了它们在我们之前的有界环境图上的位置。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig7_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig7_HTML.jpg)

图 3-7

从用户故事到有界上下文的映射

#### 工作流程/生命周期

似乎我们需要定义两个生命周期工作流:一个用于订单上下文，另一个用于库存上下文。我们需要的是一种通过这些转换来跟踪订单状态的方法，以便在状态(阶段)之间创建一个“流”。我们要做的在计算机科学中被称为*工作流网*，它是 *petri 网的衍生物。*

工作流由*状态*以及作用于一个状态到达下一个状态的事件(即转换)组成。转换对我们很重要，因为它们包含了对于底层实体所处的特定状态，哪些转换是有效的规范。它定义了状态和转换如何交互，并且是我们将用来控制我们的工作单工作流的。

##### 订单工作流程

在本章的开始，我给了你一个工作流程，`Order`对象将从头到尾经历这个流程，它非常适合我们的状态和转换模型，因为它们已经被分解了。在订单工作流的情况下，我们可以假设以下状态:

1.  已下订单

2.  订单待定

3.  挑选和打包

4.  订单已发货

5.  订单完成

对于每个状态，我们需要指定可以对其执行的事件或转换，以前进到下一个状态。这里有一个例子:

*   从阶段 1 进入阶段 2 需要支付*费用*。

*   从阶段 2 进入阶段 3 意味着产品已经*确认*有货。

*   从第 3 阶段进入第 4 阶段需要将订单从货架上取下，并装入客户会收到的箱子中。

*   从阶段 4 转到阶段 5 将表明订单已经通过快递卡车成功发送给客户。

我们也将使用这种基本格式来创建产品的生命周期。

##### 产品工作流程

简而言之，产品的生命周期始于产品在接收码头被接收，产品在接收时被登录到系统，该产品的正确数量条目将被更新(但仅当该产品已经在系统中时)。如果是，我们可以假设已经有一个与之相关的量。让我们假设这些数量的计数是正确的(即，预期计数的数量是准确的)，这意味着我们将从系统帐簿中的预期数量计数中减去收到的数量，然后将该数量添加到该产品的可用数量计数中。

如果产品对系统来说是新的，我们必须在系统中为该产品创建新的记录，然后将收到的数量添加到该产品的可用数量计数中。我们可以马上看到，在系统中创建一个新产品并不像接收一个已有数量那样简单。我们很可能需要建立一个系统，在那里接收方可以输入新产品的规格，并可以将其添加到库存日志中，以供将来跟踪。现在，我们将忽略这种复杂性，只假设进入仓库的每个产品都有一个现有记录。

之后，产品被放在一辆手推车上，仓库保管员用它将产品放在仓库中各自的位置。它将在货架上以“可用”的状态等待，直到收到一个订单，该订单中有该产品的一行。此时，在操作人员从货架上拿起产品后，数量会进行调整，并将产品的最终状态标记为“产品已售出”图 [3-8](#Fig8) 提供了产品工作流程图。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig8_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig8_HTML.jpg)

图 3-8

产品工作流程/生命周期

Note

这将是一个很好的机会来停下来，将我们在过去几页中建立的产品工作流和订单工作流这两个新概念，以及这两个概念的简短而准确的定义，添加到这种无处不在的语言中。

##### 完成

这列在软件要求中；我们之前决定“履行”只是一个订单通过其典型的工作流程。我们在订单约束的上下文中捕获了对履行的关注，因此我们可以从 UL 和系统中消除履行的概念，而只使用“订单工作流”来表示相同的东西。系统中的对象越少，我们在以后调试时需要跟踪的东西就越少。

提货和打包阶段也是如此，它属于订单上下文，甚至存在于订单工作流本身。因此，我们可以将挑选和打包的行为放在域工作流中，但是围绕挑选和打包阶段的数据值得探究。图 [3-9](#Fig9) 显示了我们的上下文和它们支持的特性的图表。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig9_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig9_HTML.jpg)

图 3-9

有界上下文

##### 产品位置

如本例前面所述，仓库工作人员面临的一个棘手问题是，他们要花很长时间才能找到仓库中数千个货架中的一个。作为一个小练习，我们将提供一个合理的解决方案，它将有助于确定任何给定产品的确切位置，以便挑选和包装。这是一个不使用代码提供问题解决方案的例子。记住，代码是最后的手段。

为了给这个例子添加一些上下文，让我们假设这个仓库运输鞋子。该仓库占地 10，000 平方英尺，其中约 8，000 平方英尺用于存储产品。我们需要一种方法来快速识别仓库中的一只鞋。这意味着我们需要某种类型的编码方案，附加到每个产品上，指定它在仓库中的位置。

Note

在本文中，我交替使用术语*鞋*和*鞋*来表示一双鞋(显然，我们不需要一双单独的鞋...除了可能扔向政客之类的)。

首先，让我们更深入地思考这个问题。鞋子都需要在合理的时间内定位，所以我们显然必须组织鞋子来分解这个组织问题。基本上，我们需要将仓库和订单处理这个大问题分解成更小、更易管理的工作单元。一种方法是通过观察领域模型中概念自然分离的方式。我首先想到的是性别。鞋子的性别是分割库存最明显的方式。看似简单直接的分离，就是直到我们发现某些鞋品牌只做女鞋，有些严格意义上的男鞋，有些两者都有。

Note

目前，我们不打算考虑鞋子的模型，这在像这样的真实世界项目中通常是必须考虑的。我们只是暂时推迟它。

我们仍然可以让性别分离起作用，这将会给我们类似图 [3-10](#Fig10) 的东西。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig10_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig10_HTML.jpg)

图 3-10

按性别和品牌分隔仓库

唯一需要注意的是，单一品牌可能会有重复的位置，这对于企业来说可能是问题，也可能不是问题，完全取决于其特定需求。无论是哪种情况，我们都将依靠与领域专家的对话来确定这个仓库方案对于公司的日常运营是否可行。

领域专家告诉您，我们所描述的布局将会起作用，因为性别是附加到任何鞋子上的，所以我们可以使用它根据鞋子的性别来划分仓库。只要有一个足够的系统来跟踪和标记鞋子在仓库中的位置，重复的品牌就不会有太大的问题，这取决于品牌和性别。

#### 身份

因此，我们需要拿出一个易于阅读的仓库示意图，将每只鞋分开，这样就不会有两只鞋有相同的标识符。我们可以假设需要有一个与每只鞋相关联的内部密钥形式的*身份*,该内部密钥可以在系统的其余部分中作为一种识别手段使用。让我们给鞋子一个*内部生成的身份*。

在思考了这个生成的身份之后，你就有了智慧的储备。这里我们需要的是一个条形码系统！这将允许我们通过以条形码的形式给每只鞋分配一个身份来跟踪每只鞋。为了确保唯一性，我们决定使用 UUID 方案，该方案可以使用第三方包轻松转换为条形码(要查看可用选项，请在谷歌上搜索 *Laravel 条形码生成器*)。

所以，条形码系统是正确的选择。然而，有一个问题。UUID 方案根本不是人类可读的，因为它的标准格式是 16 进制的 32 个十六进制字符(这里有一个例子:123e 4567-e89b-12 D3-a456-426655440000)。那并不完全是从舌尖上滚出来的。如果(不管出于什么原因)我们需要在没有条形码扫描仪的情况下找到一只给定的鞋*的位置，这也会引起一个问题。*通常，我们会发明某种 UUIDs 到货架上位置的内部映射，这只能通过扫描条形码并从内部数据库中检索产品位置来推断。简而言之，它将使鞋子的位置直接与条形码扫描仪相连。对于某些人来说，这可能是一个好的解决方案，但是对于这个例子，我们可以做得更好。

我们想要创造一种标准的方式来识别仓库中的鞋子，这种方式既可以扫描条形码，也可以被人类读取。我们放弃了 UUID 的实现，而是决定创建自己的实现。该方案必须有性别、品牌和尺码信息，以清楚地表明这是什么鞋。然后我们可以将这个代码与仓库货架联系起来，每个货架代表一组特定的鞋子。

我们很快就拼凑出了编码系统的草图。

```
(gender: m/f) - (brand: first 4 letters) - (size: 2 digit integer)

```

这似乎涵盖了几乎所有的要求。它内置了三个数据点，没有条形码扫描仪的人也能轻松阅读和理解。唯一的问题是，相同性别和尺码的同一品牌的鞋子会有完全相同的身份证号码。这是不好的，因为我们希望唯一地标识每只鞋。

考虑到这一点，我们对编码方案进行了修改。

```
(m/f) - (brand: 1st 4) - (size: 2 digits) - (Unix timestamp)

```

我想我们可能有一个可行的解决方案。通过将 Unix 时间戳添加到 ID 号的末尾，我们保持了一种独特的方式，除了保持人的可读性之外，还可以将一只鞋与大型仓库中的所有其他鞋区分开来。

图 [3-11](#Fig11) 显示了一双鞋的分解识别号。(我意识到最后一句话在任何其他背景下都毫无意义，但在这里却行得通。)

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig11_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig11_HTML.jpg)

图 3-11

每只鞋的唯一标识符的分解

Unix 时间戳保证了每双鞋都需要我们的唯一标识号，至少虚拟地说是*，因为可能有两个相同的新产品在同一时刻被添加到系统中，从而产生相同的唯一标识符。然而，这种情况在现实生活中发生的几率很小，不足以承担这个风险。这很可能永远不会发生。*

 *既然我们对进入系统(即接收)的每双鞋都有了一个标准身份，我们需要将这个字符串转换成一个条形码，以便于扫描和检索。

#### 生成条形码

因为条形码只是用来区分每件产品，所以所有的工作基本上都已经完成了，因为我们已经为鞋子创建了编码方案，可以唯一地识别它们。现在，开始将该计划付诸实施所需的全部工作就是从该身份信息生成条形码。一种方法是使用 QR 码(或“快速响应”码)。

二维码是通用的，受到很好的支持，可以保存我们想要的任何数据，包括一双鞋上的识别字符串！在这一点上，我们不会过多地讨论实现细节，但是如果您有兴趣，您可以在 Google 上搜索 Laravel QR 条形码生成器，以找到一个支持库，该库将自动处理从身份到条形码图像的转换。这是像这样的系统在生产中工作的最终要求，主要是因为条形码需要在识别时打印出来，并实际放在鞋盒上，所有的数据点都包含在识别号中。图 [3-12](#Fig12) 显示了翻译标识符 M-VANS-105-156756631 产生的二维码。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig12_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig12_HTML.jpg)

图 3-12

从字符串 M-VANS-105-1567566317 生成的条形码图像

这是一个非常方便的解决方案，基本上可以应用于任何需要跟踪或说明的事情。最棒的是，你可以将任何数据编码到这个条形码中！无论你用什么来生成图像，都可以在你用条形码应用扫描后被解密。(您可以将手机用于开发目的，但在现实世界中，出于性能和人体工程学的原因，您可能需要购买一些专业的 3D 条形码扫描仪。)在我们的例子中，我们可以使用前面创建的身份编码方案来生成一个有效的、人类可以理解的、唯一的字符串，该字符串可以被扫描仪转换和反转。

#### 消除隔阂

到目前为止，我们有以下内容:

*   每只鞋的唯一标识符

*   一个格式良好的字符串，表示人可识别的标识符，其中包含各种信息(性别、大小和品牌)。

*   一种创新且经过深思熟虑的读取条形码的方法

我们一直忽略了什么？实施细则！

到目前为止，还不清楚条形码系统在实践中如何工作。具体来说，我们在实际运行系统后端的软件和它们所基于的业务规则之间存在持续的脱节。我们需要详细说明货架组织的细节，以及我们如何使用条形码系统来管理这些细节。

##### 搁置系统

我们决定的搁置方案需要支持人类可读性，就像我们的产品标识符一样。为了让系统自主工作，我们需要一种方法来将给定的货架与仓库中的一部分产品关联起来。在我们的案例中，已经通过性别和品牌进行了细分。我们只需要我们的仓库在物理上反映这个限定符。

让我们根据鞋企在货架上的位置，用理论数量来划分仓库(图 [3-13](#Fig13) )。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig13_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig13_HTML.jpg)

图 3-13

仓库结构草图

这可能行得通，但有人可能会说，你不知道任何特定品牌的*多*会占据更多空间(如果有的话)。如果公司是新成立的，这将是一个合理的担忧，但实际上，你如何知道在任何给定的时间内，任何特定品牌将有多少在仓库内，以及你应该以什么间隔将品牌彼此分开？

鉴于我们正在进行的“代码作为最后手段”的教训，我认为这个问题可以通过查看去年的销售报告并估计大致相同水平的库存来轻松解决。

图 [3-13](#Fig13) 中的草图描绘了按品牌划分的仓库货架(实际上不止四个，但请配合我的工作)，空间为所有品牌平均分配。这可能是一个解决方案，但是性别呢？我们在条形码标记中有性别，所以我们可以用它来区分实物库存。见图 [3-14](#Fig14) 。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig14_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig14_HTML.jpg)

图 3-14

按性别划分的品牌

如图 [3-14](#Fig14) 所示，品牌本身分为男鞋和女鞋。这给了我们所有可能的产品组合(假设只有四个品牌)。

### 真实世界的场景

你是一个仓库保管员，有一批鞋子要收货。收货人负责将物品及其数量记录到系统中，这意味着每个箱子上都有一个条形码供您扫描。然而，贵公司的网络开发人员相当聪明，他们在图片上方加入了英文版的条形码。这些鞋子属于以下类别:

```
W-GLB-65-1567566899

```

你告诉自己，“没问题，我有这个，”并对自己读代码的翻译版本:“女性地球仪，大小 6.5。”你去指定的货架拿着所有的 Globe 牌鞋子，去 Globe 的女款那一半，用它做什么？

哦不！我们忽略了系统设计中的一个关键细节。我们对货架问题的探索还不够深入。我们停在了一个更粗粒度的解决方案上，这在实现中留下了一个漏洞。不过，这没什么大不了的，因为所要做的只是向系统中添加另一个数据点，作为整理鞋子的额外划分。

我们可以用什么来分隔鞋架上的鞋子，每双鞋子都有，而且每双鞋子之间的差异足够大，因此可以作为一个很好的分隔机制。如果你还没猜到，很简单:大小！

精彩的演绎，华生！我们可以按性别分割每个货架区，每个货架由一个品牌的鞋子组成，并分成不同的“尺寸洞”(坦率地说，它们是什么；我想用我能想到的最直接的方式来称呼它)。

图 [3-15](#Fig15) 只是对鞋子组织问题的一个更详细的示例解决方案，鞋子的尺寸是鞋子属性的最终区别因素，因此它可以用作进一步分离进入仓库的大量鞋子的手段。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig15_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig15_HTML.jpg)

图 3-15

通过鞋码组织个人货架

该图是货架上单排鞋号*的布局。大小之间的间隔马上会成为问题，这是一个需要咨询领域专家的细节。*

作为程序员，我们可以也确实对我们正在做的工作做一些假设。这对于开发来说非常好。如果出现软件必须考虑的情况，但无法以精确的方式定义或当时未知，则进行有根据的猜测，并用此猜测值填补缺失的空白，直到您有机会回顾并确定正确的结果，这通常是通过与领域专家的进一步交谈来实现的，或者可能需要更大程度的投资来确定。

让我重新表述一下我之前说过的话:假设作为尚未知晓的价值/过程的占位符是完全可以的，假设创建它的团队/个人有定期的代码审查和技术债务消除会议，并为重构分配足够的时间。这些应该定期发生，有宗教信仰。

在与领域专家讨论了每个品牌的每个尺码应该有多大的空间后，你已经明白应该将它们分成不同的鞋号组，如图 [3-16](#Fig16) 所示。

![../images/488324_1_En_3_Chapter/488324_1_En_3_Fig16_HTML.jpg](../images/488324_1_En_3_Chapter/488324_1_En_3_Fig16_HTML.jpg)

图 3-16

属于一个品牌的每个货架的鞋号分布

这一尺码分布表明，大多数男性的尺码将在 9 至 11.5 之间。还有一个适合儿童尺寸的地方(在这种情况下，是男孩)。在这种情况下，我们假设组织因素应该是什么，我们的设计是正确的；然而，我们不知道如何以最适合业务的方式对货架系统进行建模，所以我们对其可能的样子进行了合理的估计，然后我们在有时间与领域专家讨论此事时再次对其进行了修改，他们让我们知道应该根据尺寸的流行程度来划分尺寸，我们能够在图 [3-16](#Fig16) 中正确地描绘出这一点。

## 结论

这一章占据了相当多的页面，主要是因为我们的示例场景(顺便说一下，我们已经完全解决了)。在编程中，我们经常面临与代码质量、时间估计和开发成本相关的选择。向三角形的四分之一倾斜会导致对另一个的轻视。随着时间的推移，质量、成本和时间总是会成为你能更好估计的问题。

此外，我们检查了一些可能的火灾，这些火灾可能是由于没有正确地维护您的代码库以及没有频繁地参与代码评审而引起的。不重构通常也属于这一类。只有在正确的开发周期中，并且组件设计是迭代的，由小的胜利和“低挂的果实”组成，DDD 模型才能很好地工作将较大的问题分割成较小的部分，使得为其开发解决方案变得更加容易和易于管理。试图将不同的组件混为一谈可能会导致灾难，如果关注点分离的原则对系统整体策略的*上下文轮廓*有意义的话，应该总是尝试。

我在本章中创建的例子很好地为我在本章第一部分中表达的观点提供了一些背景。我们经历了一个场景，在这个场景中，我们必须设计一个鞋类仓库，该仓库要为运行操作(即，促进订单)正确地设置，正确地跟踪库存，并提供一种组织货架的方法。我们决定使用 3D 条形码形式的技术，在每只鞋上正确地生成一个加密代码，以表明它在仓库中的相对位置。我们已经使入库功能变得更加可行，而且整个流程也更加严谨，以便在现实世界中发挥作用。我们设计的实现的某些细节被忽略了，这在现实世界中是绝对行不通的。通过领域专家的频繁对话和确认，确保您走在正确的方向上。他们是你在大多数领域相关问题上的真理来源。文档也可以根据领域专家对给定概念或过程的想法来编写。我们可以使用逻辑对开发进行有根据的猜测，但是一定要确保定期重新审视设计，并对您正在使用的值和变量(或者您当时选择忽略的细节)建立适当的约束。

顺便提一下，这个例子来自我作为 PHP 开发人员工作过的一家公司。我省略了一些次要的细节，以便更好地关注我在本书中已经讨论过的概念。

Note

我确实遗漏了一个细节，即“挑选和包装”问题，工人们不得不花费太多时间在货架上寻找特定尺寸和品牌的鞋子。我将把这个留给你去思考，并提出可能的解决方案。你应该考虑的是如何在比我们之前设计的架子系统更精细的细节层次上表达鞋子的位置。

现在我们已经有了系统的设计，我们将在以后继续关注技术问题...但是，首先，介绍一下拉勒维尔。***