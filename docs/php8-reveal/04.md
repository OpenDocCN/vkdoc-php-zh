# 4.重新分类引擎警告，或者我如何学会停止担心并记录错误

日期:2019-08-27

作者:尼基塔·波波夫

投票:投票是按照特定的方法和警告

尽管 JIT 可能是 PHP 8 中的头条新闻，但是对引擎警告进行重新分类还是值得注意的。警告一点也不特别性感或有趣。PHP 8 的这一增加引起了很多讨论，主要集中在记录错误上:错误是 bug 吗？我们应该用代码保存这些吗？我们需要强迫人们编写没有 bug 的代码吗？这件事很快就变得复杂了。从表面上看，这只是几个函数以及它们如何报告错误的提升和转移。担心的原因是，现在我们有可能让已经在生产中运行的代码用“不必要的”(那是另一个蠕虫的罐子)错误填满日志文件，在最坏的情况下导致 PHP 停止曾经工作的代码。当然，通过设计，我们可以关闭日志和错误报告，随心所欲地编码。但是代码呢？如果有错误，那就意味着有 bug。为什么你不能修复这个错误，这样你的代码就不会再“中断”了？PHP 的基础在于不太严格的开发风格。一些成员认为这是对 PHP 创造的文化的攻击。不管怎样，这正在发生，我们需要看一看。以下是三个有问题的发动机警告:

*   `E_ERROR:`不可恢复，将停止编码。

*   `E_WARNING:`非致命错误，代码将继续。

*   `E_NOTICE:`非致命，表示可能存在问题。

然而，这种情况的发生方式是，如果你的生活有赖于去哪里吃午饭，从议会交流变成了群聊辩论。一方面，我们有善意的波波夫，他正在游说发起一场运动来“清理”PHP 在错误日志中发出的警告和错误通知。进入苏拉斯基和抵抗组织，站在 PHP 发展的历史和基础理解上。Suraski 也是创建通知系统的主要部分。许多其他的声音也支持严格的语言和编程最佳标准。这些声音指出，这种变化将把一个普通的通知变成一个更严重的警告，通过将可能的错误与非关键的错误结合起来，把水搅浑。结局很值得一读，看看我们的结局如何。不过，首先让我们看看 RFC。

在 RFC 中，Popov 指出，“我们有许多旧的错误条件，由于历史原因，它们使用了不适当的严重级别。例如，访问一个未定义的变量，虽然是一个非常严重的编程错误，但只会产生一个通知。”他确实认识到，在 PHP 的新版本中，错误得到了更好的处理，PHP 中错误“指导原则”的现实是“我们没有任何关于此事的现有规则，下面是我在下面的重新分类中尝试遵循的一些通用指导原则。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

**消息**

 | 

**当前电平**

 | 

**建议水平**

 |
| --- | --- | --- |
| 尝试递增/递减非对象的属性“%s” | 警告 | 错误异常 |
| 试图修改非对象的属性“%s” | 警告 | 错误异常 |
| 试图分配非对象的属性“%s” | 警告 | 错误异常 |
| 从空值创建默认对象 | 警告 | 错误异常 |
| 基本原理:当在写入上下文中访问非对象的属性时，会产生这些错误。如果非对象为“真”,则生成警告并忽略操作，如果为“假”,则创建一个空的`stdClass`对象。虽然自动验证是数组语言的核心部分，但对象却不是这样，在非对象上创建属性几乎肯定是编程错误，而不是有意为之。 |
| 试图获取非对象的属性“%s” | 通知；注意 | 警告 |
| 未定义的属性:%s::$%s | 通知；注意 | 警告 |
| 基本原理:第一个警告是针对与上面相同的情况，但是是针对读上下文。这被归类为警告，因为它通常表明一个编程错误(在现代代码中，所有非神奇的属性往往是已知的和固定的)。然而，对象属性也可以是动态的(例如，对象形式的 JSON)，在这种情况下，访问未定义的属性可能是不太严重的问题。一般来说，PHP 对“丢失”数据的读访问有些宽容。 |
| 无法将元素添加到数组中，因为下一个元素已被占用 | 警告 | 错误异常 |
| 基本原理:当试图推入已经使用了`PHP_INT_MAX`键的数组时，会出现这种错误情况。这种错误情况在巧尽心思构建的代码之外几乎不会发生，如果发生，则意味着数据丢失。因此，它被更改为异常。 |
| 无法在非数组变量中取消设置偏移量 | 警告 | 错误异常 |
| 不能将标量值用作数组 | 警告 | 错误异常 |
| 试图访问类型为`%s`的值的数组偏移量 | 通知；注意 | 警告 |
| 基本原理:这些诊断是在试图将标量用作数组时生成的。前两者发生在写上下文中，后者发生在读上下文中。后者是在 PHP 7.4 中作为一个通知引入的，其明确意图是提升 PHP 8.0 中的严重性。与对象的对称情况一致，写情况在这里被更严格地对待，因为它通常意味着数据丢失。 |
| 只有数组和可遍历对象可以解包 | 警告 | TypeError exception |
| 为`foreach()`提供的参数无效 | 警告 | TypeError exception |
| 基本原理:这些是简单的类型错误，应该这样处理。 |
| 非法偏移类型 | 警告 | TypeError exception |
| isset 中的非法偏移量类型或为空 | 警告 | TypeError exception |
| 未设置中的非法偏移类型 | 警告 | TypeError exception |
| 基本原理:如果一个数组或对象被用作数组键，就会产生这些错误。这又是一个简单的类型错误。 |
| `%s`重载元素的间接修改没有效果 | 通知；注意 | (通知) |
| 重载属性`%s::$%s`的间接修改无效 | 通知；注意 | (通知) |
| 基本原理:如果`__get()`或`offsetGet()`返回一个非引用，就会出现这些通知，但是是在写上下文中使用的。因为我们对写上下文的检测现在有误报，所以在我们能够确定诊断始终是合法的之前，这些应该是值得注意的。 |
| 无法将类`%s`的对象转换为 int/float/number | 通知；注意 | (通知) |
| 基本原理:对象和标量之间的比较目前是通过将对象转换为适当的类型来实现的，这就是为什么像`$obj == 1`这样的比较目前也会引起注意，尽管它们不应该引起注意。在这一问题得到解决之前，通知的分类应保持不变。 |
| 遇到非数字值 | 警告 | (警告) |
| 遇到格式不正确的数值 | 通知；注意 | (通知) |
| 基本原理:这两个警告的区别在于一个字符串是完全非数字的，还是有数字前缀。这是一个基于操作中涉及的特定字符串值的运行时问题，可能是用户控制的。因此，我们不提倡例外。 |
| 将静态属性`%s::$%s`作为非静态属性访问 | 通知；注意 | (通知) |
| 基本原理:这个通知在它所做的事情上有些混乱:它是在访问`$obj->staticProp`时抛出的，但实际上并不读取静态属性。相反，它将回退到使用名为`staticProp`的动态属性。在这方面有更多的不一致性，因为访问对象上受保护的静态属性将生成一个错误异常，即使它实际上不会访问该属性。我不知道该怎么办，但我倾向于不去管它。 |
| 数组到字符串的转换 | 通知；注意 | 警告 |
| 基本原理:这通常是一个错误(你得到的“数组”字符串是没有意义的)，但在很多情况下也不是特别严重。既然现在支持[字符串转换异常](https://wiki.php.net/rfc/tostring_exceptions)，我们也可以将其升级为错误异常，我通常对此持开放态度。 |
| 资源`ID#%d`用作偏移量，转换为整数(`%d`) | 通知；注意 | 警告 |
| 基本原理:原则上，这是一个有意义的操作，但也非常奇怪，应该用显式的整数强制转换来表明意图。 |
| 出现字符串偏移转换 | 通知；注意 | 警告 |
| 非法字符串偏移量`'%s'` | 警告 | (警告) |
| 基本原理:前者在使用 null/bool/float 作为字符串偏移量时抛出，后者在字符串不是整数时抛出。这两者应该使用相同的严重性。 |
| 未初始化的字符串偏移量:`%d` | 通知；注意 | 警告 |
| 非法字符串偏移量:`%d` | 警告 | (警告) |
| 基本原理:前者在读取越界字符串偏移量时使用，后者在写入越界负字符串偏移量时使用(对于正偏移量，字符串被扩展)。与未定义的索引/属性一致，我们在这里始终生成一个警告。 |
| 不能将空字符串赋给字符串偏移量 | 警告 | 错误异常 |
| 基本原理:该操作没有意义，表明存在某种逻辑错误。 |
| 只有变量应该通过引用传递 | 通知；注意 | (通知) |
| 只有变量引用应该通过引用返回 | 通知；注意 | (通知) |
| 只有变量引用应该通过引用产生 | 通知；注意 | (通知) |
| 只有变量应该通过引用来赋值 | 通知；注意 | (通知) |
| 试图将引用设置为不可引用的值 | 通知；注意 | (通知) |
| 无法通过解包可遍历对象来传递引用参数`%s%s%s()`的`%d`，而是传递值 | 警告 | (警告) |
| 基本原理:在需要引用的地方使用值目前有些不一致，根据具体情况，从编译器错误、错误异常、警告和通知都有可能。将非变量传递给引用参数通常是一个编程错误，因为无法修改传递的值，引用也无法达到其目的。然而，这由于可选的引用参数或可选的引用返回值而变得复杂。在这两种情况下，警告都可能是误报。这里不太清楚要做什么，所以我现在保留当前的分类。 |

*   错误异常应该是指示编程错误的错误条件的基线。

*   如果期望某个错误条件通常被有意抑制，特别是在遗留代码中，则不应该使用异常。

*   如果错误条件是数据相关的，最好不要使用异常。

*   对于已知误报的错误情况，应使用通知。

*   避免从通知直接升级到错误异常。我只是针对未定义变量的情况提出这个建议，因为现在它被严重地错误分类了。

虽然这个列表看起来很全面，但是有三个错误条件在 PHP 团队中引起了争议:未定义的变量、未定义的数组索引和被零除。波波夫以此开头:“我认为是时候看看我们现有的引擎中的警告&通知，并思考它们当前的分类是否仍然合适。像‘未定义变量’这样的错误条件只会产生一个通知，这真的令人难以置信。”引发了这次交流。

> *是否会包含* `$$foo`等动态声明的变量？
> 
> *——Lynn van der Berg*

> *专门针对未定义的变量，我们处理它们的方式与* `register_globals` *关系不大。您可以在其他动态语言(例如 Perl)中找到这种行为，并允许特定的代码模式(在写入上下文中使用时，依赖于变量的自动创建，在读取上下文中使用时，依赖于预先知道的默认值)。不喜欢这种行为或者通常依赖于它的代码模式(例如* `@$foo++` *)是可以的，但是这是有意的，与任何历史原因都没有关系*。
> 
> *-沙瓦尼亚语*

> *这个论点对数组和对象有意义(出于这个原因，我不会将未定义的索引/属性提升为异常)，但我不认为它对简单变量有任何意义。编写* `@$counts[$key]++` *是一种懒惰的方式来计算值，避免* `if (isset($counts[$key])) { $counts[$key]++; } else { $counts[$key] = 1; }` *的难看的样板文件。但是* `@$foo++` *无论是* `$foo++` *还是* `$foo = 1` *都只是一种非常糟糕的写法。在可变变量之外，条件定义变量的概念没有太多意义*。
> 
> *—Nikita Popov*

> 我所要求的只是一个清晰的升级路径，这样我的代码就可以随着时间安全地迁移，而不是在下一个版本中崩溃。相比<？php vs <？，这将打破了很多，不容易修复。通过让它抛出我们可以轻松记录到特定文件中的反对意见，当我们有时间花在技术债务上时，我们可以收集并修复案例，等到警告变成错误异常时，我们可能已经修复了 90%以上的案例，使升级成为可能。
> 
> *——Lynn van der Berg*

> *我们经常使用* `$a .= "xy"` *或* `$a[] = "xy"` *的模式，要求初始化会导致通常非常简单的函数中的 boiler-plate 代码，或者更糟糕的是将第一个代码写成* `$a = "xy"` *和* `$a = ["xy"]` *，这两者都损害了对称性和可扩展性(如果要添加新的第一个条目，需要更改两个位置)。我们已经取消了* `E_NOTICE` *，因为这个模式对填充我们的日志*太有用了。

> 静态分析器可以很好地捕捉到变量名中的简单输入错误，我们的 git 提交钩子中有一个简单的错误，它为我们做了很多工作。在一般情况下，它甚至做得更好，因为它还捕获了测试中不执行的罕见代码路径中的错别字。不，不要说“确保你有 100%的代码覆盖率”，那是一个神话。

> *总结:将* `E_NOTICE` *提升为* `E_WARNINGS` *，罚款，让他们中止代码执行:不要做，不要破坏我们的代码*。
> 
> ——基督教裁缝

> *这个例子与数组无关。在许多代码模式中，依赖这种行为对于那些思想不那么严格的人来说非常有意义。例如:* `foreach (whatever) { if (sth) { @$whCount++; } }`

> *是的，对于许多人来说，* `$whCount` *没有显式初始化可能是痛苦的，但上面的代码是完全合法的，永远没有警告通知的代码。此外——这不是遗产——有很多人欣赏这种精确的行为，这种行为在过去 20 多年里被记录在案并按预期工作。*

> 称之为“清理”是固执己见的，通过将这种观点强加给每个人来避免分歧对于那些有其他观点的人来说不是一个很好的解决方案。虽然在初始化之前不能使用变量的观点显然是一个有效的观点——仅仅是一个有效的观点——还有其他的观点。
> 
> *-沙瓦锡*

这很有可能是多年来给 PHP 带来坏名声的心态。

Suraski 然后把情况分解成一个开发者的权利问题。这是交流中最有说服力和最基本的 PHP 论点之一。

> *PHP 从未将这一观点视为公理化的要求(并不是因为*`register_globals`*)——相反，其意图是为未初始化的变量提供默认值——这是自该语言诞生以来一致的、有据可查的行为。这在某些情况下会有问题吗？绝对的。在其他情况下能有用吗？当然(这就是为什么它很常见)。很多人都依赖这种行为，并且喜欢它。那些不这样做的人(当然也有很多这样的人)总是有一个合理的解决方案，即启用* `E_STRICT` *并强制执行* `E_STRICT` *兼容的代码。我仍然认为拥有严格的模式(可以包含严格的类型、严格的操作、更严格的错误行为等等。)很有意义，对于许多喜欢更严格语言的人来说，这可能是一个更好的选择——但是我们根本没有办法改变这种语言最基本的行为之一，并强迫人们接受它——不仅因为它破坏了兼容性，还因为它破坏了许多人用来编写 PHP 代码的习惯。几十年前，Perl 以* `'use strict;'` *的形式为喜欢更严格的人提供了一个解决方案；JS 最近也做了类似的事情。这两者都没有产生任何分歧——这是一个简单、明智的解决方案，几乎没有任何缺点。*
> 
> *-沙瓦尼亚语*

这是 PHP 的一个基本原则:让开发人员选择他们想要的编码方式。让代码的交付不受其他更严格语言的约束。在波波夫回来并试图达成一个解决方案之前，谈话又回到了针锋相对的状态。

> 不。破坏兼容性的事情就是兼容性破坏。不管它们是错误还是时尚，如果代码会崩溃，它就会崩溃。我们不能通过争论工作流和工具来改变这一点。我们的工作是决定是否以及如何实现这些突破。
> 
> *—罗文·柯林斯*

> *这不是破坏所有的东西——这是破坏本应被破坏的代码，但不知何故没有被破坏*。
> 
> *—马修·布朗*

> 我用许多不同的语言写过代码。这些语言中的许多语言(最著名的是标准 ML)迫使我思考数据到底是如何流经我的程序的。另一方面，PHP 不需要这么多的工作。这意味着它的开发人员通常也不会有很大的改进，这最终会损害该语言的声誉，因为以前的 PHP 开发人员发现他们的坏习惯不能很好地移植到其他语言。有了这个改变，我们可以让人们更难写出糟糕的代码，我认为这会让现有的 PHP 用户成为更好的开发者。
> 
> *—马修·布朗*

> 对我来说,“未定义变量”错误的问题是有争议的。因此，我决定在提案中把它分成一个单独的部分，与其他部分分开投票。我将提供抛出错误异常(如最初提议的那样)、抛出警告或保留现有通知的选择。阅读这个讨论令人失望，有些幻灭。我可以理解并欣赏对遗留代码的关注。但是看到使用未定义变量被认为是合法的编程风格，这让我很难过。
> 
> *—Nikita Popov*

> 真的很尴尬，任何人都会有这样的错觉，认为这种语言一直以来的行为方式，从一开始就是一致的和有据可查的，是一个每个人都同意的错误，只是在等待有人来修复它。

> PHP 可以为那些发现它不足的人而改进，而不会伤害那些实际上对它目前的方式感到满意的人。我们应该开始寻找这样的解决方案，而不是每个人都试图“为自己的阵营赢得胜利”，将事情付诸表决，希望征服另一方。
> 
> *-沙瓦尼亚语*

> 很抱歉，但是如果你真的认为引起注意(或者警告，或者错误……)的事情不是 bug，那你就错了。这就是 bug 和通知/警告/错误等的定义。是该语言用来向开发人员报告这些错误的机制。如果做 X 已经产生了 20 年的通知，那么做 X 是错误的，是一个 bug，句号。如果语言本身不认为你所做的是错误的，为什么会有通知呢？那么通知的目的是什么呢？我真的不明白怎么会有人质疑这个。
> 
> *—通过内部构件的埃吉尔立特*

嘘！

> 对我和我所认识的每一个开发人员来说，通知和警告之间的唯一区别是错误的严重性。但是它们都被认为是错误——您在代码中犯下的需要修复的错误。我很确定这是现实世界中大多数开发者对待他们的方式。

> 不管怎样，如果你想要一种不太严格的语言，那种语言已经存在了:它是 PHP 的当前版本，你和其他喜欢它工作方式的人可以继续使用它。

> 与此同时，我认为大多数目前从事严肃 PHP 工作的人会喜欢更严格一些，我不认为让你的旧代码在全新版本的语言上运行是一个足够好的理由让这个特性不在 8.0 中出现。如果每一个潜在的 BC 中断都被邮件列表上的这三个人否决了，那么即使有主要版本又有什么意义呢？
> 
> *—埃吉尔·李特*

> *我反对这两项重新分类:*
> 
> *未定义偏移:* `%d` *—通知→警告*
> 
> *未定义指标:* `%d` *—通知→警告*

> 根据经验，必须尽职尽责地初始化数组中的每一个键是很麻烦的。我理解在一些编码标准中强制执行的基本原理；但是那些特定的缺失索引是否应该被认为是意外的(因此值得警告)主要是编码风格的问题。

> 原则上，这是一个与使用未初始化变量类似的问题，正如在这个帖子中提到的，这是一些语言中完全接受的编码模式(这个问题不同于未声明的变量)。我说“原则上”，因为完全合理的编码风格可能会选择强制变量初始化，但不会强制数组键初始化。
> 
> *——克劳德·帕奇*

最讽刺评论奖颁给了这颗宝石:

> 我见过很多人担心 PHP 会抛出实际错误(而不是通知)，因为他们试图使用一个不存在的变量/偏移量，当然也经常有人提议使用 declare 语句或类似的东西，以允许他们的“代码风格”运行时不出错。

> 因此，我对这种情况的建议是引入一个单一声明，一劳永逸地解决这个问题。
> 
> ```php
> declare(sloppy=1);
> 
> ```
> 
> *这将抑制任何关于未定义变量、数组偏移量的错误，当遇到未定义常量时，将逆转“裸字”的变化，等等。见鬼，这种模式甚至可以重新实现* `register_globals` *和* `magic_quotes` *，为什么不呢？*

> *如果你想写潦草的代码，那完全是你的特权，但是请你承认它是什么，不要假装它是某种艰巨的任务，要么首先定义变量/偏移量；或者检查它们是否被定义；或者使用适当的方法访问它们，特别考虑到未定义的变量/偏移量(即* `??` *和*`??=`*)。*
> 
>  **—斯蒂芬·雷伊**

 *波波夫最终提出了一个解决方案，将两个主要的反对意见分开，并除以零，形成他们自己的投票。

> *我已经把未定义数组键的问题拆分成一个单独的部分，将单独投票。我大体上同意忽略未定义的数组键通知是一种合理的编码风格选择(虽然我非常不同意未定义的变量也是如此)，尽管最终我认为最好用自定义错误处理程序(它可以检查错误是否源于您自己的代码库)来处理这个问题，而不是通过全面禁止通知。本着这种想法，我认为这是一个通知还是出于压制目的的警告并没有太大的关系。但是我也没有强烈地感觉到这个案例是一个警告，特别是 PHP 8* 中的 `error_reporting=E_ALL` *默认。*
> 
> *—Nikita Popov*

结果如下:

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 将未定义的变量严重性更改为？ |
| 错误异常:36 | 警告:18 | 请注意:10 |
| 将未定义的数组索引严重性更改为？ |
| 警告:42 | 请注意:21 |   |
| 将除以零严重性更改为？ |
| division byzero error exception:52 | 保持警告:8 |   |

对于所有的喧嚣，RFC 的通过给开发者留下了阴影。*