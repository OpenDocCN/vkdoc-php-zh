# 19.结论和其他想法

我们在这本书里已经涵盖了相当多的信息。我试图给你一个关于如何以领域驱动的设计方式开发软件的实用知识，这是用 Laravel 实现的。我向您介绍了许多场景，并讨论了一些可能的解决方案，以及可能的故障点。我在书中展示的所有例子都直接取自我开发网络软件的经历。在这一章中，我将回顾一些我们还没有涉及到的或者我们只是简单地提到过的概念。

在这些感兴趣的领域中，您会发现以下内容:

*   *架构*:以领域驱动的方式构建系统核心骨干的一些备选策略。我们将使用我从头构建的示例应用程序作为支持结构来展示一个伪假设场景，该场景与跟踪和管理所有订单、销售、跟踪和事务处理的核心实现部分相关，这些都是常见仓库管理系统的典型流程。

*   *拥抱 Laravel* :使用定制的`Collections`和`QueryBuilder`对象在域级别利用 Laravel(而不是使用雄辩的作用域将它们“内联”到模型中，这将作用域直接耦合到模型中，并且不可重用)。您可以使用快捷方式在模型中无缝地使用这些东西，但是我们必须确保在使用这种快捷方式时，不要破坏模型本身的完整性，也不要创建模糊基础领域的新模型。

然后，我将分享关于实现域驱动的 Laravel 应用程序的其他想法。这将引导我们进行一些总结性的思考，总结我们已经能够用 Laravel 和领域驱动设计做什么，以及我们为最初解决领域问题所做的选择和实现如何影响应用程序的未来构造和重构。

## 架构考虑

有许多方法可以架构一个系统，但是只有几种方法可以正确地确保域模型正确地反映底层核心域以及其中包含的内容。说起来容易做起来难。

在这一节中，我们将勾画出一个可能的架构，当它被实现时，将满足系统的需求。我们将根据领域驱动的设计概念来确定这个架构的某些方面。我们将定义系统空间，以适当地确定领域的不同方面，我们可以用它来开始拼凑系统的整体架构。我们将关注体系结构和系统组件之间的关系，而不是实际编写底层代码来实现我们设计的设计。具体来说，我们将通过一个示例应用程序来管理典型仓库的所有方面，包括接受订单、履行订单和装运订单；接收库存商品；以及在典型业务流程的每一步跟踪产品的位置(更多细节即将推出—敬请关注)！

## 仓库管理系统

在第 [3](03.html) 章中，我们使用了一个类似于仓库管理系统的东西，只是在一个特定的环境中(一个在线鞋类零售商的仓库)。这个例子将是更高层次的，将涵盖更广泛的领域。它基于我在过去几年中完成的一个项目。这非常相关，从这个例子中可以学到很多东西。

让我们想象一下，你被聘为一个自由项目的首席开发人员，负责构建一个包罗万象的仓库管理系统。这意味着它可以处理仓库所做、销售和跟踪的许多方面(如果不是大部分的话)。

从构成我们系统中每个单独仓库的核心的数据的角度来看，功能必须以这样一种方式存储，即允许跨系统中的所有对象轻松访问它——以便数据可以以一种清晰和可管理的方式跨组件共享。从应用程序的角度来看，您需要一种方法来将这些功能分解成更小的部分，以便它们可以独立地工作，但它们又以一种内聚的方式结合在一起，无缝地提供应用程序中丰富的功能集。

您与项目经理会面，检查所有不同的功能组，以正确地定义什么将作为应用程序的域模型的一部分。在这次会议中，您提出了一个在较高层次上描述的应用程序要包含的所需功能的列表，看起来像下面的过程:

*   第三方订单管理系统接受订单，这应该在我们这边转化为销售订单

*   完成新订单，从货架上挑选商品到装箱

*   将订单装运给销售订单上列出的买方(从仓库发出)

*   接收来自供应商的进货，包括跟踪库存水平和产品位置管理

为了使项目的需求更加清晰，你提出了如图 [19-1](#Fig1) 所示的高层图表。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig1_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig1_HTML.jpg)

图 19-1

完成仓库管理应用程序所需的功能集的草图

图中实线代表硬性关系，虚线代表隐含关系。这些是在构建模型设计时需要考虑的高级功能类别。通过进一步的讨论，您能够确定该系统中需要的几个核心上下文，以及描述这些上下文的分解的一些子项。

*   指令结束
    *   销售订单

    *   库存调整(暂时“锁定”某种产品的数量)

    *   挑选，打包

*   接收商品(采购商品)
    *   采购订单

    *   库存调整

*   储存商品
    *   产品管理

    *   仓库位置跟踪

    *   储存

*   运输商品
    *   包装

    *   库存调整(“锁”被释放，数量减少)

对于该系统的要求，这一点更加具体。三个黑色圆点描述了仓库的主要关注点。订单执行包括在每次销售中创建销售订单的概念(这可以由支付网关的成功交易来确定)。然后完成订单，这包括从货架上挑选商品，包装箱子，并将其运出。还需要有一种方法来跟踪进来的商品，它通过采购订单做到这一点，并且随着我们的进行，必须在主库存清单中进行充分的跟踪和计数。最后要考虑的是如何以提高效率的方式在仓库中正确存储商品，这一过程被称为*入库*。每个产品都必须被跟踪，在库存中被计算，然后根据一些标准系统放置在存储架上，以便在仓库系统中跟踪它们的移动。

从这个列表中，您可以确定需要存在于系统中的核心上下文，以便在新的领域模型中捕获业务模型。因为您精通领域驱动的设计，所以您知道领域模型的组织结构本身应该尽可能地按照它所代表的真实业务流程来建模。考虑到这一点，您确定该系统的四个核心环境如下:

*   订单(接收)

*   接收(传入)

*   存储(内部)

*   运输(发货/可交付)

Note

可以认为存储上下文在技术上是接收的一部分。我将它作为自己的一部分添加到这里，因为以可管理和直观的方式存储这些项目具有挑战性，并且为了运行可能会包含很大一部分逻辑。

系统的某些关键方面支持前面列出的核心领域。这些方面可以被认为是通用子域，因为它们适用于一个以上的上下文(即，跨组件共享)，并且或多或少是先前核心域的支持结构。以下是我们需要在该系统中考虑的一些通用子域的示例:

*   库存管理(由订单、接收和装运上下文使用)

*   产品管理(由所有其他有界上下文使用)

*   位置跟踪(用于存储和接收，以及提货和包装)

*   我们将通过其接收销售订单的外部订单系统

知道了概念的图形化表示如何使它们更容易理解，你很快就能设计出一个图表来显示有界上下文，以及一般子域，以及它们如何适用于每个上下文，如图 [19-2](#Fig2) 所示。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig2_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig2_HTML.jpg)

图 19-2

核心上下文和子域之间关系的分解

我们可以推断出，订单上下文需要了解产品管理和库存管理子域。接收上下文将具有与订单上下文相似的知识(也称为依赖性)。存储上下文依赖于产品管理和位置跟踪子域，而运输上下文依赖于所有三个子域。作为一名出色的首席开发人员，您有一种强烈的愿望，要封装术语及其定义，这些术语及其定义将在以后用作各种组件本身的标识符，通常被称为系统的*通用语言*。这可以用来帮助阐明有界的上下文以及它们之间的各种交互，并且可以被认为是一种上下文图的“草图”。

## 保持领域的焦点

我们已经规划了实现管理仓库的应用程序所需的各个部分，这是一个良好的开端。我们必须继续注意我们与领域中的对象的关联，以确保它们直接来自领域本身，而不是来自对它的假设。确保这种领域相关性的一个明确而可靠的方法是尽可能按字面意义命名相应的组件，并保持每个模型的定义尽可能按字面意义，因为它们是在核心领域中定义的。允许领域驱动架构，而不是假设和拥有不准确的信息。

了解了所有这些之后，你决定实现表 [19-1](#Tab1) 中列出的命名约定，以解决我们之前已经确定的明显问题。

表 19-1

组成示例仓库应用程序的命名组件

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

组件名称和上下文

 | 

组件问题

 | 

属国

 |
| --- | --- | --- |
| 命令 | 与订单相关的问题，包括库存检查、账单/地址信息、订单行、交易和创建销售订单(针对离开仓库的产品)。 | 产品管理、库存管理 |
| 接受 | 与跟踪进入仓库的产品*相关的所有逻辑，包括仓库内位置放置、库存调整以及与产品管理组件的交互。* | 产品管理、库存管理、位置跟踪 |
| 保管 | 创建和维护某种仓库跟踪系统所需的所有逻辑，以允许快速补货和快速履行订单。 | 产品管理、位置跟踪 |
| 船舶 | 订单执行最后阶段涉及的逻辑。包括根据订单细节从货架上挑选产品，将产品包装到盒子中，并打印出运输标签。库存变化也必须考虑在内。 | 产品管理、库存管理、位置跟踪 |

请注意我们是如何命名这些组件的(使用无处不在的语言中标识的术语，理想情况下，我们已经与项目保持同步)。这里的术语与领域中的术语相同，字面上的意思与它们在仓库管理上下文中的意思相同。这种方法就是有意的字面设计。

Tip

为了培养一种有意义的无处不在的语言，你需要与最了解领域的人——领域专家——进行多次讨论。随着项目的进展，随着在领域或领域模型中获得新的洞察力，您可以(并且应该)重构您的术语定义。

至此，可以说，我们已经有了作为应用程序主干的核心概念。它们是应用程序提供的功能的主要部分，因此需要额外的支持机制才能发挥作用。这些以跨组件使用的各种专门支持子域的形式出现(因此必须以一种允许轻松集成或将工作委托给系统中其他组件的方式来开发)。因为这些实际上不是常规的子域，而是被认为是一般的子域，所以我们应该始终努力在系统的核心组件和对它们进行操作的设施之间实现松散耦合，同时，促进诸如维护库存水平、更新订单状态或挑选和包装订单以准备发货等操作所需的内聚机制。

我们的系统能够足够灵活地处理组件之间的各种交互(特定领域组件之间的内部对象交互)是至关重要的。我们将很快制定出一个可能的目录结构的粗略草案，但是值得注意的是，将域驱动的架构迁移到更分布式的架构(如微服务)是多么简单，而不是从单一应用程序开始，然后迁移到微服务甚至六边形架构。这不是不可能的，但是转换本身可能会变得相当复杂，因为概念必须重新思考，界限必须重新划定，关注点需要组合或分离，以便它最有意义。

## 命名空间和目录

我们需要做的最后一个分解来分离应用程序的关注点可能是所有分解中最重要的一个:在模块级别上的领域分解，它直接对应于(尽可能字面上)底层业务领域中存在的概念、关系和结构。现在我们已经正确定义了有界上下文，我们可以决定将域分成哪些模块(包括它的目录和名称空间结构)。一般来说，但不总是这样，最好的做法是将每个子域与一个域模块对齐，并且该模块应该直接从项目的通用语言中命名。

从我们目前的角度来看(还没有考虑基础设施)，我们将创建`App\`和`Domain\`名称空间，它们将作为系统的最高级别父类。`App\`是我们放置促进和指导领域层所需的逻辑的地方。然而，现在让我们关注领域层本身。

我们首先根据之前确定的有界上下文创建子名称空间(记住，我们还必须修改我们的`composer.json`文件来添加新的`Domain`根名称空间)。

在表 [19-2](#Tab2) 中列出的结构中，我们可以将每个父名称空间的内容视为一个容器，其中包含了特定于其相应有界上下文的所有内容(即，创建新销售订单所涉及的逻辑将发生在`Order`模块中，而将产品放在货架上以便稍后可以快速找到的动作存在于`Storage`模块中)。

表 19-2

初始名称空间/目录结构

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

命名空间

 | 

目录

 | 

组件

 |
| --- | --- | --- |
| `Domain\Receiving`(或`Receivements`) | `/src/Warehouse/Domain/Receiving`(或`Receivements`) | `Receiving`(来话) |
| `Domain\Ordering`(或`Orders`) | `/src/Warehouse/Domain/Ordering` ( `Orders`) | `Orders`(来话) |
| `Domain\Storing`(或`Storage`) | `/src/Warehouse/Domain/Storage`(或`Storage`) | `Storage`(内部) |
| `Domain\Shipping`(或`Shipments`) | `/src/Warehouse/Domain/Shipping/`(或`Shipments`) | `Shipping`(传出) |

那么，对于我们的系统运行所依赖的通用子域，我们应该把它们放在哪里呢？嗯，它们仍然是域的一部分，所以我们可以将它们保留在`Domain\ root`名称空间中，或者由组件类型分隔，或者在一个附加层中(带有类似于`Domain\Support\`的前缀)。

到目前为止，应用程序的一种可能的名称空间结构如下:

```php
Warehouse
└── Domain
    ├── Ordering
    ├── Receiving
    ├── Shipping
    ├── Storing
    └── Support
        ├── InventoryManager
        ├── LocationManager
        └── ProductManager

```

在这个结构中，我们有一个清晰的父名称空间集合，它对应于底层业务的结构。在任何给定的时间，都有一种简单的方法来验证您在规划领域层的轮廓时是否处于正确的道路上。如果您的域模型的原始设计与底层业务结构在接近文字的层次上相关，并且您选择的名称直接来自系统中无处不在的语言，那么您就在正确的轨道上。

因为 Laravel 以某种方式运行(通过将应用程序的不同部分组织成各种组件，这些组件允许域层与 Laravel 的默认机制提供的其余功能集成)，所以我们将坚持使用应用程序和框架中使用的默认组件。这包括作业(可以分派队列并异步运行)、策略(通过管理谁可以查看、修改或创建模型实例来保护模型的安全性)、雄辩模型(封装模型的特定行为和属性)以及 Laravel 附带的各种其他组件。然而，我们将只使用任何特定的组件，如果我们首先确定它是必要的。我建议您不要为应用程序的域层创建任何类型的默认目录/名称空间结构，原因有很多(主要的一个原因是遵守 YAGNI——您可能不需要它)。向项目中添加并非 100%必要的类和接口会适得其反，因为这会向应用程序添加需要维护和保持最新的代码行。项目目录中额外的文件和文件夹只会增加应用程序的整体复杂性，所以尽量避免将任何不需要的东西放在项目目录中。

### 查看图层

在我们深入探讨我们的选择之前，让我们花几分钟回顾一下架构的不同层，以及每一层应该属于哪种类型的逻辑。图 [19-3](#Fig3) 显示了这些层在我们基于 DDD 的应用中的分解。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig3_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig3_HTML.jpg)

图 19-3

应用程序的每一层及其各自的关注点

图 [19-3](#Fig3) 根据组成应用程序的层以及每层的主要关注点(焦点)对应用程序进行了分解。这里没有什么新的东西，但是请注意，concertive 与应用程序的每个中心层一起运行，可以被认为是它自己的独立层(而以前您可能认为 concertive 中的功能位于基础结构层中)。

### 绘制架构图

现在，我们将开始规划我们之前确定的每个模块需要的东西。例如，我们可以假设(但实际上不会为其创建代码，除非后来认为有必要)大多数模块至少需要以下内容:

*   `Models/`:领域模型(业务对象)
    1.  实体

    2.  价值对象

*   `Repositories/`:访问这些型号的`/ Management`

*   `Factories/`:抽象更复杂的领域对象的构建的逻辑位置

*   `Aggregates/`:作为应用程序中独立单元的实体和值对象的组合位置

*   `Services/`:作为业务逻辑的一部分出现并且不能包含在实体或值对象中的功能和过程

图 [19-4](#Fig4) 用图形表示了这一点。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig4_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig4_HTML.jpg)

图 19-4

应用程序及其层的可视化表示，以及我们可能在每个层中找到的一些通用组件

图 [19-4](#Fig4) 显示了应用程序的高层次视图，其中涉及的各个层被分成各自的泳道。图中不带阴影的项目表示接口或抽象，带阴影的项目表示此类接口的实现。我将中间件作为一个特殊的项目，因为它本身不是一个类，而是一个更底层的概念。从顶部开始，接口层将支持进入我们系统的各种类型的请求，无论是 API 请求还是来自浏览器的请求。我们将很快更深入地讨论接口层和应用层。

在很大程度上，映射关注于系统的领域层方面，因此，它指出了在领域层中的单个模块的上下文中可能会找到哪些类型的对象。通常情况下，我们需要模型作为我们的实体和集合的基础(以便利用雄辩提供的特性)，价值对象和集合形成业务领域中存在的基本对象，以及用于对不符合实体或价值对象的正常形状的流程或过程建模的服务。

因为我们正在使用 Laravel 构建我们的应用程序，所以将这样的服务建模为 Laravel 作业或实现`Queueable`和`Dispatchable`契约的其他类型的域级结构是有意义的，这样它们就可以被推到异步队列中，这通常可以在整个应用程序中提供高级别的响应。在 Laravel 中最简单的方法是创建一个实现`ShouldQueue, InteractsWithQueue`和/或`SerializesModels`特征的`Job`类(或`Command`类),然后确保您的配置设置正确，以支持众多受支持队列中的一个，然后*噗*一声，您就可以开始了。

Tip

当构建作业来封装系统中的业务逻辑时，请记住，一旦它们被推送到异步堆栈上，它们将不会返回任何值。这意味着，在通过 worker 队列运行的作业或命令的上下文中，对实体所做的任何更改只有在从数据库刷新模型属性时才能检测到。这也意味着作业运行所需的任何数据或依赖项都必须在其构造函数中传递，以便在特定于作业的逻辑运行之前获得这些数据或依赖项。

同样在图 [19-4](#Fig4) 中，请注意`Repository`组件被放置在域和基础设施层之间，由实现而不是接口来表示(如阴影区域所示)。这样做的原因是，在一个典型的项目中，您将在应用程序的领域层中定义给定存储库的接口，可以将其命名为类似于`Warehouse\Domain\Orders\Contracts\OrderRepositoryInterface`的名称。

这将由基础设施层中的一个类来实现，可能叫做`Warehouse\Infrastructure\Orders\Repositories\InMemoryOrderRepository`。

可以说，在领域层中定义的存储库接口的实现实际上应该位于应用层而不是基础设施层中，因为存储库本身与模型有着密切的联系，所以它可以被视为一个应用服务(位于应用层中)，同时也可能属于领域层之外。这也是为什么抽象的`Repository`接口是在领域层中定义的。(这取决于你，可能不值得花很多时间讨论。)

在图的底部，我在图 [19-4](#Fig4) 中包含的位于基础设施层的四个文件夹是为了表示保存应用程序运行所需的重要数据的各个位置。之所以将它们列在基础设施层的上下文中，是因为我们选择了 Laravel 作为构建系统其余部分的底层框架。大多数情况下，这些文件夹存储应用程序和框架的各个部分使用的某种类型的缓存数据。

请记住，图 [19-4](#Fig4) 是给你一个可能的架构，你可以用它来构建你的应用程序。遵循软件的原则和最佳实践是可以的(也是推荐的),软件可以作为一种架构组合在一起。然而，我们想要的是更深思熟虑的东西。让我们看看我们的仓库应用程序如何适应这个体系结构，以及需要对体系结构进行哪些修改，以允许域作为系统中的底层成分充分发展，这只能通过让域“驱动”来实现。我们将只关注系统中的一个特定模块，即`Order`模块。图 [19-5](#Fig5) 展示了一个例子。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig5_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig5_HTML.jpg)

图 19-5

使用我们之前设计的松散耦合设计的应用模块示例。请注意，所有依赖项都指向域层内部，并且在每个边界交叉处都有接口

Caution

图表很棒，UML 可以用一种易读的格式传递大量信息。然而，不要犯试图绘制系统中所有事物的图表的错误。你将会被保持所有图表最新所需的维护费用所淹没。如果它们不是最新的，那么它们对我们就没用了。将图表作为工具箱中的一项，你可以用它来灌输更高级或更复杂的问题和过程。抵制把所有东西都画出来的冲动。

在图 [19-5](#Fig5) 中，我们有一个关于`Orders`领域模块的仓库管理应用架构的概要。从(INT = interface)的顶部开始，我们已经完全折叠了接口层，并且有了一些应用程序级别的服务，以便于处理域层和应用层之间存在的应用程序问题。

如果没记错的话，应用层是直接处理域层中的元素的。例如，应用服务通常是域模型对象的直接客户。在图 [19-5](#Fig5) 中，我们可以将任何利用域对象来完成某些任务的控制器和命令视为应用层的一部分。如果您注意到了，我们仍然遵守依赖规则，并且所有表示依赖的箭头都指向领域层，而不是远离领域层。

这些命令(或控制器)方法很可能会分派任何作业和服务，或者将需要运行的任何其他逻辑委托给其他组件。通过这些构造，外部世界可以与我们的应用程序内部进行通信。我们希望在应用程序中实现关注点的强分离(根据`Warehouse`域),同时保持这些不同部分的一致(和松散)耦合。实现这一点的更好的方法是将充分描述业务级概念的接口放在一个不同层中的另一个类可以实现的方式中？在这样做的过程中，我们实现了高度的分离，因为我们将业务逻辑本身作为一个抽象，在域模型中表示业务中的一个概念。

在图 [19-5](#Fig5) 中，你会看到这种模式的几个例子。例如，域层中的`OrderRepository`框是一个接口，其中有一组声明的方法，任何实现类都必须为这些方法提供定义。这些方法将与`Order`模型相关，可能包括如下功能:

*   `getLineItems(int $orderId): array`

*   `getOrdersByCustomer(int $customerId): Customer`

*   `getAverageOrderTotalBetween(string $date1, string $date2)`

*   `: int`

因为这些接口概括了领域中的正式流程，所以我们可以将这样的接口放在领域层中，并在不同的层中实现接口。在`OrderRepository`的例子中，我们在我们的领域层中为它定义了契约，而实现存在于基础设施层中(如前所示，`EloquentOrderRepository`)。通过遵循将业务和领域概念或过程开发为一组可由任意数量的客户端实现的一致接口的实践，每个客户端都将拥有自己的定制逻辑或关注点，我们的设计支持开箱即用，因为我们可以保证该给定接口的所有客户端(例如`OrderRepository`接口的`EloquentOrderRepository`实现)都将拥有在其中定义的指定方法。这是基本的面向对象编程。

图 [19-5](#Fig5) 中最后要注意的是集合的位置和它所连接的相应元素。众所周知，在领域驱动的设计中，聚合代表了一种它们自己和边界内的类之间的边界线。这增加了模型的复杂性，但通常比试图在没有聚集根的情况下建模要简单得多。由于复杂性的增加，聚合通常没有任何内置逻辑来保存或从数据存储中检索这些对象。相反，一个集合的“构建”方面通常被放置在一个专用的工厂类中，如图 [19-5](#Fig5) 所示。

Tip

图 [19-5](#Fig5) 中的`Factory`接口位于领域层，其实现位于应用层。我这样做的原因是因为应用程序层中的类和对象是域对象本身的直接客户，而一个工厂存在的唯一目的就是把一个单一的集合对象放在一起，这当然属于这一类。在现实世界中，您可能会发现存在于基础结构层而不是应用层的实现。这是偏好使然，没太大关系，只要你始终如一，坚持自己的决定。

典型的工厂类应该通过尊重集合的边界来重组集合。工厂实例化聚合的所有必需部分(位于聚合根的边界线内的对象)，并且，由于没有更好的词，将其打包成所请求的聚合对象并返回它。通过这种方式，我们基本上已经将数据库中的数据转换成了一个成熟的 PHP 对象，我们可以在应用程序中使用它，这样我们就可以以面向对象的方式与它们进行交互。然后，我们剩下的关注点是从数据库中保存和检索聚合数据，这最好留给存储库(我们在本书的整个过程中已经非常深入地讨论过了)。

### 进入应用层

从 DDD 的角度来看，为系统中存在的每个域层模块包含一个应用层模块是很常见的。对于前面的例子，我们可以在`Application`名称空间下创建一个名称空间，其名称与其对应的域层名称相同:`Orders`。

在图 [19-6](#Fig6) 中，我们设计了一个我们的系统将基于的架构，考虑到我们利用 Laravel 框架作为系统的主干，同时仍然保持系统最重要的规则不变(也就是说，允许领域本身驱动应用程序的开发)。该图略有不同，因为它以比用 DDD 创建的传统架构更直接的方式包含了框架。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig6_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig6_HTML.jpg)

图 19-6

我们的仓库项目的应用层的焦点透视。基础设施层未示出

就像我们有一个名为`Orders`的专用域模块一样，我们也应该在应用层提供一个匹配的模块。正如您所看到的，Laravel 包含的或多或少的“标准”组件显示为在实际的`Order`模块的外部(也在基础设施层内，这里没有显示)。更有可能的是，我们将需要一个控制器来处理传入的请求，从而在系统中创建、选择、更新或删除订单。还包括雄辩的知识库(它可以更好地位于基础设施层，在图 [19-6](#Fig6) 中没有显示)，其实现最终位于领域层，以及任何第三方系统，我们可以利用它来支持应用程序的各个方面。

例如，团队可能决定不希望从内部管理应用程序的身份验证，而是希望将登录和创建新用户的过程委托给其他人。假设我们认为 SaaS 是最好的选择。在网上做了一些研究后，我们发现了一个叫做 Auth0 的东西，这是一个完全集成的系统，以一种清晰的方式处理用户的所有方面(或只是登录部分)，支持最先进的静态加密技术，因此我们可以放心(没有双关语)用户的数据在任何时候都尽可能安全。为了将这个服务构建到我们的系统中，我们需要修改默认的`LoginController`来利用一个定制的存储库类(可能是一个`Auth0Repository`？)封装了与 Auth0 后端集成所需的逻辑(通过 API)。一个额外的要求是，您必须在`LoginController`上包含一个方法，该方法将充当“监听器”类型的回调，以便 Auth0 在认证完成后(无论是通过还是失败)进行调用。在这种情况下，`Auth0Repository`最好位于应用层，因为它是一个应用程序问题。然而，如果我们正在处理一个存储库，它管理一个聚集对象的保存/检索，那么实现它的合适位置应该是在基础设施层，我们将在下面强调这一点。

### 基础设施层

最后但同样重要的是，我们有基础设施层，它包含了大部分的 Laravel 默认对象、配置和其他类似的对象，我们称之为基础设施层。正如我们对应用程序和域层所做的那样，我们将在基础架构层内创建一个名为`Orders`的新名称空间，它将容纳任何不符合应用程序或域层要求的订单相关代码。参见图 [19-7](#Fig7) 中的示例。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig7_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig7_HTML.jpg)

图 19-7

仓库应用程序突出显示的基础结构层

基础设施层非常简单，但是它会随着我们添加功能而增长。如前所述，它还可能包括存储库，这些存储库封装了特定模型的存储/检索知识，或者在我们的领域层中的集合。像往常一样，我们将为对象创建一个接口。假设我们(出于某种原因)需要一个只处理内存(RAM)中的数据和对象的存储库。我们可以使用一个`InMemoryOrderRepository`，它将实现位于域层的`OrderRepository`接口。实现本身将存在于接口层中，如图 [19-7](#Fig7) 所示。你能注意到图 [19-7](#Fig7) 有什么奇怪的地方吗？如果没有，图 [19-8](#Fig8) 给出了提示。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig8_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig8_HTML.jpg)

图 19-8

图 [19-8](#Fig8) 中描述的架构的问题区域

域层中有一些元素对基础结构中的另一个元素有指向外的依赖关系，如果我们记得域逻辑位于何处(朝向中间)以及依赖关系应该以哪种方式指向(向内)域层，这应该会让您觉得有问题。让我们通过查看图 [19-9](#Fig9) 来重温这个概念。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig9_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig9_HTML.jpg)

图 19-9

分层体系结构中不同层的复习

因为我们已经选择了 Web 作为编程表达的媒介和画布，在其上以漂亮的代码形式巧妙地描绘艺术，这些代码代表了背后的科学，所以必须考虑实现标准的领域驱动设计。在这种情况下，DDD 的某些方面，如依赖于自身以外的任何东西的域层，通常在 DDD 的上下文中是严格禁止的，但在世界上最强大和最受欢迎的框架之一中似乎在一定程度上是可以接受的。

如果我们观察 Laravel 的构造方式，我们可以看到，例如，`Model`类扩展了基础`Model`类，从技术上讲，基础`Model`类位于基础设施层(位于`/vendor`目录中)或者可以在它自己的层内(见图 [19-4](#Fig4) )，但是无论哪种方式，领域层在技术上仍然依赖于它自身之外的东西。我们如何着手提供满足依赖规则的解决方案？

如果你是从“颠倒依赖关系”的角度来思考问题的，那么你是对的！我们可以做的是在基础设施层中创建一个抽象类来实现一个接口，从而将依赖关系的方向颠倒过来，指向中间的域层。参见图 [19-10](#Fig10) 中的示例。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig10_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig10_HTML.jpg)

图 19-10

反转模型类的依赖关系

## 拥抱拉勒维尔

对于本章的最后一节，我们将使用以前的示例(如医疗索赔应用程序)作为参考点，来讨论这些总结主题。

### 将对象作为一个整体来验证

另一方面，如果您需要额外的定制逻辑作为验证过程的一部分运行(这正是我们在 Claim Validator 中所需要的)，那么验证对象(或集合)组合的上下文可以通过实现一个定制的`Validation`服务来解决，该服务将利用我们刚刚创建的可重用的`Validator`组件。然后，为了让应用程序中的其他组件能够轻松访问它，您可以使用 Laravel 的服务容器将别名绑定到您的服务。

### 为对象组合验证创建验证器服务

要创建一个服务，您需要考虑几件事情，建模和架构师。

1.  服务真的需要吗？某种价值对象或实体就足够了吗？

    →如果您正在构建的东西不适合某个实体或对象的上下文，服务可能是一个不错的选择。

2.  这项服务到底要完成什么？

    →当您清楚地确定服务的目标以及它应该为整个应用程序完成什么时，它有助于缩小范围。

3.  服务完成工作需要哪些组件、类、服务、对象、实体和数据？

    →定义服务范围之外的代码的任何关系、依赖性或其他关联是有益的。

4.  这项服务在哪里最好？在什么上下文或模块中？

    →除了确定文件的物理放置位置，它还通过定义服务将位于哪个层来帮助为服务提供上下文。

5.  如何测试服务？

    →始终致力于创建单元测试和(尽可能)完整的自动化测试套件。

对于我们关于声明验证的特定上下文，我们将假设由于其复杂性而需要该服务，尽管实际上这可能是多余的(步骤 1)。该服务将处理 CPT 代码组合的验证，验证该组合是否可供提供者在其 paycode 表上使用，建立与索赔一起提交的正确文档，并验证患者是否有资格接受护理(步骤 2)。我们将需要访问索赔本身，以及涉及索赔的任何内容(属性和关系)，以及 CPT 代码模型、工资代码表(我们仍需定义)和患者资格服务，我们不会构建这些服务，只是验证它是否已为索赔中的患者运行(步骤 3)。一般来说，验证是一个基础设施问题，因为它不一定与领域本身有任何关系，而是与确保给定的模型(在我们的例子中，是`Claim`模型)处于有效状态有关(步骤 4)。这显然是一个很好的关注点分离，所以它属于基础设施层。就测试而言，一个简单的单元测试覆盖服务中涉及的大部分代码就足够了(步骤 5)。

现在我们对实际构建的内容有了更多的了解，我们可以开始创建一个名为`ClaimsValidationService.php`的新文件，该文件位于与其有界上下文和模块相对应的名称空间内。该服务将处理任何复杂的验证逻辑，以验证声明的其余部分。此时，大部分验证需要在我们已经通过实现我们在`ClaimSubmissionRequest`类中指定的规则处理过的索赔提交上运行。我们还没有涉及的一个问题是验证给定的 CPT 代码组合是否存在，并且是否在提供商的 paycode 表中列出。

在我们的服务中，我们可以使用本章中定义的`Validation`类来构建验证器。我们甚至可以使用我们之前构建的验证器来处理 CPT 代码组合和 paycode 表的另一个验证；然而，我选择使用服务来建模，这样您就可以看到当存在复杂的结构和/或跨越各种检查的多个前置条件/后置条件时如何进行验证，以确保一致性。像这样复杂的验证应该属于专门的服务。为了避免创建低级组件来正确连接这样的服务(即，具有正确的依赖关系并位于正确的上下文/模块中)的麻烦，我们可以转而依赖 Laravel 的`Validation`组件，甚至对其进行扩展以更好地满足我们的需求。因此，我们将利用 Laravel 的`Validation`组件。

### 论作为不一致实践的 Web 开发…

至少可以说，我承认 web 开发是不稳定的。真的没有很多共享资源，尤其是在过去。承认，随着软件工程的原则和实践慢慢进入 web 开发社区，在过去的几十年里事情已经变得更好了。虽然这是真的，但现实是 HTTP 还是一样的。web 编程语言(如 PHP)所基于的底层技术是一种不稳定的底层架构，它源于世界上最古老的协议之一:客户机-服务器模型。增加了会话来缓解这个问题，HTTP 2.0 提供了对原始实现的急需的重构；然而，在我看来，会话只是解决页面跳转之间共享状态的(更大的)问题的权宜之计，HTTP 2.0 并没有非常广泛，也没有像大家想象的那样流行。在全球范围内采用 HTTP 2.0 规范是肯定会发生的，但就目前情况来看，这是一条缓慢的道路。

### 最重要的是，坚持标准和最佳实践

随着时间的推移，随着应用程序复杂性的增加，无论使用哪种框架，维护大规模的代码库都变得越来越困难。分离关注点变得更具挑战性，因为要在代码中的逻辑段之间画出分界线。永远记住让领域成为应用程序开发的驱动力，并努力按照为该上下文设置的无处不在的语言来命名事物。尽可能准确地表达领域。

在本书的前面，我提出了这样一个论点，即除非您计划拥有多个数据库平台，并且您必须在任何给定的时间保持对所有这些平台的访问，否则并不真正需要存储库。不属于这种情况的一个实例是指定由标准描述的特定模型的合格对象集，该标准针对该模型的数据库数据采用条件和约束。在这里，存储库作为一种抽象描述标准本身的方式是有用的。

说所有这些是一回事，但让我们围绕根据标准描述数据集的想法来考虑一些背景。因为我们都知道接口是封装变更及其各种实现的具体细节的方式，所以我们决定最好首先使用一组接口来描述标准的整个概念(这对于在代码中记录想法非常有用，使新来者更容易快速理解契约是什么以及它的用途)。让我们为“标准”的概念建立一个基本的接口，我们可以用它来过滤和约束我们的数据。我们将使用我们的好朋友索赔处理应用程序作为清单 [19-1](#PC2) 中的底层平台。

```php
<?php

namespace Claim\Submission\Domain\Contracts;

interface CriteriaHandler
{
     /** Skip any applied criteria during processing */
      public function skipCriteria(bool $status=true): Criteria;

     /** Return the currently configured criteria */
      public function getCriteria() : array;

     /** Immediately run the passed in criteria and return results */
     public function getByCriteria(Criteria $criteria): array;

     /** Add some criteria to the set of criteria to be applied */
      public function pushCriteria() : array;

     /** Apply any pushed criteria */
      public function applyCriteria();
}

Listing 19-1Example Interface to Manage Criteria

```

在第一个清单中，我们有一些实现`Criteria`接口所需的方法，包括跳过当前迭代的任何推送标准的功能，将一个或多个标准对象添加到堆栈中，并添加一个助手方法来立即运行传递到`getByCriteria()`方法中的标准并返回结果(不处理堆栈)。还有一种方法可以一次运行整个标准堆栈(已经被推入堆栈的内容)，`applyCriteria`。这很好地描述了成为一个支持`Criteria`的对象对我们的应用程序意味着什么。记下责任。

因为我们希望在我们的标准实现中包含一组丰富的功能，并且因为除了方法和签名之外，我们不能在接口中放置任何东西，所以我们可以创建一个抽象类来容纳跨子类的公共功能。无论如何，不要在需要附加到存储库实现的另一组类(或特征)中这样做，为了类类型的保存，我们可以做的是在基本存储库类中实现`Criteria`接口。接下来就是创建一个子类，为任何这样的模型扩展这个基本存储库，我们希望能够通过指定`Criteria`来查询该模型下的数据。在我们这样做之前，让我们确保在我们的系统中为一个基本的`Repository`类定义一个接口。为了明确标准存储库在一般意义上应该具有的功能，我们将创建接口，就好像我们在它的`Model`类的每一个实例上都没有口才一样(这意味着我们创建存储库来容纳底层模型被查询的方式)。为了简洁起见，我将省略清单 [19-2](#PC3) 中的 PHP 文档块。

```php
<?php

namespace Claim\Submission\Domain\Contracts;

interface Repository
{
     public function all(array $columns = ['*']);
     public function paginate(int $perpage=1, array $columns = ['*']);
     public function find(int $id, array $columns);
     public function findBy(string $field, $value, $columns=["*"]);
     public function findAllBy(string $field, $value, $columns=["*"]);
     public function findWhere(string $where, columns=[“*”]);
     public function findOrFail(int $id, $columns=[“*”];
}

Listing 19-2A Description of a Repository Object Without the Functionality of Eloquentat Is Provided in All Models

```

这个接口有点长，但是它包含了关于模型数据的所有基本需求，包括创建、读取、更新和删除(CRUD)等功能。如果我们把雄辩的 ORM 从等式中去掉，那么我们就需要以一种方式管理模型的数据，这种方式可以很容易地重复，并且可以在代码库的其余部分中任何需要的地方使用。这正是所列出的接口在存储库类的封装中所提供的。

还要注意我们在接口中定义这些方法的方式。这样做的方式是利用原始值，并且不包括对系统中任何其他类的引用。这是理想的，因为依赖关系越少，问题就越少；然而，这并不总是一个可行的解决方案。有时，事物只能存在于另一个已定义的类或接口的上下文中，并且必须包含在新接口的定义中。在定义接口时，尽可能坚持原始值，就像我们在清单 [19-3](#PC3) 中所做的那样。

```php
<?php

namespace Claim\Submission\Domain\Repository;

use Claim\Submission\Domain\Contracts\Repository as
     RepositoryInterface;
use Claim\Submission\Domain\Contracts\CriteriaHandler;

use Illuminate\Http\Request;
use Illuminate\Support\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Container\Container as App;
use Illuminate\Http\Exception\HttpResponseException;

abstract class BaseRepository implements RepositoryInterface,
                                     CriteriaHandler
{
     /** Specify the underlying model class */
     abstract public function model(): Model;

     /** Service Container */
     private App $app;

     /** The underlying model class name*/
     protected string $model;

     /** The current stack of criteria */
     protected Collection $criteria;

     /** Switch to skip criteria */
     protected bool $skipCriteria = false;

     /** Prevent overwriting same criteria in stack */
     protected bool $preventCriteriaOverwriting = true;

     public function __construct(App $app, Collection $collection)
     {
          $this->app = $app;
          $this->criteria = $collection;
          $this->resetScope();
          $this->makeModel();
     }

     public function all(array $columns = [“*”])
     {
          $this->applyCriteria();
          return $this->model->get($columns);
     }

     public function query()
     {
          return $this->model;
     }

     public function find($id, $columns=[“*”])
     {
          $this->applyCriteria();
          return $this->model->findOrFail($id, $columns);
     }

     public function findBy($attribute, $value, $columns=[“*”])
     {
          $this->applyCriteria();
          return $this->model->where($attribute, ‘=’,
               $value)->first($columns);
     }

     public function (Criteria $criteria)
     {
          $this->model = $criteria->apply($this->model, $this);
          return $this;
     }

     public function applyCriteria()
     {
          if ($this->skipCriteria === true) {
               return $this;
          }

          foreach ($this->getCriteria() as $criteria) {
               if ($criteria instanceof Criteria) {
                    $this->model = $criteria->apply(
                         $this->model, $this);
               }
          }
          return $this;
     }
}

Listing 19-3An Implementation of a Repository as Defined by the Repository and Criteria Interfaces

```

在清单 [19-3](#PC4) 中，我们在一个抽象类中有一个`Repository`和`Criteria`接口的通用实现。让我们通过查看图 [19-11](#Fig11) 来快速查看一下我们目前定义的结构。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig11_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig11_HTML.jpg)

图 19-11

当前实现的 UML

图 [19-11](#Fig11) 描述了一个抽象类实现多个契约(接口)的典型场景。该类不能被直接实例化，而是意味着从扩展而来，以便子类能够“储备”您在抽象类中提供的一组默认功能。现在，根据我们当时的需求，我们可以选择通过为每个接口实现独立的子类来进一步分离关注点，如图 [19-12](#Fig12) 所示。

![../images/488324_1_En_19_Chapter/488324_1_En_19_Fig12_HTML.jpg](../images/488324_1_En_19_Chapter/488324_1_En_19_Fig12_HTML.jpg)

图 19-12

我们的存储库和标准接口的更加复杂和灵活的版本

我们现在对整个对象模式有了一个额外的深度层，因为它获取的知识不仅是我们正在构建的东西的特定知识，更重要的是，是领域的特定知识。这样，当与一个`Criteria`对象结合使用时，我们已经表达了一个存储库的能力，并且我们已经在域的层次上这样做了。这种方法可能是有效的，但是作为一种折衷，可能会导致需要维护的额外类的激增，并且很可能为需要这种能力的每个域对象复制这些额外的类。通过将子类的创建限制在严格的按需基础上，可以避免这种情况，并且最终可以得到一些潜在可重用组件的丰富实现。这就是游戏的名字！尽可能地干燥，这与可重用代码的概念是一致的，并且当您在系统中添加这种严格的关注点分离时，它会变得更加强大。假设应用程序确实需要这些功能来完成它的工作(并且您或您的团队没有通过定义这种超详细、细粒度的微对象来过度设计它)，请确保它们不会以一组命名很长的接口和抽象结束，这些接口和抽象没有真正地将组件作为一个整体来传达，也没有提供它存在的任何理由，即它解决它想要解决的问题的能力。

就代码而言，从清单 [19-1](#PC2) 到 [19-2](#PC3) 的变化将是最小的，并且只要您编码到一个接口，而不是一个实现，使用这些接口的应用程序的任何其他部分(通常是应用程序或域服务)将不必修改。

Tip

值得以更独特的形式重复:

代码到接口，而不是实现。

为了实现这一点，您应该正确地键入任何消费代码，这些代码依赖于接口本身的任何实现的功能。只要领域被清楚地定义，并且你依赖它来指导你在这个和所有其他应用程序问题上的决定，这应该是自然而然的事情。

这就是对接口而不是对实现进行编码的好处:它允许更大的灵活性，并且增加了在应用程序的其他地方重用的机会(但这并不能保证)。接口本身可以由无限数量的子类来实现，每个子类指定更细粒度的细节。这是有道理的，因为使用这样一个抽象结构和明确的关注点分离的整个概念是能够定义一个接口的特定实例(也就是适配器)，这些实例描述了对象的“模式”(如果你愿意的话)中的特定规则，而这又是我们在接口(也就是端口)中定义的。这使我们能够以一种从一般到特殊的方式创建对象，对象的粒度封装在实现类的范围内。

关于这些图，最后要注意的一点是为什么它们是这样分开的。在定义包含在代码中的功能的概念线和边界的计算中，有哪些元素通过文件系统中的名称空间和物理位置进行划分？

Tip

简而言之，当定义分离应用程序关注点的界线时，总是尝试在域之后对它们建模，并根据它们的变化率对它们进行分组。以相同频率变化的物体应该放在一起。

如果我们试图将在同一类、模块或接口中以不同速率变化的事物与以该速率变化的其他事物保持在一起，这将在我们修改组件的任何部分或其结构时得到回报，因为它对依赖于它的代码几乎没有影响(如果有的话)。

## 结束语

领域驱动的设计是解决现代商业问题的实用方法，因为它保持了对领域的关注。在 web 应用程序世界中，当领域代码达到一定的复杂程度时，几乎总是会使用框架。这有多种原因，包括不必为应用层包含的每个机制重新发明轮子的好处。通过利用 Laravel 作为实现领域驱动设计的一种手段，我们可以设计出满足项目需求的应用程序，并确保我们的应用程序的生命周期。当我们热衷于遵循软件开发中的最佳实践和现代标准时，我们发现应用程序的维护变得更加简单，重构也是如此。扩展应用程序的功能可以相对容易地实现，并且可以以领域模块的形式出现，这使得根据领域本身封装功能逻辑(例如，`Order`模块、`Ship`模块等)变得容易。，来自我们本章开头的仓库应用程序)。

继续读。继续编码。继续想。保持一致。知识就是力量，缺乏知识就是无知。不要做后者。