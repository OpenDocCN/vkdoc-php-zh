# 3.对象基础

对象和类是本书的核心，自从十多年前引入 PHP 5 以来，它们也是 PHP 的核心。在这一章中，我通过研究 PHP 的核心面向对象特性，为更深入的对象和设计奠定了基础。如果你是面向对象编程的新手，你应该仔细阅读这一章。

本章将涵盖以下主题:

*   *类和对象*:声明类和实例化对象

*   *构造器方法*:自动设置你的对象

*   *原始类型和类类型*:为什么类型很重要

*   继承:为什么我们需要继承以及如何使用它

*   可见性:简化你的对象接口，保护你的方法和属性不受干扰

## 类和对象

理解面向对象编程的第一个障碍是类和对象之间奇怪而奇妙的关系。对于许多人来说，正是这种关系代表了第一个启示的时刻，第一次面向对象的兴奋的闪光。所以我们不要忽略基本原则。

### 一等舱

类通常用对象来描述。这很有趣，因为对象通常是用类来描述的。这种循环会使面向对象编程的第一步变得困难。因为是类塑造了对象，所以我们应该从定义一个类开始。

简而言之，类是用于生成一个或多个对象的代码模板。您用关键字`class`和一个任意的类名来声明一个类。类名可以是数字和字母的任意组合，但不能以数字开头。它们也可以包含下划线字符。与类关联的代码必须用大括号括起来。在这里，我将这些元素结合起来构建一个类:

```php
// listing 03.01

class ShopProduct
{
    // class body
}

```

示例中的`ShopProduct`类已经是一个合法的类，尽管它还不是非常有用。然而，我做了一件非常有意义的事情。我已经定义了一个类型；也就是说，我已经创建了一个可以在脚本中使用的数据类别。当你阅读这一章的时候，这种力量会变得更加清晰。

### 第一个(或两个)对象

如果类是生成对象的模板，那么对象就是根据类中定义的模板构造的数据。一个对象被称为它的类的一个实例。它是由类定义的类型。

我使用`ShopProduct`类作为生成`ShopProduct`对象的模型。为此，我需要`new`操作符。`new`运算符与类名结合使用，如下所示:

```php
// listing 03.02
$product1 = new ShopProduct();
$product2 = new ShopProduct();

```

用类名作为唯一的操作数调用`new`操作符，并返回该类的一个实例；在我们的例子中，它生成一个`ShopProduct`对象。

我已经使用了`ShopProduct`类作为模板来生成两个`ShopProduct`对象。尽管它们在功能上是相同的(即，空的)，`$product1`和`$product2`是从单个类生成的相同类型的不同对象。

如果你仍然困惑，试试这个类比。把一个类想象成制造塑料鸭子的机器中的一个铸件。我们的目标是这台机器生产的鸭子。产生的东西的类型是由压制它的模具决定的。这些鸭子在各方面看起来都一样，但它们是不同的实体。换句话说，它们是同一类型的不同实例。这些鸭子甚至可能有自己的序列号来证明它们的身份。在 PHP 脚本中创建的每个对象都有自己唯一的标识符。(注意，标识符对于对象的生命周期是唯一的；也就是说，PHP 重用标识符，即使是在一个进程中。)我可以通过打印出`$product1`和`$product2`对象来演示这一点:

```php
// listing 03.03
var_dump($product1);
var_dump($product2);

```

执行这些函数会产生以下输出:

```php
object(popp\ch03\batch01\ShopProduct)#235 (0) {

}

object(popp\ch03\batch01\ShopProduct)#234 (0) {

}

```

Note

在 PHP 的旧版本中(直到 5.1 版)，可以直接打印一个对象。这将对象转换为包含对象 ID 的字符串。从 PHP 5.2 开始，这种语言不再支持这种魔力，任何将对象视为字符串的尝试都会导致错误，除非在对象的类中定义了名为`__toString()`的方法。我将在本章后面介绍方法，我将在第四章[中介绍`__toString()`。](04.html)

通过将对象传递给`var_dump()`，我提取了有用的信息，包括在散列符号之后的每个对象的内部标识符。

为了让这些对象更有趣，我可以修改`ShopProduct`类来支持称为属性的特殊数据字段。

## 在类中设置属性

类可以定义称为属性的特殊变量。属性也称为成员变量，它保存的数据因对象而异。例如，对于`ShopProduct`对象，您可能希望操作标题和价格字段。

类中的属性看起来类似于标准变量，只是在声明属性时，必须在属性变量前面加上 visibility 关键字。这可以是`public`、`protected`或`private`，它决定了代码中可以访问属性的位置。例如，公共属性可以在类外部访问，私有属性只能由类内部的代码访问。

我将在本章的后面回到这些关键词和可见性的问题。现在，我将使用关键字`public`声明一些属性:

```php
// listing 03.04

class ShopProduct
{
    public $title = "default product";
    public $producerMainName = "main name";
    public $producerFirstName = "first name";
    public $price = 0;
}

```

如您所见，我设置了四个属性，并为每个属性分配了一个默认值。我从`ShopProduct`类实例化的任何对象现在将用默认数据预先填充。每个属性声明中的关键字`public`确保我可以从对象上下文外部访问属性。

您可以使用字符`'->'`(对象操作符)结合对象变量和属性名，逐个对象地访问属性变量，如下所示:

```php
// listing 03.05
$product1 = new ShopProduct();
print $product1->title;

default product

```

因为属性被定义为`public`，您可以像读取它们一样给它们赋值，替换类中设置的任何默认值:

```php
// listing 03.06
$product1 = new ShopProduct();
$product2 = new ShopProduct();
$product1->title = "My Antonia";
$product2->title = "Catch 22";

```

通过在`ShopProduct`类中声明和设置`$title`属性，我确保所有的`ShopProduct`对象在第一次创建时都有这个属性。这意味着基于这个假设，使用这个类的代码可以处理`ShopProduct`对象。因为我可以重置它，所以`$title`的值可能会因对象而异。

Note

使用类、函数或方法的代码通常被描述为类、函数或方法的*客户端*或*客户端代码*。在接下来的章节中，你会经常看到这个术语。

事实上，PHP 并没有强迫我们在类中声明所有的属性。您可以向对象动态添加属性，如下所示:

```php
// listing 03.07
$product1->arbitraryAddition = "treehouse";

```

然而，这种给对象分配属性的方法在面向对象编程中并不被认为是好的实践。

为什么动态设置属性是不好的做法？当你创建一个类时，你定义了一个类型。您告诉世界，您的类(以及从它实例化的任何对象)由一组特定的字段和函数组成。如果你的`ShopProduct`类定义了一个`$title`属性，那么任何使用`ShopProduct`对象的代码都可以在一个`$title`属性可用的假设下继续运行。但是，不能保证属性是动态设置的。

我的对象在这个阶段仍然是笨重的。当我需要处理一个对象的属性时，我必须在对象的外部进行。我伸手进去设置并获取属性信息。在多个对象上设置多个属性将很快变成一件苦差事:

```php
// listing 03.08
$product1 = new ShopProduct();
$product1->title = "My Antonia";
$product1->producerMainName  = "Cather";
$product1->producerFirstName = "Willa";
$product1->price = 5.99;

```

我再次使用`ShopProduct`类，一个接一个地覆盖所有的默认属性值，直到我设置了所有的产品细节。既然我已经设置了一些数据，我也可以访问它:

```php
// listing 03.09
print "author: {$product1->producerFirstName} "
    . "{$product1->producerMainName}\n";

```

这将输出以下内容:

```php
author: Willa Cather

```

这种设置属性值的方法存在许多问题。因为 PHP 允许您动态设置属性，所以如果您拼错或忘记了属性名，您不会得到警告。例如，假设我想键入这一行:

```php
// listing 03.10
$product1->producerFirstName = "Shirley";
$product1->producerMainName = "Jackson";

```

不幸的是，我错误地打成了这样:

```php
// listing 03.11
$product1->producerFirstName = "Shirley";
$product1->producerSecondName = "Jackson";

```

就 PHP 引擎而言，这段代码完全合法，我不会被警告。但是，当我打印作者的名字时，我会得到意想不到的结果。

另一个问题是我的课堂太放松了。我没有被强迫去设定一个标题，一个价格，或者制片人的名字。客户端代码可以确保这些属性的存在，但是很可能经常会遇到默认值。理想情况下，我鼓励任何实例化`ShopProduct`对象的人设置有意义的属性值。

最后，我不得不千方百计去做一些我可能经常想做的事情。正如我们已经看到的，打印完整的作者姓名是一个令人厌倦的过程。

让对象代表我处理这种苦差事会很好。

所有这些问题都可以通过赋予`ShopProduct`对象自己的一组函数来解决，这些函数可以用来在对象上下文中操作属性数据。

## 使用方法

正如属性允许对象存储数据一样，方法允许对象执行任务。方法是在类中声明的特殊函数。正如您所料，方法声明类似于函数声明。`function`关键字位于方法名之前，后面是括号中的可选参数变量列表。方法体用大括号括起来:

```php
// listing 03.12

public function myMethod($argument, $another)
{
    // ...
}

```

与函数不同，方法必须在类的主体中声明。它们还可以接受许多限定符，包括一个 visibility 关键字。像属性一样，方法可以被声明为`public`、`protected`或`private`。通过声明一个方法`public`，您可以确保它可以从当前对象的外部被调用。如果在方法声明中省略了 visibility 关键字，该方法将被隐式声明为`public`。然而，为所有方法显式声明可见性被认为是一种好的做法(我将在本章后面回到方法修饰符)。

Note

在第 15 章中，我将介绍代码中的最佳实践规则。编码风格标准 PSR-12 要求为所有方法声明可见性。

```php
// listing 03.13

class ShopProduct
{
    public $title = "default product";
    public $producerMainName = "main name";
    public $producerFirstName = "first name";
    public $price = 0;

    public function getProducer()
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

在大多数情况下，您将使用对象变量以及对象操作符`->`和方法名来调用方法。在方法调用中必须使用括号，就像调用函数一样(即使不向方法传递任何参数):

```php
// listing 03.14

$product1 = new ShopProduct();
$product1->title = "My Antonia";
$product1->producerMainName = "Cather";
$product1->producerFirstName = "Willa";
$product1->price = 5.99;

print "author: {$product1->getProducer()}\n";

```

这将输出以下内容:

```php
author: Willa Cather

```

我将`getProducer()`方法添加到`ShopProduct`类中。注意，我声明`getProducer()`是公共的，这意味着它可以从类外部调用。

我在这个方法的主体中引入了一个特性。`$this`伪变量是一个类引用一个对象实例的机制。如果你觉得这个概念难以接受，试着用短语“当前实例”代替`$this`请考虑以下陈述:

```php
$this->producerFirstName

```

这转化为以下内容:

**当前实例**的 `$producerFirstName` **属性**

因此,`getProducer()`方法组合并返回`$producerFirstName`和`$producerMainName`属性，使我在每次需要引用完整的生产者名称时免于执行这项任务。

这让班级提高了一点。尽管如此，我仍然受困于大量不必要的灵活性。我依靠客户端编码器来改变一个`ShopProduct`对象的默认值。这在两个方面存在问题。首先，正确初始化一个`ShopProduct`对象需要 5 行代码，没有一个编码人员会为此感谢你。第二，我无法确保在初始化`ShopProduct`对象时设置了任何属性。

我需要的是一个当一个对象从一个类实例化时自动调用的方法。

## 创建构造函数方法

创建对象时会调用构造函数方法。您可以使用它来进行设置，确保为重要的属性赋值，并完成任何必要的准备工作。

Note

在 PHP 5 之前的版本中，构造函数方法采用了封装它的类名。所以`ShopProduct`类将使用一个`ShopProduct()`方法作为它的构造函数。这在 PHP 7 中被否决，在 PHP 8 中不再有效。将你的构造方法命名为`__construct()`。

注意，方法名以两个下划线字符开头。对于 PHP 类中的许多其他特殊方法，您会看到这种命名约定。在这里，我为`ShopProduct`类定义了一个构造函数:

Note

以这种方式开始的内置方法被称为*魔法方法*，因为它们在特定的环境中会被自动调用。你可以在 [`www.php.net/manual/en/language.oop5.magic.php`](http://www.php.net/manual/en/language.oop5.magic.php) 的 PHP 手册中读到更多关于它们的内容。虽然这样做并不违法，因为双下划线有如此特殊的含义，但在您自己的自定义方法中避免使用它们是一个好主意。

```php
// listing 03.15
class ShopProduct
{
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price = 0;

    public function __construct(
        $title,
        $firstName,
        $mainName,
        $price
    ) {
        $this->title = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName = $mainName;
        $this->price = $price;
    }

    public function getProducer()
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

我再一次将功能收集到类中，节省了使用它的代码的工作量和重复。使用`new`操作符创建对象时，调用`__construct()`方法:

```php
// listing 03.16
$product1 = new ShopProduct(
    "My Antonia",
    "Willa",
    "Cather", 5.99
);
print "author: {$product1->getProducer()}\n";

```

这会产生以下结果:

```php
author: Willa Cather

```

提供的任何参数都传递给构造函数。所以在我的例子中，我将标题、名字、主要名称和产品价格传递给构造函数。构造函数方法使用伪变量`$this`给对象的每个属性赋值。

Note

一个`ShopProduct`对象现在更容易实例化，使用起来也更安全。实例化和设置在一条语句中完成。任何使用`ShopProduct`对象的代码都可以合理地确定它的所有属性都已初始化。

您可以不初始化属性而不出错。但是任何访问该属性的尝试都会导致致命错误。

### 构造函数属性提升

虽然我们已经使`ShopProduct`类更加安全，并且从客户的角度来看更加方便，但是我们也引入了相当多的样板文件。回顾一下这个班级的现状。为了用四个属性实例化一个对象，我们总共需要三组对数据的引用。首先，我们声明属性，然后我们提供构造函数参数来保存数据，然后当我们将方法参数分配给属性时，我们将所有数据放在一起。PHP 8 提供了一个名为*构造器* *属性提升*的特性，它提供了一个受欢迎的快捷方式。通过为您的构造函数参数包含一个 visibility 关键字，您可以将它们与同时分配给它们的属性声明*和*结合起来。下面是`ShopProduct`的新版本:

```php
// listing 03.17
class ShopProduct
{
    public function __construct(
        public $title,
        public $producerFirstName,
        public $producerMainName,
        public $price
    ) {
    }

    public function getProducer()
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

构造函数方法签名中属性的声明和赋值都是隐式处理的。通过减少重复，这也减少了错误潜入代码的机会。通过使类更加紧凑，阅读源代码的人更容易关注逻辑。

Note

PHP 8 中引入了构造函数属性提升。如果您的项目仍然运行 PHP 7，那么您应该避免利用新语法。

可预测性是面向对象编程的一个重要方面。您应该设计您的类，以便对象的用户可以确定它们的特性。使对象安全的一种方法是使其属性中保存的数据类型可预测。例如，可以确保一个`$name`属性总是由字符数据组成。但是，如果属性数据是从类外部传入的，如何实现这一点呢？在下一节中，我将研究一种可以用来在方法声明中强制对象类型的机制。

## 默认参数和命名参数

随着时间的推移，方法参数列表会变得又长又笨拙。这使得处理一个类变得越来越困难，因为很难跟踪它的方法所需要的参数。通过在方法定义中提供默认值，我们可以让客户端编码人员的工作变得更容易。比方说，我们需要一个标题给我们的`ShopProduct`对象，但是接受空字符串值作为生产者名称，零值作为价格。对于`ShopProduct`，调用代码需要提供所有这些数据:

```php
// listing 03.18
$product1 = new ShopProduct("Shop Catalogue", "", "", 0);

```

我们可以通过为参数提供默认值来简化这种实例化。在下一个例子中，我就是这样做的:

```php
// listing 03.19
class ShopProduct
{
    public function __construct(
    public $title,
    public $producerFirstName = "",
    public $producerMainName = "",
    public $price = 0
    ) {
    }

    // ...
}

```

只有当调用代码在其调用中不提供值时，这些赋值才会被激活。现在，对构造函数的调用只需要指定一个值:标题。

```php
// listing 03.20
$product1 = new ShopProduct("Shop Catalogue");

```

默认的参数值可以使使用方法更加方便，但是，通常情况下，它们也会导致意想不到的复杂化。如果我想提供一个价格，但仍然希望生产者名称回到它们的默认值，那么我的紧凑构造函数调用会发生什么情况呢？在 PHP 8 之前，我会被卡住。为了指定价格，我必须提供空的生产商名称。这让我们兜了一圈。我还需要弄清楚构造函数期望空的生产者名称值是什么类型的值。我应该传递空字符串吗？还是空值？我对缺省值的支持非但没有节省工作，反而很可能造成了混乱。

幸运的是，PHP 8 提供了命名参数。在我的方法调用中，我现在可以在我希望传递的值前面指定每个参数名。然后，PHP 将该值与方法签名中的正确参数相关联，而不考虑调用代码中的顺序。

```php
// listing 03.21
$product1 = new ShopProduct(
    price: 0.7,
    title: "Shop Catalogue"
);

```

注意这里的语法:我告诉 PHP 我想通过首先指定参数名`price`，然后是冒号，然后是我想提供的值，将`$price`参数设置为`0.7`。因为我已经使用了命名参数，它们在调用中的顺序不再相关，我不再需要提供空的生产者名称值。

## 参数和类型

类型决定了在脚本中管理数据的方式。例如，您可以使用`string`类型来显示字符数据，并使用字符串函数来操作这些数据。数学表达式中使用整数，测试表达式中使用布尔，等等。这些类别被称为基本类型。然而，在更高的层次上，类定义了类型。因此，`ShopProduct`对象属于原始类型`object`，但它也属于`ShopProduct`类类型。在这一节中，我将研究这两种类型与类方法的关系。

方法和函数定义不一定要求参数应该是特定的类型。这既是祸也是福。参数可以是任何类型，这一事实为您提供了灵活性。您可以构建智能地响应不同数据类型的方法，根据不断变化的环境定制功能。当一个方法体期望一个参数保存一种类型，但却得到另一种类型时，这种灵活性也会导致代码中出现歧义。

### 原始类型

PHP 是一种松散类型的语言。这意味着没有必要声明变量来保存特定的数据类型。变量`$number`可以在相同的范围内保存值`2`和字符串`"two"`。在强类型语言中，如 C 或 Java，在给变量赋值之前，必须声明变量的类型，当然，该值必须是指定的类型。

这并不意味着 PHP 没有类型的概念。每个可以赋给变量的值都有一个类型。您可以使用 PHP 的一个类型检查函数来确定变量值的类型。表 [3-1](#Tab1) 列出了 PHP 中识别的原语类型及其对应的测试函数。每个函数接受一个变量或值，如果这个参数是相关类型的，则返回`true`。

表 3-1

PHP 中的基本类型和检查函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

类型检查功能

 | 

类型

 | 

描述

 |
| --- | --- | --- |
| `is_bool()` | 布尔代数学体系的 | 两个特殊值之一 true 或 false |
| `is_integer()` | 整数 | 一个整数。`is_int()`和`is_long()`的别名 |
| `is_float()` | 浮动 | 浮点数(带小数点的数字)。`is_double()`的别名 |
| `is_string()` | 线 | 字符数据 |
| `is_object()` | 目标 | 一个物体 |
| `is_resource()` | 资源 | 用于识别和使用外部资源(如数据库或文件)的句柄 |
| `is_array()` | 排列 | 阵列 |
| `is_null()` | 空 | 未分配的价值 |

当您使用方法和函数参数时，检查变量的类型可能特别重要。

#### 基本类型:一个示例

您需要密切关注代码中的类型。这是你可能遇到的许多类型相关问题中的一个例子。

假设您正在从 XML 文件中提取配置设置。XML 元素告诉您的应用程序是否应该尝试将 IP 地址解析为域名，这是一个有用但相对昂贵的过程。

以下是一些示例 XML:

```php
// listing 03.22
<settings>
    <resolvedomains>false</resolvedomains>
</settings>

```

字符串`"false"`由您的应用程序提取，并作为一个标志传递给一个名为`outputAddresses()`的方法，该方法显示 IP 地址数据。这里是`outputAddresses()`:

```php
// listing 03.23

class AddressManager
{
    private $addresses = ["209.131.36.159", "216.58.213.174"];

    public function outputAddresses($resolve)
    {
        foreach ($this->addresses as $address) {
            print $address;
            if ($resolve) {
                print " (" . gethostbyaddr($address) . ")";
            }
            print "\n";
        }
    }
}

```

当然，`AddressManager`类可以做一些改进。例如，将 IP 地址硬编码到一个类中不是很有用。然而，`outputAddresses()`方法循环遍历`$addresses`数组属性，打印每个元素。如果`$resolve`参数变量本身解析为`true`，该方法将输出域名和 IP 地址。

这里有一种结合使用`settings` XML 配置元素和`AddressManager`类的方法。看看你是否能发现它有什么缺陷:

```php
// listing 03.24
$settings = simplexml_load_file(__DIR__ . "/resolve.xml");
$manager = new AddressManager();
$manager->outputAddresses((string)$settings->resolvedomains);

```

代码片段使用`SimpleXML` API 来获取`resolvedomains`元素的值。在这个例子中，我知道这个值是文本元素`"false"`，我按照`SimpleXML`文档的建议将它转换成一个字符串。

这段代码不会像您预期的那样运行。在将字符串`"false"`传递给`outputAddresses()`方法时，我误解了该方法对参数的隐含假设。该方法需要一个布尔值(即`true`或`false`)。事实上，字符串`"false"`将在测试中解析为`true`。这是因为 PHP 将在测试上下文中帮助您将一个非空字符串值转换为布尔值`true`。考虑以下代码:

```php
if ("false") {
    // ...
}

```

它实际上相当于这样:

```php
if (true) {
    // ...
}

```

有许多方法可以解决这个问题。

您可以使`outputAddresses()`方法更加宽容，这样它可以识别一个字符串，并应用一些基本规则将它转换成布尔等价形式:

```php
// listing 03.25
public function outputAddresses($resolve)
{
    if (is_string($resolve)) {
        $resolve = (preg_match("/^(false|no|off)$/i", $resolve)) ? false : true;
    }
    // ...
}

```

然而，避免这种方法有很好的设计理由。一般来说，为一个方法或函数提供一个清晰严格的接口比提供一个模糊宽容的接口要好。模糊和宽容的函数和方法会导致混乱，从而滋生错误。

您可以采用另一种方法:让`outputAddresses()`方法保持原样，并包含一个注释，该注释包含明确的指令，即`$resolve`参数应该包含一个布尔值。这种方法本质上是告诉编码者阅读小字，否则后果自负:

```php
// listing 03.26

/**
 * Outputs the list of addresses.
 * If $resolve is true then each address will be resolved
 * @param    $resolve    boolean    Resolve the address?
 */
public function outputAddresses($resolve)
{
    // ...
}

```

这是一种合理的方法，假设您的客户端编码人员是文档的勤奋读者(或者使用能够识别这种注释的聪明编辑器)。

最后，您可以让`outputAddresses()`严格控制它准备在`$resolve`参数中找到的数据类型。对于像 Boolean 这样的基本类型，在 PHP 7 发布之前只有一种方法可以做到这一点。您必须编写代码来检查传入的数据，并在数据与所需类型不匹配时采取某种措施:

```php
// listing 03.27
public function outputAddresses($resolve)
{
    if (! is_bool($resolve)) {
        // do something drastic
    }
}

```

这种方法可以用来强制客户端代码在`$resolve`参数中提供正确的数据类型，或者发出警告。

Note

在下一节“类型声明:对象类型”中，我将描述一种更好的方法来约束传递给方法和函数的参数类型。

代表客户端转换字符串参数是友好的，但可能会带来其他问题。在提供转换机制时，您要猜测客户端的上下文和意图。另一方面，通过强制布尔数据类型，您让客户端决定是否将字符串映射到布尔值，并决定哪个单词应该映射到`true`或`false`。与此同时，`outputAddresses()`方法专注于它被设计来执行的任务。这种强调在故意忽略更广泛的上下文的情况下执行特定任务的做法是面向对象编程中的一个重要原则，我将在整本书中经常提到它。

事实上，您处理参数类型的策略一方面取决于任何潜在错误的严重性，另一方面取决于灵活性的好处。PHP 根据上下文为您转换大多数原始值。例如，当在数学表达式中使用时，字符串中的数字被转换为整数或浮点等效值。因此您的代码可能会自然地原谅类型错误。

然而，总的来说，当涉及到对象和基本类型时，最好是在严格性方面出错。幸运的是，PHP 8 提供了比以前更多的工具来加强类型安全。

### 一些其他类型检查函数

我们已经看到了检查原始类型的变量处理函数。当我们检查变量的内容时，值得一提的是几个函数，它们超出了检查基本类型的范围，提供了关于变量中保存的数据的使用方式的更一般的信息。我在表 [3-2](#Tab2) 中列出了这些。

表 3-2

伪类型检查函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能

 | 

描述

 |
| --- | --- |
| `is_countable()` | 可以传递给`count()`函数的数组或对象 |
| `is_iterable()` | 可遍历的数据结构——也就是说，可以使用`foreach`进行循环 |
| `is_callable()` | 可以调用的代码—通常是匿名函数或函数名 |
| `is_numeric()` | int、long 或可以解析为数字的字符串 |

表 [3-2](#Tab2) 中描述的函数并不检查具体的类型，而是检查处理测试值的方式。例如，如果`is_callable()`为一个变量返回`true`，您知道您可以像对待一个函数或方法一样对待它并调用它。类似地，您可以循环通过一个通过了`is_iterable()`测试的值——即使它可能是一种特殊的对象而不是数组。

### 类型声明:对象类型

正如参数变量可以包含任何基本类型一样，默认情况下，它可以包含任何类型的对象。这种灵活性有其用途，但在方法定义的上下文中可能会出现问题。

想象一个设计用来处理`ShopProduct`对象的方法:

```php
// listing 03.28
class ShopProductWriter
{
    public function write($shopProduct)
    {
        $str  = $shopProduct->title . ": "
            . $shopProduct->getProducer()
            . " (" . $shopProduct->price . ")\n";
        print $str;
    }
}

```

您可以像这样测试这个类:

```php
// listing 03.29
$product1 = new ShopProduct("My Antonia", "Willa", "Cather", 5.99);
$writer = new ShopProductWriter();
$writer->write($product1);

```

这将输出以下内容:

```php
My Antonia: Willa Cather (5.99)

```

`ShopProductWriter`类包含一个方法`write()`。`write()`方法接受一个`ShopProduct`对象，并使用它的属性和方法来构造和打印一个摘要字符串。我使用了参数变量的名字`$shopProduct`，作为该方法需要一个`ShopProduct`对象的信号，但是我没有强制这样做。这意味着我可能会被传递一个意外的对象或原始类型，直到我开始尝试使用`$shopProduct`参数时才知道。到那时，我的代码可能已经假定它已经被传递了一个真正的`ShopProduct`对象。

Note

你可能想知道为什么我没有直接把`write()`方法添加到`ShopProduct`中。原因在于责任范围。`ShopProduct`类负责管理产品数据；`ShopProductWriter`负责写它。当你阅读本章时，你会开始明白为什么这种分工会有用。

为了解决这个问题，PHP 5 引入了类类型声明(当时称为类型提示)。要将类类型声明添加到方法参数中，只需在需要约束的方法参数前放置一个类名。所以我可以这样修改`write()`方法:

```php
// listing 03.30
public function write(ShopProduct $shopProduct)
{
    // ...
}

```

现在，`write()`方法将只接受包含类型为`ShopProduct`的对象的`$shopProduct`参数。

下面是一个基础类:

```php
// listing 03.31
class Wrong
{
}

```

下面是一个试图用一个`Wrong`对象调用`write()`的片段:

```php
// listing 03.32
$writer = new ShopProductWriter();
$writer->write(new Wrong());

```

因为`write()`方法包含一个类类型声明，传递给它一个`Wrong`对象会导致致命错误。

```php
TypeError: popp\ch03\batch08\ShopProductWriter::write(): Argument #1 ($shopProduct) must be of type
popp\ch03\batch04\ShopProduct, popp\ch03\batch08\Wrong given, called in /var/popp/src/ch03/batch08/Runner.php on ...

```

Note

在 TypeError 示例输出中，您可能已经注意到引用的类包含了许多附加信息。例如，`Wrong`类被引用为`popp\ch03\batch08\ Wrong`。这些是*名称空间*的例子，你会在第四章[中遇到它们的细节。](04.html)

这使我不必在处理之前测试参数的类型。这也使得方法签名对于客户端编码者来说更加清晰。她一眼就能看出`write()`方法的要求。她不必担心由类型错误引起的一些模糊错误，因为声明是严格执行的。

尽管这种自动类型检查是防止错误的好方法，但是理解类型声明是在运行时检查的还是很重要的。这意味着类声明只会在不需要的对象被传递给方法时报告错误。如果对`write()`的调用隐藏在一个只在圣诞节早上运行的条件子句中，如果你没有仔细检查你的代码，你可能会发现自己在这个假期工作。

### 类型声明:基本类型

在 PHP 7 发布之前，只能约束对象和一些其他类型(callable 和 array)。PHP 7 最终引入了标量类型声明。这允许您在参数列表中强制使用布尔、字符串、整数和浮点类型。

有了标量类型声明，我可以向`ShopProduct`类添加一些约束:

```php
// listing 03.33
class ShopProduct
{
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price = 0;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price
    ) {
        $this->title = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName = $mainName;
        $this->price = $price;
    }

    // ...
}

```

有了这样的构造函数方法，我就可以确定`$title`、`$firstName`和`$mainName`参数将总是包含字符串数据，而`$price`将包含一个浮点数。我可以通过用错误的信息实例化`ShopProduct`来证明这一点:

```php
// listing 03.34
// will fail
$product = new ShopProduct("title", "first", "main", []);

```

我试图实例化一个`ShopProduct`对象。我向构造函数传递了三个字符串，但是我在最后一关失败了，因为我传入了一个空数组而不是所需的 float。多亏了类型声明，PHP 不会让我得逞:

```php
TypeError: popp\ch03\batch09\ShopProduct:: construct(): Argument #4 ($price) must be of type float, array given, called in...

```

默认情况下，在可能的情况下，PHP 会隐式地将参数转换为所需的类型。这是我们之前遇到的安全性和灵活性之间紧张关系的一个例子。例如，`ShopProduct`类的新实现将悄悄地为我们把一个字符串转换成一个浮点数。因此，该实例化不会失败:

```php
// listing 03.35
$product = new ShopProduct("title", "first", "main", "4.22");

```

在幕后，字符串`"4.22"`变成了浮点`4.22`。到目前为止，很有用。但是回想一下我们在使用`AddressManager`类时遇到的问题。字符串`"false"`被悄悄地解析成布尔型`true`。默认情况下，如果我像这样在`AddressManager::outputAddresses()`方法中使用`bool`类型声明，这种情况仍然会发生:

```php
// listing 03.36
public function outputAddresses(bool $resolve)
{
    // ...
}

```

现在考虑这样一个调用，它传递一个字符串:

```php
// listing 03.37
$manager->outputAddresses("false");

```

由于隐式转换，它在功能上等同于传递布尔值`true`的函数。

您可以使标量类型声明变得严格，尽管只能在逐个文件的基础上进行。在这里，我打开严格类型声明并再次用字符串调用`outputAddresses()`:

```php
// listing 03.38
declare(strict_types=1);

        $manager->outputAddresses("false");

```

因为我声明了严格类型，所以这个调用导致抛出一个`TypeError`:

```php
TypeError: popp\ch03\batch09\AddressManager::outputAddresses(): Argument #1 ($resolve) must be of type bool, string given, called in...

```

Note

`strict_types`声明适用于发出调用的文件，而不适用于实现函数或方法的文件。所以由客户机代码来执行严格性。

您可能需要将参数设置为可选的，但是如果提供了参数的话，还是要对其类型进行约束。您可以通过提供默认值来做到这一点:

```php
// listing 03.39
class ConfReader
{

    public function getValues(array $default = [])
    {
        $values = [];

        // do something to get values

        // merge the provided defaults (it will always be an array)
        $values = array_merge($default, $values);
        return $values;
    }
}

```

### `mixed`类型

PHP 8.0 中引入的`mixed`类型声明可能被视为一个语法糖的例子——也就是说，它本身并没有做太多事情。这之间没有*功能*的区别:

```php
// listing 03.40
class Storage
{
    public function add(string $key, $value)
    {
        // do something with $key and $value
    }
}

```

还有这个:

```php
// listing 03.41

class Storage
{
    public function add(string $key, mixed $value)
    {
        // do something with $key and $value
    }
}

```

在第二个版本中，我声明`add()`的`$value`参数将接受`mixed`——换句话说，来自`array`、`bool`、`callable`、`int`、`float`、`null`、`object`、`resource`或`string`的任何类型。所以声明一个`mixed $value`等同于让`$value`在参数列表中没有类型声明。那么，为什么要为`mixed`声明费心呢？本质上，您是在声明参数*有意地*接受任何值。一个空的参数可能会接受任何值，或者因为代码作者懒惰而没有类型声明。消除怀疑和不确定性，因此它是有用的。

综上所述，在表 [3-3](#Tab3) 中，我列出了 PHP 支持的类型声明。

表 3-3

类型声明

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

类型声明

 | 

因为

 | 

描述

 |
| --- | --- | --- |
| `array` | Five point one | 一个数组。可以默认为`null`或一个数组 |
| `int` | Seven | 整数。可以默认为`null`或整数 |
| `float` | Seven | 浮点数(带小数点的数字)。即使启用了严格模式，也将接受整数。可以默认为`null`，一个浮点数，或者一个整数 |
| `callable` | Five point four | 可调用代码(如匿名函数)。可以默认为`null` |
| `bool` | Seven | 一个布尔值。可以默认为`null`或布尔值 |
| `string` | Five | 字符数据。可以默认为`null`或一个字符串 |
| `self` | Five | 对包含类的引用 |
| `[a class type]` | Five | 类或接口的类型。可以默认为`null` |
| `iterable` | Seven point one | 可以用`foreach`遍历(不一定是数组，可以实现`Traversable`) |
| 目标 | Seven point two | 一个物体 |
| 混合的 | Eight | 值可以是任何类型的显式通知 |

### 联合类型

在包罗万象的`mixed`声明和相对严格的类型声明之间有一条鸿沟。如果需要将一个参数约束到两个、三个或更多的命名类型，该怎么办？在 PHP 8 之前，实现这一点的唯一方法是在方法体中测试类型。让我们带着新的需求回到`Storage`类。`add()`应该只接受一个字符串或一个布尔值作为它的`$value`方法。下面是一个在方法体中检查类型的实现:

```php
// listing 03.42

class Storage
{
    public function add(string $key, $value)
    {
        if (! is_bool($value) && ! is_string($value)) {
            error_log("value must be string or Boolean - given: " . gettype($value));
            return false;
        }
        // do something with $key and $value
    }
}

```

Note

事实上，我们可能会抛出一个异常，而不是返回`false`。你可以在第 4 章中读到更多关于异常的内容。

虽然这种手工检查完成了工作，但它很难操作，也很难阅读。幸运的是，PHP 8 引入了一个新特性:联合类型，它允许您组合两个或多个由管道符号分隔的类型，以进行复合类型声明。

下面是我对`Storage`的重新实现:

```php
// listing 03.43

class Storage
{
    public function add(string $key, string|bool $value)
    {
        // do something with $key and $value
    }
}

```

如果我现在试图将`$value`设置为除了 float 或 Boolean 之外的任何值，我将触发一个现在已经很熟悉的`TypeError`。

如果我想让`add()`更宽容一点，我也可以使用联合类型来允许一个`null`值。

```php
// listing 03.44

class Storage
{
    public function add(string $key, string|bool|null $value)
    {
        // do something with $key and $value
    }

}

```

联合类型声明与对象类型声明一样有效。此示例将接受类型为`ShopProduct`的对象或空值:

```php
// listing 03.45
public function setShopProduct(ShopProduct|null $product)
{
    // do something with $product
}

```

因为许多方法接受或返回`false`作为可选值，PHP 8 在联合的上下文中支持`false`伪类型。因此，在这个例子中，我将接受一个`ShopProduct`对象或`false`:

```php
// listing 03.46
    public function setShopProduct2(ShopProduct|false $product)
    {
        // do something with $product
    }

}

```

这比 union `ShopProduct|bool`更有用，因为在任何情况下我都不想接受`true`。

Note

PHP 8 中增加了联合类型。

### 可空类型

当联合类型接受`null`作为两个选项之一时，您可以使用一个等价的参数。可空类型由前面带问号的类型声明组成。所以这个版本的`Storage`要么接受一个字符串，要么接受`null`:

```php
// listing 03.47

class Storage
{
    public function add(string $key, ?string $value)
    {
        // do something with $key and $value
    }
}

```

当我描述类类型声明时，我暗示类型和类是同义的。然而，这两者之间有一个关键的区别。当你定义一个类的时候，你也定义了一个类型，但是一个类型可以描述整个类家族。将不同的类组合在一个类型下的机制称为继承。我将在下一节讨论继承。

## 返回类型声明

正如我们可以声明参数的类型一样，我们也可以使用返回类型声明来约束方法返回的类型。返回类型声明直接放在方法或函数的右括号之后，采用冒号后跟类型的形式。声明返回类型和声明参数类型时支持相同的类型集。所以这里我约束了`getPlayLength()`的返回类型:

```php
// listing 03.48
public function getPlayLength(): int
{
    return $this->playLength;
}

```

如果调用此方法时未能返回整数值，PHP 将生成一个错误:

```php
TypeError: popp\ch03\batch15\CdProduct::getPlayLength(): Return value must be of type int, none returned

```

因为返回值是以这种方式强制的，所以任何调用此方法的代码都可以放心地将其返回值视为整数。

返回类型声明支持可空类型和联合类型。让我们强制一个联合类型:

```php
// listing 03.49
public function getPrice(): int|float
{
    return ($this->price - $this->discount);
}

```

从 PHP 8 开始，有一种类型是由返回类型声明而不是参数类型声明支持的。您可以声明一个方法永远不会返回一个带有`void`伪类型的值。因此，例如，因为`setDiscount()`方法被设计为设置而不是提供一个值，所以我在这里使用了一个`void`返回类型声明:

```php
// listing 03.50
public function setDiscount(int|float $num): void
{
    $this->discount = $num;
}

```

## 遗产

继承是从基类派生一个或多个类的方法。

从另一个类继承而来的类称为它的子类。这种关系经常用父母和孩子来描述。子类从父类派生并继承父类的特征。这些特征包括属性和方法。子类通常会向其父类(也称为超类)提供的功能添加新功能；由于这个原因，子类扩展了它的父类。

在深入研究继承的语法之前，我将检查它可以帮助您解决的问题。

### 继承问题

再看看`ShopProduct`类。目前，它非常通用。它可以处理各种产品:

```php
// listing 03.51

$product1 = new ShopProduct("My Antonia", "Willa", "Cather", 5.99);
$product2 = new ShopProduct(
    "Exile on Coldharbour Lane", "The",
    "Alabama 3",
    10.99
);
print "author: " . $product1->getProducer() . "\n";
print "artist: " . $product2->getProducer() . "\n";

```

以下是输出结果:

```php
author: Willa Cather
artist: The Alabama 3

```

将制作者的名字分成两部分对书籍和 CD 都很有效。我希望能够对“阿拉巴马 3”和“凯瑟”进行排序，而不是对“The”和“Willa”进行排序。懒惰是一种优秀的设计策略，所以现阶段不需要担心对不止一种产品使用`ShopProduct`。

然而，如果我在我的例子中添加一些新的需求，事情会迅速变得更加复杂。例如，假设您需要表示特定于书籍和 CD 的数据。对于 CD，必须存储总播放时间；对于书籍，总页数。可能有许多其他的差异，但这将有助于说明这个问题。

我如何扩展我的例子来适应这些变化？两种选择立即呈现在眼前。首先，我可以将所有的数据放入`ShopProduct`类。其次，我可以将`ShopProduct`分成两个独立的类。

让我们检查第一种方法。这里，我将 CD 和书籍相关的数据合并到一个类中:

```php
// listing 03.52
class ShopProduct
{
    public $numPages;
    public $playLength;
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $numPages = 0,
        int $playLength = 0
    ) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
        $this->numPages          = $numPages;
        $this->playLength        = $playLength;
    }

    public function getNumberOfPages(): int
    {
        return $this->numPages;
    }

    public function getPlayLength(): int
    {
        return $this->playLength;
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

我已经提供了对`$numPages`和`$playLength`属性的方法访问，以说明在这里起作用的不同力量。从此类实例化的对象将包含一个冗余方法，对于 CD，必须使用一个不必要的构造函数参数进行实例化:CD 将存储与书籍页面相关的信息和功能，而书籍将支持播放长度数据。这可能是你现在可以忍受的。但是，如果我添加更多的产品类型，每个类型都有自己的方法，然后为每个类型添加更多的方法，会发生什么呢？我们的班级会变得越来越复杂，越来越难管理。

因此，将不属于同一个类的字段强制放入一个类会导致对象臃肿，具有冗余的属性和方法。

问题也不仅仅止于数据。我在功能性方面也遇到了困难。考虑一种总结产品的方法。销售部门要求在发票中使用清晰的汇总行。他们希望我包括 CD 的播放时间和书籍的页数，所以我将被迫为每种类型提供不同的实现。我可以尝试使用一个标志来跟踪对象的格式。

这里有一个例子:

```php
// listing 03.53

public function getSummaryLine(): string
{
    $base  = "{$this->title} ( {$this->producerMainName}, ";
    $base .= "{$this->producerFirstName} )";
    if ($this->type == 'book') {
        $base .= ": page count - {$this->numPages}";
    } elseif ($this->type == 'cd') {
        $base .= ": playing time - {$this->playLength}";
    }
    return $base;
}

```

为了设置`$type`属性，我可以测试构造函数的`$numPages`参数。然而，`ShopProduct`类又一次变得比必要的更加复杂。随着我在我的格式中添加更多的差异，或者添加新的格式，这些功能上的差异将变得更加难以管理。也许我应该尝试用另一种方法来解决这个问题。

由于开始感觉像是两个类合二为一，我可以接受这一点，创建两种类型而不是一种。我可能会这样做:

```php
// listing 03.54
class CdProduct
{
    public $playLength;
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $playLength
    ) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
        $this->playLength        = $playLength;
    }

    public function getPlayLength(): int
    {
        return $this->playLength;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": playing time - {$this->playLength}";
        return $base;
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

```php
// listing 03.55
class BookProduct
{
    public $numPages;
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $numPages
    ) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
        $this->numPages          = $numPages;
    }

    public function getNumberOfPages(): int
    {
        return $this->numPages;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": page count - {$this->numPages}";
        return $base;
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }
}

```

我已经解决了复杂性问题，但这是有代价的。我现在可以为每种格式创建一个`getSummaryLine()`方法，而不必测试标志。这两个类都不维护与其无关的字段或方法。

代价在于重复。每个类中的`getProducerName()`方法完全相同。每个构造函数都以相同的方式设置许多相同的属性。这是另一种你应该训练自己嗅出的难闻气味。

如果我需要`getProducer()`方法对每个类都有相同的行为，那么我对一个实现所做的任何更改都需要对另一个实现进行。如果不小心，这些类很快就会失去同步。

即使我有信心我可以保持复制，我的担忧并没有结束。我现在有两种类型而不是一种。

还记得`ShopProductWriter`课吗？它的`write()`方法被设计为使用单一类型:`ShopProduct`。我该如何修改它才能像以前一样工作？我可以从方法签名中删除类类型声明，但是我必须相信`write()`被传递了一个正确类型的对象。我可以在方法体中添加我自己的类型检查代码:

```php
// listing 03.56
class ShopProductWriter
{
    public function write($shopProduct): void
    {
        if (
            ! ($shopProduct instanceof CdProduct) &&
            ! ($shopProduct instanceof BookProduct)
        ) {
            die("wrong type supplied");
        }
        $str  = "{$shopProduct->title}: "
            . $shopProduct->getProducer()
            . " ({$shopProduct->price})\n";
        print $str;
    }
}

```

注意例子中的`instanceof`操作符；如果左边操作数中的对象属于右边操作数所代表的类型，则`instanceof`解析为`true`。

我又一次被迫增加了一层新的复杂性。我不仅要针对`write()`方法中的两种类型测试`$shopProduct`参数，还要相信每种类型都将继续支持与另一种类型相同的字段和方法。当我简单地要求单一类型时，一切都变得更加简洁，因为我可以使用类类型声明，因为我可以确信`ShopProduct`类支持特定的接口。

CD 和书籍这两个方面似乎不能很好地结合在一起，但又不能分开。我想把书籍和 CD 作为一个单一的类型，同时为每种格式提供一个单独的实现。我想在一个地方提供通用的功能以避免重复，但允许每种格式以不同的方式处理一些方法调用。我需要使用继承。

### 使用继承

构建继承树的第一步是找到基类中不匹配或者需要不同处理的元素。

我知道`getPlayLength()`和`getNumberOfPages()`方法不属于一起。我也知道我需要为`getSummaryLine()`方法创建不同的实现。

让我们将这些差异作为两个派生类的基础:

```php
// listing 03.57
class ShopProduct
{
    public $numPages;
    public $playLength;
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $numPages = 0,
        int $playLength = 0
    ) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
        $this->numPages          = $numPages;
        $this->playLength        = $playLength;
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        return $base;
    }
}

```

```php
// listing 03.58
class CdProduct extends ShopProduct
{
    public function getPlayLength(): int
    {
        return $this->playLength;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": playing time - {$this->playLength}";
        return $base;
    }
}

```

```php
// listing 03.59
class BookProduct extends ShopProduct
{
    public function getNumberOfPages(): int
    {
        return $this->numPages;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": page count - {$this->numPages}"; return $base;
    }
}

```

要创建子类，必须在类声明中使用`extends`关键字。在这个例子中，我创建了两个新的类，`BookProduct`和`CdProduct`。两者都扩展了`ShopProduct`类。

因为派生类不定义构造函数，所以当它们被实例化时，父类的构造函数被自动调用。子类继承对所有父类的公共和受保护方法的访问(尽管不是私有方法或属性)。这意味着您可以在从`CdProduct`类实例化的对象上调用`getProducer()`方法，即使`getProducer()`是在`ShopProduct`类中定义的:

```php
// listing 03.60
$product2 = new CdProduct(
    "Exile on Coldharbour Lane",
    "The",
    "Alabama 3",
    10.99,
    0,
    60.33
);
print "artist: {$product2->getProducer()}\n";

```

所以两个子类都继承了公共父类的行为。您可以将`BookProduct`对象视为`ShopProduct`对象。您可以将一个`BookProduct`或`CdProduct`对象传递给`ShopProductWriter`类的`write()`方法，所有这些都将按预期工作。

注意，`CdProduct`和`BookProduct`类都覆盖了`getSummaryLine()`方法，提供了它们自己的实现。派生类可以扩展但也可以改变其父类的功能。

这个方法的超类实现可能看起来是多余的，因为它被它的两个子类覆盖了。然而，它提供了新子类可能使用的基本功能。该方法的存在也为客户端代码提供了保证，即所有的`ShopProduct`对象都将提供一个`getSummaryLine()`方法。稍后，您将看到如何在根本不提供任何实现的情况下，在一个基类中做出这个承诺。每个子`ShopProduct`类继承其父类的属性。`BookProduct`和`CdProduct`都在各自版本的`getSummaryLine()`中访问`$title`属性。

起初，继承可能是一个很难理解的概念。通过定义一个扩展另一个类的类，可以确保从该类实例化的对象首先由子类的特征定义，然后由父类的特征定义。另一种思考方式是从搜索的角度。当我调用`$product2->getProducer()`时，在`CdProduct`类中找不到这样的方法，并且调用落入了`ShopProduct`中的默认实现。另一方面，当我调用`$product2->getSummaryLine()`时，在`CdProduct`中找到并调用`getSummaryLine()`方法。

属性访问也是如此。当我在`BookProduct`类的`getSummaryLine()`方法中访问`$title`时，在`BookProduct`类中找不到该属性。它是从父类`ShopProduct`中获得的。属性同样适用于两个子类，因此它属于超类。

然而，快速浏览一下`ShopProduct`构造函数，可以发现我仍然在管理基类中应该由其子类处理的数据。`BookProduct`类应该处理`$numPages`参数和属性，`CdProduct`类应该处理`$playLength`参数和属性。为了做到这一点，我将在每个子类中定义构造函数方法。

#### 构造函数和继承

当你在子类中定义一个构造函数时，你就有责任将所有的参数传递给父类。如果您做不到这一点，您可能会得到一个部分构造的对象。

要调用父类中的方法，必须首先找到引用类本身的方法:句柄。PHP 为此提供了关键字`parent`。

要在类而不是对象的上下文中引用一个方法，可以使用`::`而不是`->`:

```php
parent::__construct()

```

Note

我将在第 [4 章](04.html)中更详细地介绍范围解析操作符(`::`)。

前面的代码片段意味着“调用父类的`__construct()`方法。”这里，我修改了我的例子，使每个类只处理适合它的数据:

```php
// listing 03.61
class ShopProduct
{
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    public function __construct(
        $title,
        $firstName,
        $mainName,
        $price
    ) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )"; return $base;
    }
}

```

```php
// listing 03.62
class BookProduct extends ShopProduct
{
    public $numPages;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $numPages
    ) {
        parent:: __construct(
            $title,
            $firstName,
            $mainName,
            $price
        );
        $this->numPages = $numPages;
    }

    public function getNumberOfPages(): int
    {
        return $this->numPages;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( $this->producerMainName, ";
        $base .= "$this->producerFirstName )";
        $base .= ": page count - {$this->numPages}";
        return $base;
    }
}

```

```php
// listing 03.63
class CdProduct extends ShopProduct
{
    public $playLength;

    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        float $price,
        int $playLength
    ) {
        parent:: __construct(
            $title,
            $firstName,
            $mainName,
            $price
        );
        $this->playLength = $playLength;
    }

    public function getPlayLength(): int
    {
        return $this->playLength;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": playing time - {$this->playLength}";
        return $base;
    }
}

```

每个子类在设置自己的属性之前都会调用其父类的构造函数。基类现在只知道自己的数据。子类通常是其父类的专门化。作为一个经验法则，你应该避免给家长班级任何关于他们孩子的特殊知识。

Note

在 PHP 5 之前，构造函数采用封闭类的名字。新的统一构造函数使用名称`__construct()`。使用旧的语法，调用父构造函数会将您绑定到那个特定的类:`parent::ShopProduct();`。旧的构造函数语法在 PHP 7.0 中被弃用，在 PHP 8 中被完全删除。

#### 调用被覆盖的方法

关键字`parent`可以用于任何覆盖父类中对应方法的方法。当您重写一个方法时，您可能不希望删除父方法的功能，而是希望扩展它。您可以通过在当前对象的上下文中调用父类的方法来实现这一点。如果您再次查看`getSummaryLine()`方法的实现，您会发现它们复制了大量代码。最好使用而不是复制已经在`ShopProduct`类中开发的功能:

```php
// listing 03.64
// ShopProduct

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        return $base;
    }

```

```php
// listing 03.65
// BookProduct

    public function getSummaryLine(): string
    {
        $base  = parent::getSummaryLine();
        $base .= ": page count - $this->numPages";
        return $base;
    }

```

我在`ShopProduct`基类中为`getSummaryLine()`方法设置了核心功能。

我没有在`CdProduct`和`BookProduct`子类中重现这一点，而是在继续向摘要字符串添加更多数据之前简单地调用父方法。

既然您已经看到了继承的基础，我将根据完整的图片重新检查属性和方法的可见性。

### 公共、私有和受保护:管理对类的访问

至此，我已经声明了所有的属性`public`。如果在属性声明中使用旧的`var`关键字，那么公共访问是方法和属性的默认设置。

Note

`var`在 PHP 5 中被弃用，将来可能会从语言中完全删除。

正如我们所见，类中的元素可以声明为`public`、`private`或`protected`:

*   公共属性和方法可以从任何上下文中访问。

*   私有方法或属性只能从封闭类内部访问。甚至子类都没有权限。

*   受保护的方法或属性只能从封闭类或子类中访问。没有外部代码被授予访问权限。

那么这对我们有什么用呢？可见性关键字允许您仅公开客户端所需的类的那些方面。这为你的对象设置了一个清晰的界面。

通过防止客户端访问某些属性，访问控制还有助于防止代码中出现错误。例如，假设您希望允许`ShopProduct`对象支持折扣。您可以添加一个`$discount`属性和一个`setDiscount()`方法:

```php
// listing 03.66

// ShopProduct class

    public $discount = 0;

//...

    public function setDiscount(int $num): void
    {
        $this->discount = $num;
    }

```

有了设置折扣的机制，您可以创建一个考虑已经应用的折扣的`getPrice()`方法:

```php
// listing 03.67

public function getPrice(): int|float
{
    return ($this->price - $this->discount);
}

```

在这一点上，你有一个问题。您只想公开调整后的价格，但是客户端可以轻松地绕过`getPrice()`方法并访问`$price`属性:

```php
print "The price is {$product1->price}\n";

```

这将打印原始价格，而不是您希望显示的折扣调整价格。您可以通过将`$price`属性设为私有来立即停止这种情况。这将阻止直接访问，迫使客户端使用`getPrice()`方法。任何从`ShopProduct`类外部访问`$price`属性的尝试都将失败。就更广阔的世界而言，这种财产已不复存在。

将属性设置为`private`可能是一种过分热心的策略。子类不能访问`private`属性。想象一下，我们的业务规则规定只有书没有资格享受折扣。您可以覆盖`getPrice()`方法，使其返回`$price`属性，不应用折扣:

```php
// listing 03.68
// BookProduct

    public function getPrice(): int|float
    {
        return $this->price;
    }

```

由于私有的`$price`属性是在`ShopProduct`类中声明的，而不是在`BookProduct`类中声明的，所以在这里访问它的尝试将会失败。这个问题的解决方案是将`$price`变量声明为`protected`，从而授予对子类的访问权限。请记住，受保护的属性或方法不能从声明它的类层次结构外部访问。它只能从其原始类或原始类的子类中访问。

一般来说，宁可失之于隐私。首先将属性设为私有或受保护，仅在需要时放松限制。您的类中的许多(如果不是大多数)方法将是公共的，但是如果有疑问，请再次锁定它。为类中的其他方法提供本地功能的方法与类的用户无关。使其成为`private`或`protected`。

#### 存取方法

即使当客户端程序员需要使用您的类持有的值时，拒绝对属性的直接访问，而是提供传递所需值的方法，通常也是一个好主意。这样的方法被称为访问器或获取器和设置器。

您已经看到了访问器方法带来的一个好处。您可以使用访问器根据具体情况过滤属性值，如`getPrice()`方法所示。

还可以使用 setter 方法来强制属性类型。类型声明可用于约束方法参数，但属性可以包含任何类型的数据。还记得使用`ShopProduct`对象输出列表数据的`ShopProductWriter`类吗？我可以进一步开发它，让它一次写任意数量的`ShopProduct`对象:

```php
// listing 03.69
class ShopProductWriter
{
    public $products = [];

    public function addProduct(ShopProduct $shopProduct): void
    {
        $this->products[] = $shopProduct;
    }

    public function write(): void
    {
        $str =  "";
        foreach ($this->products as $shopProduct) {
            $str .= "{$shopProduct->title}: ";
            $str .= $shopProduct->getProducer();
            $str .= " ({$shopProduct->getPrice()})\n";
        }
        print $str;
    }
}

```

`ShopProductWriter`类现在更有用了。它可以保存许多`ShopProduct`对象，并一次性为它们写入数据。不过，我必须相信我的客户编码人员会尊重这个类的意图。尽管我已经提供了一个`addProduct()`方法，但我并没有阻止程序员直接操作`$products`属性。有人不仅可以向`$products`数组属性添加错误类型的对象，甚至可以覆盖整个数组并用原始值替换它。我可以通过将`$products`属性私有来防止这种情况:

```php
// listing 03.70

class ShopProductWriter
{
    private $products = [];

    //...

```

现在外部代码不可能破坏`$products`属性。所有访问都必须通过`addProduct()`方法，我在方法声明中使用的类类型声明确保只有`ShopProduct`对象可以添加到数组属性中。

### 类型化属性

因此，通过将方法签名中的类型声明与属性可见性声明相结合，可以控制类中的属性类型。下面是另一个例子:一个`Point`类，我在其中使用类型声明和属性可见性来管理属性类型:

```php
// listing 03.71
class Point
{
    private $x = 0;
    private $y = 0;

    public function setVals(int $x, int $y)
    {
        $this->x = $x;
        $this->y = $y;
    }

    public function getX(): int
    {
        return $this->x;
    }

    public function getY(): int
    {
        return $this->y;
    }
}

```

因为`$x`和`$y`属性是私有的，它们只能通过`setVals()`方法来设置——并且因为`setVals()`只接受整数值，所以你可以确保`$x`和`$y`总是包含整数。

当然，因为这些属性被设置为`private`，所以访问它们的唯一方式是通过 *getter* 或 *accessor* 方法。

在引入类型化属性的 PHP 7.4 版本之前，我们一直坚持使用这种固定属性类型的方法。这允许我们为我们的属性声明类型。下面是利用这一点的`Point`版本:

```php
// listing 03.72
class Point
{
    public int $x = 0;
    public int $y = 0;
}

```

我将属性`$x`和`$y`设为公共属性，并使用类型声明来约束它们的类型。正因为如此，如果我愿意，我可以选择在不牺牲控制的情况下摆脱`setVals()`方法。我也不再需要`getX()`和`getY()`方法。`Point`现在是一个非常简单的类，但是，即使它的两个属性都是公共的，它也向世界保证了它所保存的数据。

让我们尝试在其中一个属性上设置一个字符串:

```php
// listing 03.73
$point = new Point();
$point->x = "a";

```

PHP 不会让我们得逞的:

```php
TypeError: Cannot assign string to property popp\ch03\batch11\Point::$x of type int

```

Note

联合类型也可以在类型属性声明中使用。

#### 商店产品类别

让我们通过修改`ShopProduct`类及其子类来锁定访问控制，并加入一些我们已经介绍过的其他特性来结束本章:

```php
// listing 03.74
class ShopProduct
{
    private int|float $discount = 0;

    public function __construct(
        private string $title,
        private string $producerFirstName,
        private string $producerMainName,
        protected int|float $price
    ) {
    }

    public function getProducerFirstName(): string
    {
        return $this->producerFirstName;
    }

    public function getProducerMainName(): string
    {
        return $this->producerMainName;
    }

    public function setDiscount(int|float $num): void
    {
        $this->discount = $num;
    }

    public function getDiscount(): int
    {
        return $this->discount;
    }

    public function getTitle(): string
    {
        return $this->title;
    }

    public function getPrice(): int|float
    {
        return ($this->price - $this->discount);
    }

    public function getProducer(): string
    {
        return $this->producerFirstName . " "
            . $this->producerMainName;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        return $base;
    }
}

```

除了通过将属性的可见性设置为`private`(或者在`$discount`的情况下设置为`protected`来关闭对大多数属性的访问之外，我还重新引入了构造函数属性提升，这样我就可以将属性声明与构造函数签名结合起来。我还为`$discount`使用了属性类型声明——同时展示了 PHP 8 的新类型联合特性。我已经约束了`$discount`,这样它就可以被赋予*一个`int`或者`float`值。这个约束可能看起来是多余的，因为`$discount`被声明为`private`，而`setDiscount()`方法中的类型声明——另一个联合——将强制执行相同的条件。然而，为你的属性声明类型是一个很好的实践，一部分是因为这是一种强制的内联文档，另一部分是因为它可以防止我们在进一步开发`ShopProduct`的过程中意外地反复无常。*

```php
// listing 03.75
class CdProduct extends ShopProduct
{
    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        int|float $price,
        private int $playLength
    ) {
        parent:: __construct(
            $title,
            $firstName,
            $mainName,
            $price
        );
    }

    public function getPlayLength(): int
    {
        return $this->playLength;
    }

    public function getSummaryLine(): string
    {
        $base  = "{$this->title} ( {$this->producerMainName}, ";
        $base .= "{$this->producerFirstName} )";
        $base .= ": playing time - {$this->playLength}";
        return $base;
    }
}

```

同样，我在构造函数的签名中使用了属性提升。这一次，仅仅是为了一个理由:`$playLength`。因为我将剩余的构造函数参数传递给父类，所以我没有为它们设置可见性。我在构造函数体中使用它们。

```php
// listing 03.76
class BookProduct extends ShopProduct
{
    public function __construct(
        string $title,
        string $firstName,
        string $mainName,
        int|float $price,
        private int $numPages
    ) {
        parent:: construct(
            $title,
            $firstName,
            $mainName,
            $price
        );
    }

    public function getNumberOfPages(): int
    {
        return $this->numPages;
    }

    public function getSummaryLine(): string
    {
        $base  = parent::getSummaryLine();
        $base .= ": page count - $this->numPages";
        return $base;
    }

    public function getPrice(): int|float
    {
        return $this->price;
    }
}

```

因此，在这个版本的`ShopProduct`家族中，所有属性要么是`private`要么是`protected`。我添加了一些访问器方法来使事情变得更完整。

## 摘要

这一章涵盖了很多内容，从一个空的实现到一个全功能的继承层次结构。你接受了一些设计问题，特别是关于类型和继承。您看到了 PHP 对可见性的支持，并探索了它的一些用途。在下一章，我将向你展示 PHP 更多的面向对象的特性。