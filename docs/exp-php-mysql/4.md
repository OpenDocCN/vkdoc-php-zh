# 四、数据库

*。。。总的来说，数据库设计仍然主要是一种艺术努力，而不是科学努力。。。*

—C. J .日期，数据库上的*日期*

联合通常没有得到很好的优化。。。。如果可能，请改用 UNION ALL。

*—乔·塞尔科的 SQL 编程风格*

*永远不要指定全部。*

—C. J. Date， *SQL 和关系理论*

似乎数据库设计是一门艺术，而 SQL 技术则是见仁见智。在这一章中，我试图给你一些指导方针，帮助你掌握这门艺术。你也会得到我对 SQL 的看法。正如您将了解到的，我不像 Joe Celko 那样是 SQL 爱好者，也不像 Chris Date 那样是理论家。不过，我确实知道如何构建应用。

除了两个例外，*所有的应用都操纵现实* 的局部模型。例如，当您运行一个应用来平衡您的支票簿时，您实际上并没有改变您的支票簿，甚至没有改变银行对存款和已结清支票的想法。你只是在操作一个计算机化的支票登记簿，它是应用对你的财务状况的模型，准确与否。或者，当您到 Amazon 的网站寻找要购买的书时，您只看到每本书的模型，由封面、书名、作者姓名、价格、评论等图像表示。这本书本身——现实——就在亚马逊的一个仓库里。(电子书让我的例子有点偏离，我知道。)

这两个例外都与 PHP/MySQL 应用没有太大关系，它们是操纵现实世界的实时控制应用和操纵*非现实*模型的程序(例如，发生在某个虚构的遥远星球上的视频游戏)。前几天，我在用一个实时应用给我和女儿组装的乐高思维风暴机器人编程。我犯了一个错误，差点把它从桌子上弄下来，把放它进来的大盒子撞到了地板上。那真的发生了——不仅仅是我在电脑屏幕上看到的！但是 PHP 既不适合实时控制，也不适合视频游戏，所以我将讨论的唯一应用是那些操纵现实模型的应用。

如果模型值得保留，那么它需要存储在某个地方，通常是在运行应用的计算机的磁盘上。对于许多应用来说，比如一个电子表格或者一个字处理器，就像我现在正在使用的，一个文件就可以了。但是如果模型有任何结构，可以变得很大，并且可以被几个用户同时访问，那么最好使用数据库。

这就引出了数据库的定义:*数据库是现实的一个持久的局部模型，可以被应用操纵。*应用不是直接操作数据库，这很复杂，必须恰到好处地避免损坏数据，并且必须相当快，而是处理一个称为数据库管理系统(DBMS)的中间程序。在本书中，数据库管理系统是 MySQL。

这一章是关于如何设计一个适合应用需求的逻辑数据库，如何在 MySQL 中物理地实现它，以及如何用 SQL 连接它。在第五章中，你会发现如何从 PHP 连接到它的机制。

关系数据库

数据库可以使用几种方法来排列构成模型的数据，其中最流行的方法被称为关系型，因为数据保存在数据库理论中称为*关系*的表中。这种表格的每一列构成一个*属性*，或*字段*。每一行都是一个字段的集合，我们认为是一个*记录*。例如，employee 表中有雇员编号、姓氏、名字、电话号码等列，每个雇员对应一行(或一条记录)。类似地，可能有一个部门表，其中包含部门编号和名称等列，每个部门占一行。

在关系方法中，每个表都是完全独立的；没有从一行数据到另一行数据的指针，这在计算机程序内部使用的数据结构中是常见的，例如树和链表。但是，这并不意味着您不能将数据项存储在引用另一个表中的行的行中，例如存储在雇员行中的部门号，它指示雇员所在的部门。但是，在关系方法中，这样的引用不是指针——它只是两个表碰巧共有的数据项。

使用关系方法的 DBMS 称为关系 DBMS (RDBMS)，这就是 MySQL。PostgreSQL 也是如此，它是另一种流行的开源 DBMS，还有大家伙:SQL Server、Oracle 和 DB2。甚至最流行的嵌入式 DBMS SQLite 也是关系型的。

情况并非总是如此。当我在 20 世纪 70 年代开始接触数据库时，关系数据库非常新，效率低得令人绝望，难以使用，而且大多数是研究项目。IBM 的旗舰商业数据库 IMS 使用了层次化的方法，至少在贝尔实验室，数据库专家们迷恋于网络数据库，它比 IMS 强大得多。随着时间的推移，关系型方法取而代之，层次型和网络型方法现在只存在于历史书和大公司运营的遗留系统中。

对于非常频繁使用的数据库应用，如亚马逊、脸书和网飞，即使是运行在最快硬件上的最成熟的 RDBMS 也太慢，而且几乎不具备足够的可伸缩性来满足这些网站的需求。用第三章中的术语来说，他们已经尽可能扩大了*(更大的服务器)，任何进一步的增长都必须来自于向外扩展*(更多的服务器)，但是关系数据库很难跨服务器分布。他们的答案是放弃最常访问的数据的关系方法，使用更简单、更容易分发的方法。这些被称为 NoSQL 数据库，但我不会在本书中涉及它们。**

 **结构化查询语言

您可能已经知道，SQL 是用于定义、查询和修改关系数据库的语言。如果您想在 PHP 中做这些事情，您可以通过从 PHP 向数据库发送 SQL 语句来完成。我将在这里解释 SQL，可能你已经知道了，但是你可能喜欢阅读我的方法，因为它不同于 SQL 的典型解释方式。

一些历史

最初，关系数据库的发明者 E. F. Codd 提出了关系代数和关系演算来处理关系。Codd 工作过的 IBM 的其他研究人员提出了一种基于关系演算的语言，在较小程度上也基于关系代数，现在被称为 SQL。(发音是 S-Q-L，不是“续集”。)SQL 与关系数据库的联系如此紧密，以至于它们有时被称为 SQL 数据库，而且，在许多情况下，如 MySQL，这些字母甚至出现在名称中。

关于术语:SQL 所谓的*表*、*列*和*行*被称为“关系”(关系数据库由此得名)、“属性”和“元组”这种对应不准确；例如，关系必须有一个主键，必须对属性或元组(它们是集合)没有顺序，并且不能有重复的行。这些事情对表格来说都不是真的，尽管在设计和思考表格时把它们当成真的是个好主意。也就是说，不要假定列和行的顺序，并且总是有一个主键。在本书中，我主要使用 SQL 术语。从应用的角度来看，列就像一个*字段*，行就像一个*记录*，但是这些术语并不在 SQL 中使用。

我将在这里提供 SQL 的概念性概述，目的是解释它的重要思想，而不是它的所有子句、操作符和函数。我会推荐一些书和其他资源，你可以去那里了解所有的细节。

SQL 语句

SQL 有几种语句。

*   用于检索数据的`select`语句，有许多子条款和选项，
*   修改数据的语句:`insert`、`update`、`delete`，
*   用于定义数据的语句，所谓的数据定义语言(DDL) ，如`create table`和`alter table`，
*   用于控制访问的语句，如`grant`和`revoke`，称为数据控制语言(DCL) ，以及
*   其他杂项声明。

数据修改语句加上`select`被称为*数据操作语言* (DML)。所有的 SQL 语句都很容易学习和使用，除了`select`，这两个都很难。

Select 语句的作用

一个`select`语句定义了一个虚拟表。该声明有以下四个部分:

*   所需的列，可以是所有可用的列，也可以是您指定的特定列(也称为投影)，
*   要处理哪些表来为虚拟表提供数据，
*   要选择哪些行，以及
*   如何对行进行排序。

(在我的解释中，我将跳过与结果中的行分组相关的两个子句，`group by`和`having`。)

各部分按照我列出的顺序出现在一个`select`语句中，但这不是思考它们的最佳方式。图 4-1 是更好的图片，显示`select`更像一个工厂。

![9781430260073_Fig04-01.jpg](img/9781430260073_Fig04-01.jpg)

图 4-1 。选择语句工厂

正如图 4-1 所暗示的，连接(从漏斗中出来)产生的虚拟表中的任何列都可以用于过滤行(`where`子句)，但是只有选择的列(列在单词`select`之后)可以用在`order by`子句中。一些 SQL 实现允许在`order by`子句中使用表达式，但这不是一个好主意，因为无论结果如何排序，都应该显示为数据。

下面是一个`select`陈述的印刷外观，斜体字短语对应于四个部分。

```php
select column-specification from table-specification where conditional-specification order by order-specification

```

不需要的话可以省略`where`和`order by`子句。如果您不想指定列，而只想全部指定，那么您可以使用一个`*`来指定列。因此，键入到`mysql`命令中的最简单的`select`语句的例子是

```php
mysql> select * from department;
+---------------+------------+
| department_id | name       |
+---------------+------------+
|             1 | Accounting |
|             2 | Shipping   |
|             3 | Sales      |
+---------------+------------+
```

这里的结果与实际的表相同，但是如果我只指定了`name`列，那么它就是虚拟的，因为它是由`select factory`捏造的，并不真正存在于数据库中。

```php
mysql> select name from department;
+------------+
| name       |
+------------+
| Accounting |
| Shipping   |
| Sales      |
+------------+
```

这里有一个`where`子句，它在一个简单的正则表达式(模式)中使用了`like`操作符。

```php
mysql> select name from department where name like 's%';
+----------+
| name     |
+----------+
| Shipping |
| Sales    |
+----------+
```

同样，它是一个比计算它的基表更窄(更少的列)和更短(更少的行)的虚拟表。

添加一个`order by`子句，就可以对结果行进行排序。

```php
mysql> select name from department where name like 's%' order by name;
+----------+
| name     |
+----------+
| Sales    |
| Shipping |
+----------+
```

带有`order by`子句的`select`语句的结果是有序的，因此它显然不是数学集合，而所有关系都是。这就是 SQL 处理表而不是关系的一个原因。

连接表格

像`department`一样，`select`的表规范部分比仅仅是表名要复杂得多。假设我们也有一个`employee`表。

```php
mysql> select * from employee;
+-------------+---------------+----------+-------+
| employee_id | department_id | last     | first |
+-------------+---------------+----------+-------+
|           1 |             2 | Smith    | John  |
|           2 |             2 | Jones    | Mary  |
|           3 |             1 | Gonzalez | Ivan  |
|           4 |          NULL | Chu      | Nancy |
+-------------+---------------+----------+-------+
```

我们可以组合来自`department`和`employee`表的数据，这样它们就可以出现在一个虚拟表中，利用它们的公共列`department_id`。这称为连接，执行连接的 SQL 操作符称为`join`。如果不加入，关系数据库比文件集合好不了多少。

有不同类型的连接。我先从一个*交叉连接*开始，它是两个表的叉积；也就是说，生成的虚拟表包含两个表的所有列，第一个表的每一行都在第二个表的每一行旁边。如果第一个表有 15 列 100 行，第二个表有 20 列 600 行，结果将有 35 列(15 + 20)和 60，000 行(100 * 600)。清单 4-1 显示了一个小得多的结果，来自于`department`和`employee`表的交叉连接。

***清单 4-1*** 。部门和员工表的交叉连接

```php
mysql> select * from department cross join employee;
+---------------+------------+-------------+---------------+----------+-------+
| department_id | name       | employee_id | department_id | last     | first |
+---------------+------------+-------------+---------------+----------+-------+
|             1 | Accounting |           1 |             2 | Smith    | John  |
|             2 | Shipping   |           1 |             2 | Smith    | John  |
|             3 | Sales      |           1 |             2 | Smith    | John  |
|             1 | Accounting |           2 |             2 | Jones    | Mary  |
|             2 | Shipping   |           2 |             2 | Jones    | Mary  |
|             3 | Sales      |           2 |             2 | Jones    | Mary  |
|             1 | Accounting |           3 |             1 | Gonzalez | Ivan  |
|             2 | Shipping   |           3 |             1 | Gonzalez | Ivan  |
|             3 | Sales      |           3 |             1 | Gonzalez | Ivan  |
|             1 | Accounting |           4 |          NULL | Chu      | Nancy |
|             2 | Shipping   |           4 |          NULL | Chu      | Nancy |
|             3 | Sales      |           4 |          NULL | Chu      | Nancy |
+---------------+------------+-------------+---------------+----------+-------+
```

重要的是要认识到这种连接是无用的，甚至是误导的，因为盲目地将行配对是没有意义的。然而，请看第二行，其中两个`department_id`值(来自`department`和`employee`表)恰好是同一个数字(以粗体显示)。该行包含一个事实:John Smith 从事运输工作。事实上，所有这两列相等的行都是有用的，其他的行都是无用的。我们应该做的是一个*内部连接*，其中我们从每个表中指定一个在结果表中相等的列，导致其他列被跳过。即如下:

```php
mysql> select * from department inner join employee
    -> using (department_id);
+---------------+------------+-------------+----------+-------+
| department_id | name       | employee_id | last     | first |
+---------------+------------+-------------+----------+-------+
|             2 | Shipping   |           1 | Smith    | John  |
|             2 | Shipping   |           2 | Jones    | Mary  |
|             1 | Accounting |           3 | Gonzalez | Ivan  |
+---------------+------------+-------------+----------+-------+
```

(如果你有一个`using`或`on`从句，你可以跳过`inner`这个词，我会一直这样做。除了本章中的例子，我从不使用交叉连接。我将很快介绍一些其他有用的连接类型。)

现在我们有了一个事实信息表，至少在模型反映真实世界的范围内。记住，数据库只是模型。

我们在本书中做的每个连接，以及我在任何应用中做过的每个连接，都将是一个*等价连接*，这意味着连接列是相等的，尽管连接条件可以是一个更复杂的表达式(例如，使用像`<`这样的操作符)。

如果没有雇员和部门编号的混乱，更容易阅读的结果将是以下按姓氏排序的结果:

```php
mysql> select last, first, name  from department join employee
    -> using (department_id) order by last;
+----------+-------+------------+
| last     | first | name       |
+----------+-------+------------+
| Gonzalez | Ivan  | Accounting |
| Jones    | Mary  | Shipping   |
| Smith    | John  | Shipping   |
+----------+-------+------------+
```

回到清单 4-1 中的交叉连接，查看最后三行，可以看到 Nancy Chu 不在任何部门(可能她是新员工，或者退休员工，或者大老板)。但是在前面的两个内部连接示例中都没有看到这个事实，原因是任何包含空值的条件都不会为真。然而，可以通过指定一个*右外连接*来获得这些行，之所以这样叫是因为它保留了右边表中的所有行，即使左边表中没有匹配的行，在这种情况下会提供空值。单词“outer”可以省略，所以它也称为右连接。在这里。

```php
mysql> select last, first, name  from department
    -> right join employee using (department_id) order by last;
+----------+-------+------------+
| last     | first | name       |
+----------+-------+------------+
| Chu      | Nancy | NULL       |
| Gonzalez | Ivan  | Accounting |
| Jones    | Mary  | Shipping   |
| Smith    | John  | Shipping   |
+----------+-------+------------+
```

如果我们将`employee`表放在连接操作符的左边，将`department`表放在右边，我们将会做一个*左连接*，因为左边的表将会被保留。

有时会有两个以上的连接。假设部门被分组为分部，并且您有一个定义了两个分部的`division`表。

```php
mysql> select * from division;
+-------------+------------+
| division_id | name       |
+-------------+------------+
|           1 | Operations |
|           2 | Product    |
+-------------+------------+
```

为了扩展示例，我将 Jane Doe 添加到销售部门，并将一个`division_id`添加到`department`表。

```php
mysql> select * from employee;
+-------------+---------------+----------+-------+
| employee_id | department_id | last     | first |
+-------------+---------------+----------+-------+
|           1 |             2 | Smith    | John  |
|           2 |             2 | Jones    | Mary  |
|           3 |             1 | Gonzalez | Ivan  |
|           4 |          NULL | Chu      | Nancy |
|           5 |             3 | Doe      | Jane  |
+-------------+---------------+----------+-------+
mysql> select * from department;
+---------------+------------+-------------+
| department_id | name       | division_id |
+---------------+------------+-------------+
|             1 | Accounting |           1 |
|             2 | Shipping   |           1 |
|             3 | Sales      |           2 |
+---------------+------------+-------------+
```

为了获得一个显示每个人所在部门的虚拟表，我可以像以前一样连接`employee`和`department`表，然后将中间结果与`division`表连接，如清单 4-2 所示。`department`和`division`表都有一个`name`列，这很好，因为它对两者(组织名称)有相同的含义，但是我必须在 SQL 中用它们的表名限定它们。否则，我会得到一个错误，因为单独的`name`是不明确的。

***清单 4-2*** 。员工、部门和分部查询

```php
mysql> select last, first,
    -> department.name,
    -> division.name
    -> from employee
    -> join department using (department_id)
    -> join division using (division_id);
+----------+-------+------------+------------+
| last     | first | name       | name       |
+----------+-------+------------+------------+
| Smith    | John  | Shipping   | Operations |
| Jones    | Mary  | Shipping   | Operations |
| Gonzalez | Ivan  | Accounting | Operations |
| Doe      | Jane  | Sales      | Product    |
+----------+-------+------------+------------+
```

可以对该查询进行两项改进。

*   为了让 Nancy Chu 出现，她没有部门，我需要使用左连接(以前，因为我有`department`在先，所以它是右连接)。
*   我可以使用一个*列别名*来区分结果集中带有单词`as`的两个`name`列。注意限定列本身(例如，`department.name`)是不够的。

清单 4-3 展示了改进后的查询，其中我还添加了一个`order by`子句。

***清单 4-3*** 。改进的员工、部门和分部查询

```php
mysql> select last, first,
    -> department.name as 'Dept. Name',
    -> division.name as 'Div. Name'
    -> from employee
    -> left join department using (department_id)
    -> left join division using (division_id)
    -> order by last;
+----------+-------+------------+------------+
| last     | first | Dept. Name | Div. Name  |
+----------+-------+------------+------------+
| Chu      | Nancy | NULL       | NULL       |
| Doe      | Jane  | Sales      | Product    |
| Gonzalez | Ivan  | Accounting | Operations |
| Jones    | Mary  | Shipping   | Operations |
| Smith    | John  | Shipping   | Operations |
+----------+-------+------------+------------+
```

在 PHP/MySQL 程序中，我不会使用类似于`'Dept. Name'`的别名，因为查询的结果会发送给程序，而不是运行`mysql`命令的终端，别名将作为数组下标，而不是像清单 4-3 中那样作为人类可读的标题。像`$row['Dept. Name']`这样的 PHP 表达式很难编写。我改为使用别名`department_name`，它反映了出现在`select`语句中的限定名`department.name`，所以表达式变成了`$row['department_name']`。这样就很容易将数组下标与选择列关联起来。

为了加深你对这些 SQL 查询的理解，这里回顾一下清单 4-3 中的一个查询，按照图 4-1 所示的 select 语句工厂。

1.  `employee`、`department`和`division`表被组合成一个由所有列和行组成的虚拟表。
2.  `left join`操作符和它们的`using`子句用于将第 1 步中虚拟表中的行限制为那些`department_id`列和`division_id`列匹配或者这些列为空的行。
3.  我没有过滤步骤 2 中虚拟表的行，所以它们都保留了下来。
4.  步骤 3 中的虚拟表被缩小到只包含四列，其中两列被重命名。
5.  对步骤 4 中的虚拟表进行了排序。

MySQL 并不完全像我的工厂那样进行处理——它的效率要高得多——但这无关紧要，因为 SQL 是非过程化的。您指定了想要的结果集，但没有指定如何获得它。

顺便说一下，我刚刚介绍了 99%，甚至 100%的应用开发所需的所有连接:连接(内部连接)、左连接(左外部连接)和右连接(右外部连接)。我对表的看法是，我似乎从来不使用右连接。所以，如果你通读我写过的所有应用代码，你真正看到的只是 join 和 left join。(大约十年前，当我在 Oracle 为德克萨斯州的 Richardson 学区工作时，我做过一次完整的外部连接。现在想起来还会发麻。)

表达式和存储过程

与其他编程语言一样，SQL 包含大量的数字、字符串、日期和各种运算符和函数。表达式可以出现在 SQL 语句的几个地方，比如列列表(列值可以是计算的结果)、`where`子句和`update`语句。但是在 PHP/MySQL 程序中，你通常只会在`where`子句中使用它们。与用 SQL 计算列值相比，更简单的方法是将值返回给 PHP 程序并在那里进行任何计算。(这是一个共性；我相信你会发现偶尔的例外。)类似地，对于要放入行中的值，您需要在 PHP 中进行任何需要的计算，然后将答案传递给 SQL。因此，您会发现 SQL 书籍或课程告诉您的大部分内容都没有任何用处。在学习 SQL 时，我会专注于真正强大的连接和子查询(稍后解释)，而忽略传统的编程语言表达式。

SQL 的发展从最早的时候就没有停止过表达式。它现在包括一个完整的编程语言，所以你可以把程序放在数据库中，由数据库执行。对于 MySQL，这对于用于数据验证的触发器很重要，我将在本章的“约束”一节中介绍。否则，我不使用它们。

我想说的是，你对 SQL 的使用要保守。把它用在关系数据库最擅长的地方，用 PHP 完成大部分计算。

关于 SQL 的进一步阅读

这就是我现在要解释的关于 SQL 的全部内容，因为我完全跳过了我一直使用的`employee`、`department`和`division`表的来源；也就是说，数据库是如何设计的，这一点更重要。我将在本书的剩余部分解释我使用的 SQL。

我的书架上没有一本介绍 SQL 的书。用了这么久，都不记得什么时候怎么学的了。我的 SQL 书籍都是参考书或者进阶书。我发现很难找到可以推荐的辅导书。他们都有一个或更多的缺陷:他们只是给出例子而没有真正解释发生了什么(就像我对我的`select`语句工厂所做的)，他们有错误的信息，或者他们太复杂和先进而不能作为介绍。但是我确实找到了一本技术上准确、易于阅读，并且解释了原理和理论的书:Clare Churcher (Apress，2008)的《SQL 查询入门》,这是迄今为止我遇到的最好的 SQL 入门书籍。她只关注查询，而不是任何更新或 SQL 的其他部分，但这没关系，因为 99%的能力和复杂性都在查询中；其他陈述很简单。

一旦你读过丘奇的书，或者如果你已经知道 SQL，我会去找高级书籍，其中最好的是乔·塞尔科(摩根·考夫曼，2011 年)的《聪明人的 SQL》*,这本书真的很好，应该被任何打算专业使用 SQL 的人学习。(他的 *SQL 编程风格*(摩根·考夫曼，2005)也不错。)您可能想了解 MySQL 的 SQL 文档，您可以在 MySQL 网站`dev.mysql.com/doc`找到这些文档。*

如果你倾向于理论，C. J. Date (O'Reilly Media，2009)的《SQL 和关系理论》是一本很棒的书，绝对值得花时间去读。(事实证明，SQL 不是一种关系型语言，所谓的 RDBMS 也不是关系型数据库，你永远不需要使用空值。我是说理论上。)

实体关系建模

现在该说说表是从哪里来的了；也就是如何设计一个关系数据库。

ER 图 s

还记得我说过关系数据库中的表是独立的吗？我没有撒谎——他们在撒谎。但是，你不应该独立地思考 ??。您应该设计它们，以便可以使用`select`语句创建虚拟表，以有用的方式呈现数据。雇员和部门的例子非常简单，很容易理解如何设置这些表来实现连接。然而，在实践中，有几十个表，每个表可能有十列或更多列，很难预料如何用 SQL 处理它们。我们需要一种在比独立表更高的抽象层次上工作的设计方法，这就是*实体关系建模* (ER 建模)。

ER 建模并不是唯一的建模方法。许多程序员更喜欢使用面向对象的建模，使用统一建模语言(UML) 。如果您想这样做，那就去做吧，但是请记住，您不是要用面向对象的编程语言来实现这个模型，而是要用不支持继承的关系数据库来实现这个模型。正如我在“子类型”一节中解释的，有一种方法可以完成继承的一部分，但这不是一回事，所以不要过分使用深继承树。在这本书里，我不会涉及面向对象的数据库；与他们的继承情况不同。

ER 建模提供了比一组表格更具表达力的符号。在`department`和`employee`表中使用`department_id`列意味着包括零个雇员在内的许多雇员可以在一个部门中，并且一个雇员可以在一个部门中，但不是必须在一个部门中(如果`department_id`列包含 null)。那需要太多的思考。真想像图 4-2 中的图画一样说出来。

![9781430260073_Fig04-02.jpg](img/9781430260073_Fig04-02.jpg)

图 4-2 。许多员工可以在一个部门工作

图 4-2 是一个部门*排*和五个员工*排*的图。最好绘制*表*，这意味着所有雇员只有一个框，因为每个雇员只是雇员表中的一行。行尾的一些符号可以表示可能有许多雇员。其实我还在概念阶段的时候，连一个绘图应用都懒得做。我只是素描，如图图 4-3 。

![9781430260073_Fig04-03.jpg](img/9781430260073_Fig04-03.jpg)

图 4-3 。一个部门中许多员工的更简洁的绘图

像这样的图片有一个正式的名字:*实体关系图* (ER 图)。与关系表不同，我们可以在表之间画线。那些线条代表*关系*，圆圈或圆角矩形代表*实体*。这些图片中没有显示实体的*属性*，比如名称和部门编号。(ER 图中显示的“关系”和“关系”数据库之间没有联系。那是巧合。)

其思想是，根据实体、它们的属性以及它们之间的关系，将整个数据库设计成一个 ER 图，然后，在根据需求(尤其是用例)对其进行验证之后，将它转换成 RDBMS 的一组表。顺便说一下，这种翻译基本上是机械的。

每当我使用“实体”这个词时，我实际上是指一个*实体集*(或*实体类型*)。从技术上讲，实体是集合中的一个成员，例如特定的雇员或特定的部门。面向对象的程序员知道这是类和实例之间的区别。但是，我从来不用“实体”这个词来指代一个实例；为此，我总是使用“元组”、“行”或“记录”这样的词我使用“实体”一词来指代那些元组、行或记录所在的表或关系。

ER 设计工具和 MySQL 工作台

我不会在纸上勾画整个数据库。在我画出大部分草图之后，当然是所有困难的部分，我使用 er 设计工具重新绘制图表，添加属性(即命名列)，并让工具生成将创建数据库的 SQL 语句。如果我以后需要更改数据库，我会更改绘图并使数据库与之同步。您可以将 ER 设计工具想象成一个具有关系数据库智能的绘图程序。

我非正式地做建模，不关心关系的精确符号和盒子的正确形状(圆形或圆形，虚线或实线等)。).(你已经读到第四章了，现在你知道我几乎非正式地做了所有的设计；我只有在编码的时候才会紧张。)如果你想了解更多关于如何以正确的方式进行 ER 建模的知识，两本最好的书已经绝版，但仍然很容易从亚马逊的二手书店买到:*案例研究:理查德·巴克(Addison-Wesley，1990)的《实体关系建模》*，以及史蒂夫·霍伯曼(Technics Publications，LLC，2005)的《数据建模变得简单。也有更厚的书，比如 Graeme Simsion 和 Graham Witt (Morgan Kaufmann，2004)的*数据建模基础*，但是我没有发现所有额外的材料值得一读。

ER 设计工具曾经非常昂贵，但现在 MySQL 开发人员有一个免费的工具，叫做 MySQL Workbench，你可以从`dev.mysql.com/downloads/tools/workbench`开始为 Mac OS、Windows 或 Linux 下载。它不仅仅用于 ER 建模，它还处理数据库管理、备份和恢复、表定义和更改、数据编辑和查询。我认为这对任何 MySQL 开发都是必不可少的。

我将展示如何用 MySQL Workbench 构建`employee`、`department`和`division`表。首先，在初始屏幕上，我单击了“创建新的 EER 模型”按钮来启动一个新的模型，然后双击了“添加图表”按钮。这给了我一个空白的绘图画布，如图图 4-4 。

![9781430260073_Fig04-04.jpg](img/9781430260073_Fig04-04.jpg)

图 4-4 。空白画布

接下来我点击桌子图标，在图 4-4 中圈出，并点击画布放置一张桌子。我重复了两次，得到了如图图 4-5 所示的三个表格。

![9781430260073_Fig04-05.jpg](img/9781430260073_Fig04-05.jpg)

图 4-5 。三张桌子

然后我双击`table1`进入列编辑器，在那里我将表名改为`department`并输入列，如图图 4-6 所示。

![9781430260073_Fig04-06.jpg](img/9781430260073_Fig04-06.jpg)

图 4-6 。为部门表输入的列

我对`employee`和`division`表格做了同样的操作，并稍微重新排列了一下表格的位置，如图图 4-7 所示。

![9781430260073_Fig04-07.jpg](img/9781430260073_Fig04-07.jpg)

图 4-7 。完成的员工、部门和分部表

现在是有趣的部分。我点击图 4-7 中圈出的关系图标，从`employee`表的`department_id`列到`department`表的`department_id`列画一条线，在这两个表之间建立一对多的关系。(你从“多”的一面开始。)然后我从`department`表的`division_id`列到`division`表的`division_id`列做了同样的操作。这就完成了 ER 图，如图图 4-8 所示。

![9781430260073_Fig04-08.jpg](img/9781430260073_Fig04-08.jpg)

图 4-8 。完整的 ER 图

你觉得那很有趣吗？听听这个:MySQL Workbench 不仅仅是绘图——它知道如何将 ER 图转换为 SQL 来创建数据库，如果图发生变化，它甚至可以在以后同步它。为此，我从数据库菜单中选择同步模型，点击几个已经设置好默认值的对话框(MySQL Workbench 之前连接到我的开发平台数据库服务器)，然后进入 SQL 屏幕，如图 4-9 所示。

![9781430260073_Fig04-09.jpg](img/9781430260073_Fig04-09.jpg)

图 4-9 。生成 SQL 来创建表格

我单击了 Execute 按钮，表就创建好了。为了将一些测试数据输入到`division`表格中，我使用了 MySQL Workbench 的另一部分，表格数据编辑器，如图图 4-10 所示。我还将测试数据输入到`department`和`employee`表格中。

![9781430260073_Fig04-10.jpg](img/9781430260073_Fig04-10.jpg)

图 4-10 。输入到分部表中的数据

注意，我必须按顺序输入数据:`division`、`department`和`employee`。这是因为数据库强制的*外键约束*，要求输入到`department`表中的`division_id`必须已经存在于`division`表中。否则，将会有一个悬空的引用，一个不存在的`division_id`。这种强制是*参照完整性*的一个方面，这是极其重要的，因为它确保了 ER 图所定义的数据库模型保持一致。

正如我提到的，当我添加新的表或列，或者修改现有的列时，我可以使用 ER 图，然后将更改同步回数据库，就像我创建初始表一样。MySQL Workbench 不需要编写 SQL DDL 语句。你必须用 PHP 程序编写代码，但是我很少这样做。我的 PHP 应用只处理数据，从不修改数据模型。

ER 设计流程

在他 1976 年介绍实体关系模型的论文(“实体关系模型——走向数据的统一视图”)中，陈品山给出了设计数据库的四个步骤，这些步骤在今天仍然有意义。

1.  *“识别感兴趣的实体集和关系集”*
2.  *“识别关系集合中的语义信息，例如某个关系集合是否是[a] 1:n 映射”*
3.  *“定义值集和属性”*
4.  *“将数据组织成实体/关系关系并决定主键”*

这些是我在这里遵循的步骤，现在我已经展示了 MySQL Workbench 中的 ER 设计工具是如何工作的。

识别实体

使用 ER 设计工具听起来很容易，事实也的确如此。这是因为该工具不能帮助您解决困难的部分，即决定实体应该是什么。在图 4-8 的例子中，我很容易地画出了实体和它们的关系，因为我已经用一张纸画出了我想要的东西。我思考的时候你没在看。你会很无聊的。

一旦有了实体，事情就变得简单了，因为需求会告诉你关系是什么。例如，一个部门可以有多名员工吗？是的，当然，否则为什么有一个部门。员工可以不在任何部门吗？是的，听起来很合理。一名员工可以在多个部门工作吗？不，那是不允许的。一个部门可以没有员工吗？是的，他们就是这样开始的。所以我的结论是，部门和员工是一对多的关系，从员工端来说是可选的。

当你确定关系时，应该向你的团队成员和客户提出这样的问题。这是引出更多需求的好方法。(回想一下第二章中的内容，需求开始时范围很广，但是非常缺乏细节。)如果你问一群学校管理人员，一个学生是否可以入学，但没有课程，接着就是 45 分钟的讨论，不要感到惊讶。你会提出一些你从未想过要问的问题。

属性也是由需求决定的。您需要足够的属性来生成每个报告和屏幕，为每个业务逻辑算法提供数据输入，并保存所有转换后的数据。

但是需求不会告诉你实体应该是什么，尽管它们肯定会建议很多实体。如果是人事系统，需求中会提到部门和员工。他们会满足所有的要求。绩效评估、经理、工资等级、电话号码和其他数百种东西也是如此。这是显而易见的。但是，这些东西是实体还是属性呢？电话号码本身是员工的属性还是实体的属性？如果是属性，是部门的属性还是部门经理的属性？

无论这些问题如何回答，都有可能让系统运行并满足所有需求。既然如此，一套答案要比另一套好得多。一个好的数据库设计可以决定一个容易实现的应用和一个难以忍受的半工作应用。*数据库是应用设计中最重要的部分，而实体是数据库设计中最重要的部分。*

实体到底是什么？实体是有意义的事物，可能是抽象的，数据库需要存储关于它的信息，并且它与一个或多个其他实体相关。细说，

*   一个实体需要是重要的，对数据库所代表的模型来说是重要的。对于世界事务会议(CWA)来说，很明显，专门小组成员、专家小组、主持人和捐款是非常重要的。电子邮件地址和航班到达时间不是——它们只是用来完成重要的事情。换句话说，成千上万的与会者在那里聆听专家小组成员参与小组讨论。他们根本不在乎他们的航班什么时候到达。他们可能会在意自己的电子邮件地址，但不是出于正当理由，而且 99%的人都不在乎。在所有数百个潜在的实体中，只有少数几个需要任何艰难的思考来决定他们是否值得这一崇高的荣誉。
*   如果这个东西有属性，它可能是一个实体。电话号码、电子邮件地址和航班时间没有属性；它们本身就是单一的价值观。在数据库设计中，我们不关心将电话号码、电子邮件地址和时间分解成它们的组成部分。如果需要，应用可以这样做。事实上，在数据库术语中，这些被称为原子值。(回想一下物理学，甚至原子也可以分裂，但是元素周期表——延伸这个类比——有原子的盒子，而不是电子、质子和中子的盒子。)
*   如果有一系列的东西，它们可能是实体。例如，即使你不认为小组是重要的，一个小组成员通常是其中的五个或十个，这意味着他或她所在的小组的列表，这暗示了实体。正如我们将看到的，属性列表不是一个好主意。
*   稍微改变一下前面的观点，如果事物是一个集合(例如，部门和分部)，它可能是一个实体。
*   当你开始绘制关系时，你会发现一些实体需要被创建、合并或者调整。
*   好的数据库设计遵循*规范化*规则，你可能已经听说过(第一范式，第二范式，等等。).应用这些规则会强制将一个实体的某些属性移动到另一个必须创建的实体中。如果你的 ER 图是精心构建的，这种情况即使有，也会很少，但这是可能的。如果你试图设计没有 ER 图的表，由于标准化会有很多麻烦。

注意我所有的含糊其词，比如“可能”和“暗示”这是因为选择实体不是一成不变的。这涉及到一些艺术。

所以，记住这些要点，开始吧。需求摆在你面前，开始在一些纸上画代表实体的圆形或矩形。如果有助于你搞清楚事情的话，在一些属性上涂写，但是不要费心去得到所有的属性(忽略中间名、尊称、邮政信箱号码和其他琐事)。在人际关系中也画素描。如果你不喜欢乱涂乱画，你可以直接使用你的 ER 设计工具，但那可能会迫使你过早地进入太多的细节，而你仍然在为大图而奋斗。

经过几个小时的需求和你的草图，你会到达一个点，事情真正开始凝胶，er 模型开始有意义。您将愉快地发现，您理解您正在建模的组织或流程实际上是如何工作的。当您停止与同事谈论部门拥有员工，并开始谈论部门和员工表处于可选的一对多关系时，您将知道您已经到了。

然后是 ER 图表工具的时间。您必须更精确地确定关系，决定主键和外键，键入所有属性，并决定每个属性的物理数据类型。哦，别忘了，所有的表和属性都必须命名。那都是大量的工作，一小时又一小时。但是，主要是打字。*你已经得到了实体！*

识别关系及其语义信息

我已经解释并举例说明了一对多关系，这是目前最常见和最有用的一种关系。还有另外两个你会用到的。

*   *一对一*。这意味着一个表中的一行与另一个表中的一行相关。例如，一个面板(面板表的一行)可能有一个记录(记录表的一行)。一个面板不能有两个记录，一个记录只能属于一个面板。(这是 CWA 的政策。)如果面板不一定要有录音(可能面板还没发生)，那就是可选的一对一关系。否则，这是强制性的。
*   *多对多*。一个小组成员可以在几个小组中，每个小组有几个小组成员。它在任何一端都可以是可选的:某个专门小组成员可能还没有被安排到任何专门小组中，或者可能生病了而没有到达，不得不从所有专门小组中被删除，但仍然是(失踪的)专门小组成员。或者，一个专门小组可能只是凭空想象出来的，CWA 委员会还没有将任何成员列入其中。

有*认同*和*非认同*关系。如果一个表与另一个表有标识关系，则第一个表中的行如果不与第二个表相关就不能存在。例如，没有面板就不可能有录音(CWA 只记录面板)，所以一对一的关系也是可识别的(面板*识别*录音)。但是可以有一个没有部门的员工，所以这是不确定的。

在模型中表示标识关系的方法是将外键作为主键的一部分或全部。(我还没有正式介绍这两个术语，但是你可以理解我在这里所说的。)例如，如果面板表的主键是`panel_id`，我们可以使它也成为记录表的主键。这既创造了一对一的关系，又使其具有识别性。这是一对一的，因为每个主键都必须是唯一的，所以`panel_id`在记录表中只能出现一次。它是可识别的，因为每一行都必须有一个主键，除非有一个与之相关的面板，否则不可能有记录行。

如果是一对多的关系，因为一个面板可以有几个录音(可能一个音频一个视频)，那么`panel_id`只是录音主键的一部分；整个键可能是`(panel_id, type)`，其中类型是音频或视频。出于同样的原因，它仍然是可识别的:没有`panel_id`，因此没有面板，就没有主键，没有主键就没有行。

有趣的是，尽管多对多关系很重要，但是没有办法在关系数据库中直接表示它们。您必须创建另一个实体，有时称为交集(或关联)实体，您可以对其构建两个一对多关系。交集实体通常只有两列，每一列对应一个外键，这些外键引用表示多对多关系的表。

例如，图 4-11 显示了一个 MySQL 工作台画布，我在上面画了专门小组成员和小组表格。

![9781430260073_Fig04-11.jpg](img/9781430260073_Fig04-11.jpg)

图 4-11 。小组成员和小组成员表

现在，如果我单击图 4-11 中圈出的多对多关系图标，单击 panel 表一次，单击 panel 表一次，MySQL Workbench 不会绘制多对多关系。相反，它发明了一个新的实体，并为其构建了两个一对多的关系。老实说，图 4-12 中所示的`panel_has_panelist`表不是我画的，也不是我命名的，更不是我输入的栏目。这个工具自己完成了所有这些工作。

![9781430260073_Fig04-12.jpg](img/9781430260073_Fig04-12.jpg)

图 4-12 。表示多对多关系的综合交集表

如果你仔细观察图 4-12 中的图，你可以看到两个外键`panel_panel_id`和`panelist_panelist_id`一起构成了`panel_has_panelist`表的复合主键。这正是我想要的。我当然不想为那个表创建一个新的键，因为两个外键可以完成这项工作。

我不喜欢的是`panel_panel_id`这样的名字。简单的`panel_id`，准确地匹配`panel`表的主键名，要好得多。这不仅使外键引用的内容更清晰，而且使 SQL 连接更简单，因为您可以说

```php
select * from panelist join panel_has_panelist using (panelist_id)
join panel using (panel_id)
```

而不是罗嗦

```php
select * from panelist join panel_has_panelist
on panelist_id = panelist_panelist_id
join panel on panel_panel_id = panel_id
```

合成表的名称`panel_has_panelist`是可以的，但是我通常会为关系想一个更自然的名称，比如`participation`，或者干脆选择更简洁的`panel_panelist`。

交集表拥有附加属性是完全合理的。例如，假设小组成员有两个角色:演讲者和讨论者。这应该是`panel_has_panelist`表的一个属性，因为同一个小组成员在不同的小组中有不同的角色。添加了这个属性后，`panel_has_panelist`这个名字看起来更别扭。它现在是一个真正的实体，应该有一个像样的名字，比如`participation`。当你设计一个数据库时，当你练习你的艺术时，这些是你要考虑的事情。

定义属性

如果一个数据项不值得作为一个实体，或者如果设计考虑，如规范化或处理多对多关系的需要，不要强迫它成为一个实体，它是一个属性(即列)。当您筛选需求时，您将得到一个初始的属性列表，并随着开发的进行或在初始部署后添加新特性时引入更多的属性。添加属性很少影响数据库或应用的其余部分，除了数据库进行更改时的一些开销。除此之外，MySQL 和大多数其他数据库可以动态添加属性。他们可以更改名称和类型，也可以删除它们，但是这些更改可能会影响正在运行的应用。

就数据库而言，您希望保持属性的原子性。没错，使用 SQL 字符串函数，您可以解析电子邮件地址或分解日期的各个部分，但这对于编码来说有些麻烦，而且您知道您正在尝试拆分原子。“电子邮件地址”和“日期”是常用的名称，表明它们是单个单元，因此适合用于数据库列。另一方面，如果您有一个名为`name`的列，并输入像“Smith，John”或更糟的“John Smith”这样的值，它甚至看起来像是将两个字段打包成一个。实际上，有很多地方需要将名字和姓氏分开，当名字是单个字段时，试图解析名字会很麻烦，而且容易出错，尤其是当如此多的数据库在国际上使用时。本着组合比分解容易得多的原则，名字应该分解。没有人需要把电子邮件地址分开，所以它可以被认为是原子的。

如果这个属性有一个标准代码，试着使用它。美国邮政局为每个州和地区定义了代码，所以使用它们，而不是编造自己的代码或允许在表单中键入任何缩写。这同样适用于性别:一个名为 ISO/IEC 5218 的标准为未知、男性、女性和不适用(例如，公司)定义了代码 0、1、2 和 9，所以继续将列定义为整数并使用代码。(代码 0 避免了允许字段可为空，这具有其他优点；在“空值”一节中会有更多的介绍。)

我已经讨论了如何决定一个属性是否应该是一个实体，我会在“规范化”一节中详细介绍

决定主键

关系数据库不使用指针。相反，它们使用键来进行连接。此外，主键是标识要更新或删除的特定行的主要方式。

一个*键*是唯一标识表中一行的一列或多列。如果有不止一个，它们被称为候选键，你必须选择一个作为主键。大多数表只有一个键，所以别无选择。

每个关系都必须有一个主键，但是 SQL 表没有，MySQL 也是如此。但是，不要创建没有主键的表。在 MySQL Workbench 的 ER 图表部分，如果您有一个没有主键的表，您将不能用任何关系工具连接它。如果你想知道为什么当你点击鼠标时没有任何反应，这可能就是原因。我想这是一件好事，但是它确实迫使你在你的 er 设计中比你想要的更早地定义至少一个临时主键。

就关系理论而言，任何键都适合作为主键，即使它由几列(组合键)组成，并且它们是相当长的字符串。然而，实际上，组合键不方便用 SQL 编码(太多的输入)，长组合键对于数据库处理来说效率很低。较短的键更好。最方便有效的键是单个整数列，或者，如果没有类似的东西，也可以是相当短的单个列，比如州代码。

如果数据中根本没有键，实体可能设计得不好。或者，可能只是数据没有合适的内容。CWA 人的桌子就是这种情况。我们不会像音像店或保险公司那样给小组成员或捐赠者分配号码。有时两个小组成员有相同的名字，当人们改变他们的名字或纠正拼写错误时，名字经常会被修改。您不希望您的主键经常被编辑。因此，我创建了一个*代理键* :一个在插入一行时自动生成的整数，它保证是唯一的。它作为一个键工作得很好，但是它是实现的一个工件，在现实世界中没有任何意义。

我总是用表名加上后缀`_id`来命名我的代理键。不要使用普通的`id`，因为这样你就不能合理地使用相同的名称作为外键，因为`id`太不明确了，如果已经有一个列使用了这个名称，它甚至是不被允许的。对于像`department_id`这样的名字，我对外键使用相同的名字，除非包含该外键的表需要多个外键，可能一个外键用于雇员所在的部门，另一个外键用于他或她进行代码评审的部门。然后你需要去类似`reporting_department_id`和`code_review_department_id`的地方，或者`reporting_id`和`review_id`的地方。你的电话。

顺便说一句，千万不要在一个地方用“dept”而在另一个地方用“dept”。每样东西都应该只有一个名字，通常它不应该是一个缩写，除非它是一个广泛使用的标准名称。像“rprtng_dept_id”这样的词太难听了。

由实际数据形成的密钥称为自然密钥。其中一个应该永远是你的首选，但是如果没有可用的，或者有但是太笨拙，继续创建一个代理键。这在 MySQL 中很容易做到:只需将列设置为不可空且自动递增的整数。我已经在图 4-6 中展示了其中的一个，我在图 4-13 中放大了其中的一部分，这样你可以看得更清楚。请注意，PK(主键)、NN(不可为空)和 AI(自动递增)被选中。

![9781430260073_Fig04-13.jpg](img/9781430260073_Fig04-13.jpg)

图 4-13 。定义代理主键

代理键有三个主要缺点。

*   如果有另一个候选键，您可能需要对它指定一个惟一的约束，以确保不会输入重复的数据，因为代理键会使相同的行变得惟一。如果没有 unique 约束，一个重复的行将获得自己的代理键(记住，它是自动递增的)，所以数据库会很高兴地插入它，并且错误不会被检测到。缺点是这需要一个额外的索引，因为这是唯一性的实现方式。如果自然键是主键，那么只需要一个索引。
*   当我们开始编写更多的 PHP 代码时，您会看到，如果您插入一个带有代理键的行，您必须在单独的数据库调用中询问这个键是什么，因为它是在插入时计算的，这可能有点棘手。如果钥匙是天然的，你就不用问了。
*   有时代理键会导致额外的连接。

要了解为什么会有额外的连接，假设您有一个包含列`last`、`first`、`street`、`city`和`state`的`person`表。您还有一个包含列`city`、`state`、`population`和`mayor`的`city`表。图 4-14 显示了模型。

![9781430260073_Fig04-14.jpg](img/9781430260073_Fig04-14.jpg)

图 4-14 。与自然键的一对多关系

city 表的主键是`(city, state)`，所以 person 表中的那两列是外键。请注意，这些是自然键。现在，如果您想要的只是一个包含城市和州的人员目录，那么您可以非常简单地做到，因为您想要的所有列都在`person`表中。

```php
select * from person
```

然而，`(city, state)`正是我说过不喜欢的那种键:复合的、长的(例如，“马里兰州塞文河畔温彻斯特”)。因此，我将使 city 表的主键成为代理键`city_id`，并使用它作为`person`列中的单个外键，替换`city`和`state`列。(我们绝不会想把这些列留在那里，因为那样我们会在两个地方有城市和州，它们可能是不一致的。这就是正常化的意义所在。)

这些都没问题，但是现在要显示目录，我需要说

```php
select * from person
join city using (city_id)
```

它有一个我以前不需要的连接，还显示了`city_id`字段，对于不在数据库中的人来说，这完全没有意义。回到我真正需要做的地方

```php
select last, first, street, city, state from person
join city using (city_id)
```

我不是说你不应该使用代理键。我喜欢它们，使用它们的次数可能比大多数数据库设计人员都多。我是说他们不自由。

嗯，有时候他们是免费的。如果您希望目录列出人口和/或市长，不仅不会有额外的连接，因为在两种情况下都需要连接，而且使用代理键的连接会更有效，因为键要短得多。

没有什么是直截了当的。你必须继续思考。

外键

表中的外键是另一个表(也可能是同一个表)中的主键，它在两个表之间建立关系。外键的唯一目的是参与联接。事实上，如果有一个外键与 ER 图上画出的关系不对应，那么一定有问题。外键不仅仅是为了被聪明的 SQL 程序员发现。它们总是被故意放在那里。是的，您当然可以连接两个表，一个表中有高尔夫差点属性，另一个表中有部门编号，但是这样做是没有意义的，即使您这样做了，也不会使高尔夫差点成为外键。

重要的是外键不能引用不存在的主键。这将意味着，例如，一个专门小组成员在特定的小组上，但是该小组行已经被删除。如果 panelist 表中的外键是用外键约束声明的，这种删除可能会被数据库阻止，MySQL Workbench 会自动这样做。如果您仔细查看图 4-9 中雇员表的 SQL，您会看到以下内容:

```php
CONSTRAINT `fk_employee_department`
FOREIGN KEY (`department_id`)
REFERENCES `department` (`department_id`)
ON DELETE NO ACTION
ON UPDATE NO ACTION
```

这个约束意味着列`department_id`是对表`department`中同名列的引用，它引用的行不能被删除，除非首先删除该行，或者外键被更改，可能是 NULL。`on delete`子句表示没有动作，但是有一个选项是`cascade`，这意味着如果删除了`department`表中被引用的行，MySQL 数据库也应该自动删除该行(在`employee`表中被引用的行)。如果有另一个表的外键引用了 employee 表，并且也指定了`cascade`，这可能会导致另一个级联。等等。

我从不使用`cascade`，因为我害怕如果我没有完全考虑清楚事情以及数据库中的连锁反应可能导致的破坏。如果试图删除被引用的行，我宁愿得到错误消息。然后，我将把它翻译成用户能够理解的术语，比如“只要员工还在，就不能删除部门。”对我来说，这听起来安全多了；毕竟，用户可能试图错误地删除该部门，打算删除一个空部门。

正如我在讨论主键的命名时提到的，您总是希望外键具有相同的名称，除非在同一个表中有多个这样的外键，在这种情况下，它们必须具有不同的名称。无论如何，您都希望这样，因为外键显然服务于不同的目的。

正如我所说的，外键可以引用同一个表的主键。图 4-15 显示，还有两个不同角色的外键。建模的现实是经理和助理都是雇员，经理可以管理一个或多个雇员，助理可以协助一个或多个雇员(其中一些可能是经理)。MySQL Workbench 有点混淆了界限，但是如果您发挥想象力，您可以看到从主键(`employee_id`)到`manager`列的一对多关系，以及从主键到`assistant`列的类似但完全独立的关系。为了澄清这种关系，这在您看来可能是颠倒的:一个经理(“一”方)管理几个员工(“多”方)，每个人都有他或她的`manager`列引用该经理的主键。(不是*经理*用`manager`栏目；被管理的是*员工*。)助手同上。

![9781430260073_Fig04-15.jpg](img/9781430260073_Fig04-15.jpg)

图 4-15 。雇员表中的经理和助理外键列

在这里，我向雇员表添加了一些数据，以显示 Nancy Chu 是三名雇员的经理(他们的`manager`列中有她的`employee_id`):

```php
mysql> select * from employee;
+-------------+---------------+----------+-------+---------+-----------+
| employee_id | department_id | last     | first | manager | assistant |
+-------------+---------------+----------+-------+---------+-----------+
|           1 |             2 | Smith    | John  |       4 |      NULL |
|           2 |             2 | Jones    | Mary  |       4 |      NULL |
|           3 |             1 | Gonzalez | Ivan  |       4 |      NULL |
|           4 |          NULL | Chu      | Nancy |    NULL |         2 |
|           5 |             3 | Doe      | Jane  |    NULL |         2 |
+-------------+---------------+----------+-------+---------+-----------+
```

现在假设我想要一个显示每个雇员及其经理姓名的查询。在前面的例子中，当我有一个引用另一个表的外键时，我使用公共列名(例如，`department_id`)来连接这两个表。这一次外键(`manager`)引用了它所在的同一个表，所以我将把 employee 表与其自身连接起来。因为我将不得不两次提到`employee`表，所以我将使用别名来保持它们的正确性。第一次提到的是我要寻找其经理的员工，所以我将使用别名`e`。第二次提到的是经理，所以我用`m`。(使用什么别名完全由你决定，只要它们是不同的。)好了，准备好这个:

```php
mysql> select e.last, e.first,
    -> m.last as manager_last, m.first as manager_first
    -> from employee as e join employee as m
    -> on e.manager = m.employee_id;
+----------+-------+--------------+---------------+
| last     | first | manager_last | manager_first |
+----------+-------+--------------+---------------+
| Smith    | John  | Chu          | Nancy         |
| Jones    | Mary  | Chu          | Nancy         |
| Gonzalez | Ivan  | Chu          | Nancy         |
+----------+-------+--------------+---------------+
```

注意，我还在列列表中使用了别名，因为有两个姓和两个名。如果没有别名，MySQL 会抱怨不明确的列名。理解这个查询的方法是首先查看表表达式。它是`employee`表与其自身的连接，连接表达式根据主键测试`manager`外键。完成后，我们只想挑选出给出这两个名字的四列。

如果您仍然感到困惑，请回到我最初对内部连接的解释，当时我取了一个叉积，然后注意到一些行有匹配的键。这里你也可以产生一个叉积，如图图 4-16 所示。

![9781430260073_Fig04-16.jpg](img/9781430260073_Fig04-16.jpg)

图 4-16 。员工表与其自身的交叉连接

由第一个`employee`表(别名`e`)提供的前六列是这样标记的，来自第二个`employee`表(别名`m`)的后六列也是这样标记的。第一个表中的列`manager`是外键，第二个表中的列`employee_id`是与之匹配的主键。回想一下，交叉连接显示了许多毫无意义的行；它所做的只是将第一个表的每一行与第二个表的每一行配对。然而，有些行是有意义的，我已经画了阴影。他们是那些

```php
e.manager = m.employee_id
```

如果您回头看一下查询，这正是内部连接条件。内部连接意味着“取叉积，只给我满足条件的行。”现在我希望一个表和它本身的连接是清楚的。

在 CWA 应用中，一个人可以是一个人的住房主人、一个人的委员会联系人、一个配偶/伴侣、一个中间人，以及其他一些东西。很多人和其他人联系在一起！我的 SQL 充满了自连接，有时在同一个查询中有三四个。提示:如果您发现自己正在这样做，请明智地使用表别名来命名表，以便它们在查询的其余部分看起来像不同的表。

子类型

有时你有一个有点一般的实体，比如`person`，以及该实体的几个更具体的子类型，比如`moderator`、`donor`和`panelist`。一个拥有像`person`这样的类的面向对象程序员可能会对它进行子类化来创建三个子类型，这样它们就继承了超类的公共属性，比如说，名和姓。仅与子类型密切相关的属性，例如是否要求匿名，将进入子类(比如`donor`)。

但是关系数据库不是这样工作的。没有继承，也没有类似“子表”的东西。我们只有表，尽管如您所知，我们当然可以从一个表引用另一个表。有三种方法来处理子类型。

*   将所有子类型(`moderator`、`donor`和`panelist`)的所有属性放在`person`表中，不要使用不需要的属性。这种方法有时被称为*卷起*。
*   把所有的属性，普通的和只有仲裁者的，放在一个`moderator`表中，对`donor`和`panelist`表做同样的事情。保留`person`桌子，如果你需要它给任何不是主持人、捐赠者或小组成员的人；否则，扔掉它。这有时被称为*下降*。
*   仅将公共属性放入`person`表中，并为每个子类型创建一个单独的表(在本例中为`moderator`、`donor`和`panelist`表)。用一对一的标识关系将子类型行连接到其在`person`表中的行。你可以称这种方法为*多表*。

汇总方法很容易思考和使用，因为每个人，不管是什么角色，都是`person`表中的一行，这看起来很简单。有些列有默认值，甚至空值，但那又怎么样呢？即使不涉及子类型，这也并不罕见。

向下滚动的方法听起来很笨拙，因为人们分布在四张或者更多的桌子上。比方说，将所有这些表与`panel`表连接起来，以得出小组成员(主持人和小组成员)的列表，这需要额外的工作，并且 SQL 可能很快失控。(由子类型表的联合组成的视图会有所帮助。)

多表方法很简洁，应该会吸引面向对象的程序员。它确实需要一个 join 来获取版主、捐赠者或小组成员的所有属性，但这并不太坏，而且您可以创建一个隐藏 join 的视图，因此，实际上，您可以假装它是与查询相关联的。但是，根据 MySQL 对可更新视图非常严格的规则，这样的视图是不可更新的，因此任何插入、删除或更新都必须针对基表。这比只有一张宽大的卷起来的桌子要多得多。

这种简化的方法根本不能很好地处理一个人是两个或更多子类型的成员(例如，既是仲裁者又是施主)。两个不同表中的两行数据几乎相同，这可能不违反任何范式，但这非常糟糕。相比之下，多表方法很好地处理了这一点，但是您必须确保连接(或者封装它们的视图)是精心设计的。

如果这一切看起来太复杂了，我会说直接把所有东西都放在一个表中。我对 CWA 数据库这样做了，虽然这个表非常宽(超过 100 列)，但是使用它没有任何问题。所有这些未使用的列都浪费了空间，但这是一个非常小的应用，所以没关系。此外，我经常发现一个我认为只适用于捐赠者的属性(比如`do_not_call`)实际上也适用于版主和小组成员，在这种情况下，我除了开始使用一个已经准备好并在等待的专栏之外，什么都不需要做。如果我使用多表方法，我可能会希望将列移动到`person`表中，然后修改假设它在`donor`表中的代码。

也就是说，大多数看我的`person`表的人会说它格式不好，应该分开。不是因为他们熟悉应用和所有列的含义，而是因为超过 100 列的表很难闻。他们不会错的。

物理设计

首先，我将解释如何从 ER 图生成物理设计。然后我将讨论两个比逻辑设计更影响物理设计的复杂问题:空值和规范化。

从 ER 图到物理设计

我将列出将 ER 图转换为物理设计(表格、列等)的步骤。)，尽管 MySQL Workbench 将两者混合在一起，在绘制 ER 图时就完成了大部分物理设计。比如画一个实体其实就是画一个表，你至少要有一个主键才能画任何连接线(关系)，这就暴露了列编辑器。您可以决定推迟输入类型，直到 ER(逻辑)设计完成，您准备好进入物理设计，但是 MySQL Workbench 无论如何都会坚持提供默认类型。

尽管如此，即使 ER 设计工具在进行过程中创建了物理设计，解释一下如何从纸上绘制的纯 ER 图生成物理设计也是有用的。这些步骤不会是一个惊喜。我将简洁地陈述它们，没有例子；大多数复杂性(例如，代理键、外键和唯一约束)已经解释过了。

1.  每个实体变成一个表。
2.  每个属性成为一列。
3.  对于多对多关系，构建一个新的实体来表示该关系，并将该关系重绘为两个一对多关系。(正如我所展示的，MySQL Workbench 坚持马上做这一步。)
4.  如果您还没有为每个实体确定一个主键，那么请这样做。如果有必要，或者看起来合适的话，使用代理键。对于在步骤 3 中添加的任何实体，在步骤 5 之后决定主键，因为您将使用两个外键。
5.  对于每个一对多关系，向“多”方添加一个外键，该外键引用“一”方的主键。除非这样做会导致重复的列名，否则将外键列命名为与其引用的主键相同。
6.  为每个外键添加一个外键约束。
7.  如果在第 4 步中引入了任何代理主键，则为其他候选键添加一个唯一约束，以避免除代理主键之外都相同的行。
8.  检查除可选外键之外的每一列，看它是否可以声明为 not null，因为缺省的可为 null 是危险的。(参见“空值”一节)
9.  检查每一张表，确保它处于第一、第二和第三范式。如有必要，重复步骤 1 到 8，以纠正任何规范化违规，除了您认为正常的第一范式违规。(参见“规范化”一节，我在那里解释了这个异常。)
10.  添加检查约束，以确保所有数据都符合模型，并尽可能符合实际情况。(更多信息在“约束”一节中。))
11.  根据需要添加索引以加快处理速度。所有主键和唯一约束都将被索引，但您可能需要更多的主键和唯一约束。最好推迟这一步，直到开发完应用并用真实数据加载数据库(可能来自转换)，否则很难知道要索引什么。(索引除了提高性能之外，没有任何其他用途。)

空值

不幸的是，默认情况下，每个非键列都允许用 NULL 代替值，如果不插入值，NULL 也是默认的，所以大多数数据库到处都是 NULL。这是一个问题，因为在条件表达式中使用时它们的行为很奇怪:任何包含 NULL 的条件表达式都会产生未知值，这是第三个真值，还有 TRUE 和 FALSE。也就是说，SQL 中的条件是三值的，而不是像大多数编程语言那样是二值的。

当我说“任何条件表达式”时，我指的是*任何*。甚至表情

```php
NULL = NULL
```

不是真的；未知。所有其他条件操作符也是如此。

一个常见的错误是假设 NULL 与 FALSE 相同，这在其他编程语言中很常见。但不是在 SQL 中，如下例所示:

```php
select * from employee where salary < 5000
```

结果不会包括`salary`列为空的任何人(可能工资还没有设置，或者员工是志愿者，或者输入员工数据的人不知道工资，打算以后再输入)。无论 NULL 的原因是什么，都不会包含该员工，因为`NULL < 5000`不为真，这是包含在结果中的条件。

当我在 CWA 数据库工作时，那条空蛇咬了我。我有一些 BOOL 列来表示一个人是版主、捐赠者还是小组成员，并且我没有禁止空值。如果条目表单上没有选中这些复选框，我的 PHP 代码会将值默认为 NULL。我编写了一个`select`语句来查找不是版主、捐赠者或参与者的人，如下:

```php
select * from person where
not moderator and not donor and not panelist
```

结果集只有几行，这些行中的复选框已经被选中，然后又被取消选中，在这种情况下，我的程序确实为每一列输入了 0。但是从来没有任何值的列是空的，所以很多行都丢失了，包括所有的委员会成员、制作人和职员。

有几种方法可以解决这个问题。首先，可以修复 SQL。最直接的方法是使用`coalesce`函数，它返回第一个非空的参数。在这里，我使用它实际上使 NULL 的行为类似于 FALSE:

```php
mysql> select * from person where
    -> not coalesce(moderator, false) and
    -> not coalesce(donor, false) and
    -> not coalesce(panelist, false);
+-----------+-------+-----------+-------+----------+
| person_id | last  | moderator | donor | panelist |
+-----------+-------+-----------+-------+----------+
|         1 | Smith |      NULL |  NULL |     NULL |
|         2 | Jones |         0 |     0 |        0 |
|         3 | Doe   |      NULL |  NULL |     NULL |
+-----------+-------+-----------+-------+----------+
```

这个结果是正确的:Smith、Jones 和 Doe 是三个不是主持人、捐赠者或小组成员的人。

但是最好通过使这些列不可为空来修复数据库，这是我在“从 er 图到物理设计”一节的步骤 8 中应该做的 NULL 表示“没有值”`moderator`列可以解释为“已知是一个版主”，在这种情况下，如果不知道这个人是否是版主，那么 FALSE 是可以的。也就是说，代替`create table`语句的是

```php
moderator bool default null,
```

它应该说

```php
moderator bool default 0 not null,
```

考虑 NULL 对于像`middle_name`这样的列可能意味着的所有事情:值未知、值尚未输入、值不适用或者没有中间名。实际上，如果类型是`varchar`，长度为零的字符串就和 NULL 一样好，没有 NULL 的任何问题。

数字列可能需要空值，因为`0`不是一个好的占位符(它通常是一个有效值)，类似于`-1`的东西会造成混乱。

一个绝对需要 NULL 的地方是外键列为空，因为该行没有这种关系(例如，雇员不在任何部门)。由于外键约束，您不能输入像零这样的特殊值。数据库将只允许 NULL 或与约束中给定的主键匹配的值。

除了这些情况之外，空值是不需要的，并且应该被消除。不能将它设置为缺省值是很糟糕的，但是对数据库运行一个查询来报告所有可为 all 的列也差不多。我将向您展示如何做到这一点，主要是因为它给了我一个讨论`information_schema`和子查询的借口。

每个 MySQL 安装(从版本 5 开始)的一部分`information_schema`，保存每个表的结构数据。它在 MySQL 网站上有完整的文档，但是通过使用 MySQL Workbench 浏览，您可以很容易地找到它。您将很快看到`columns`表，它保存了每一列的数据。特别是，`columns`表的`is_nullable`列告诉我们哪些列可以为空，如清单 4-4 所示。

***清单 4-4*** 。mydb 架构中所有可空的列

```php
mysql> select table_name, column_name from columns
    -> where is_nullable = 'YES' and table_schema = 'mydb';
+------------+---------------+
| table_name | column_name   |
+------------+---------------+
| employee   | department_id |
| employee   | first         |
| employee   | manager       |
| employee   | assistant     |
| person     | first         |
| person     | street        |
| person     | city          |
| person     | state         |
| person     | moderator     |
| person     | donor         |
| person     | panelist      |
+------------+---------------+
```

为了改进查询，可以跳过外键但需要更复杂查询的列。作为外键的列可以通过连接`table_constraints`和`key_column`表来显示，如清单 4-5 所示。

***清单 4-5*** 。mydb 模式中的外键列

```php
mysql> select u.table_name, u.column_name
    -> from table_constraints
    -> join key_column_usage as u using(constraint_name)
    -> where u.table_schema = 'mydb' and
    -> constraint_type = 'foreign key';
+--------------------+---------------+
| table_name         | column_name   |
+--------------------+---------------+
| department         | division_id   |
| employee           | manager       |
| employee           | assistant     |
| employee           | department_id |
| panel_has_panelist | panel_id      |
| panel_has_panelist | panelist_id   |
| person             | city          |
| person             | state         |
+--------------------+---------------+
```

现在，通过使外键查询成为可空列查询的*相关子查询*，可以将两个查询组合起来，如清单 4-6 所示，其中相关名称用粗体显示。

***清单 4-6*** 。mydb 模式中非外键的可空列

```php
mysql> select table_name, column_name from columns as col
    -> where is_nullable = 'YES' and table_schema = 'mydb'
    -> and column_name not in (
    ->     select u.column_name
    ->     from table_constraints
    ->     join key_column_usage as u using(constraint_name)
    ->     where u.table_schema = 'mydb' and
    ->     u.table_name = col .table_name and
    ->     constraint_type = 'foreign key'
    -> );
+------------+-------------+
| table_name | column_name |
+------------+-------------+
| employee   | first       |
| person     | first       |
| person     | street      |
| person     | moderator   |
| person     | donor       |
| person     | panelist    |
+------------+-------------+
```

事情是这样的:我只想要外部查询中不在外键集中的列名(在`columns`表上)。该集合由内部查询在`in`函数中动态生成。它与清单 4-5 中的查询几乎相同，除了只包含列名，不包含表名，并且在`where`子句中添加了另一个条件，以根据`columns`表中的表名测试`key_column_usage`表中的表名。

```php
u.table_name = col .table_name
```

`columns`表不直接参与内部查询(它不是连接的表之一)，但是它的别名`col`仍然可以在条件中使用。这就是为什么它被称为相关子查询:从外部查询中引用别名将两个查询相关联。

我之前建议你阅读 Clare Churcher (Apress，2008)的*开始 SQL 查询*。当你阅读她对嵌套查询的看法时，你可能已经有了清单 4-6 中所示的查询。大多数其他 SQL 入门书籍也讨论了它们。(值得学习一下。难道您不想和您的朋友一起喝一杯，并以某种方式参与到您那天下午编写了相关子查询的对话中吗？我知道我会的。)

但是我已经偏离了本节的要点，即找出不是外键的可空列，并尽可能使它们成为`not null`。对于清单 4-6 中的六个可空列，这很容易做到。我已经说过`moderator`、`donor`和`panelist`应该是`not null`，因为假和空一样有效。这同样适用于`varchar`列、两个`first`列和`street`列:空字符串也可以。

从数据库中删除可空列，你会更开心。

归一化

每本关于数据库的书都至少列出了前三种范式，有些列出了一种称为 Boyce-Codd 范式的无编号范式，有些提到了第五种范式，至少有一本提到了新的第六种范式。如果您遵循这些规则，所有这些规则将使您的数据库设计更好。

我在这里做的是给出我自己的第一范式的版本(你会明白为什么我不确定)。我一起讨论第二范式和第三范式，因为它们在意义上非常接近，我甚至通过解释第四范式超越了大多数数据库书籍。

其他的我就不多说了，但是如果你想的话，你可以看看。你的第一选择可能是一篇很容易在网上找到的论文，威廉·肯特的《关系数据库理论中五种范式的简单指南》。它既易于阅读，又数学精确。

第一范式(1NF)

与其他范式不同，1NF 不是为了改进设计，而是关于关系数据库的一般陈述:一列中的所有值必须包含原子值，而不是例如数组、集合或关系。或者，换句话说，所有行必须有相同的列数。

既然创建一个不在 1NF 中的表是不可能的，为什么它被谈论得这么多？这是因为自从 1NF 被引入以来，它已经发展了几十年，意思是数学上的，如果不是实际上的，一个不同的问题:*表格的列不应该形成一个水平列表。*要了解为什么会这样，请查看这个表，从技术上讲，它在 1NF 中。

```php
+---------------+------------+-----------+-----------+-----------+
| department_id | name       | employee1 | employee2 | employee3 |
+---------------+------------+-----------+-----------+-----------+
|             1 | Accounting |         1 |         4 |         5 |
|             2 | Shipping   |         2 |      NULL |      NULL |
|             3 | Sales      |         3 |         6 |      NULL |
+---------------+------------+-----------+-----------+-----------+
```

很明显，这里的想法是通过在每一行中列出员工来表示部门中的员工，但是这样做的问题是显而易见的。

*   只允许三名员工。由于可能没有固定的上限，随着部门的扩大，必须添加更多的列。当添加更多数据时修改模式是一个糟糕的主意。
*   在 SQL 中处理雇员是很尴尬的，因为必须明确地提到列(现在是三列，但是还在增加)。例如，对于每个雇员列，您必须将 department 表与 employee 表连接一次，以得到一个非常宽、非常混乱的结果表，其中包含所有的雇员数据。

如果您仔细构建了您的 ER 模型，就永远不会创建这样的表，因为您会看到 employee 是一个实体，并且您会在部门和雇员之间建立一对多的关系，如我在前面的示例中所示。即使您最终得到了一个包含多个雇员列的表，您也会很快发现这有多尴尬并解决它。所以 1NF 不是你应该担心的事情。当你不跟随它的时候你会知道它。

或者，也许不是。下面这张表呢:

```php
+-------+-------+--------------+--------------+--------------+
| last  | first | home phone   | work phone   | mobile phone |
+-------+-------+--------------+--------------+--------------+
| Smith | John  | 303-111-2222 | 303-888-4321 | 303-987-1234 |
+-------+-------+--------------+--------------+--------------+
| Jones | Mary  | 303-456-9876 |         NULL |         NULL |
+-------+-------+--------------+--------------+--------------+
| Doe   | Joe   | 303-098-3456 | 720-234-1122 |         NULL |
+-------+-------+--------------+--------------+--------------+
```

这三个电话号码组成一个列表吗？看起来是这样，但不同的是，这些数字有不同的作用(家庭、工作、移动)，而以前员工列表只是一个列表，哪个员工是哪个并不重要。但是，不同的角色不会妨碍将电话号码移动到它们自己的表中，因为该表中的一列可以用于该角色。

将电话号码移动到它们自己的表中使得`phone`成为一个实体，并且在需要电话号码的任何时候都需要加入。此外，这样的连接可能会为每个人创建多达三个结果集行，每个数字一行，这在应用中处理起来比每个人一行要复杂得多，而现在表中只有一行。

消除电话号码列表值得吗？没有放之四海而皆准的答案，但在大多数情况下我不会这么做。如果列表中的元素数量很少(在本例中只有三个)并且稳定(不太可能超过三个)，并且电话号码不参与连接或`where`子句，那么我很想让电话号码保持原样。但是如果你认为他们应该在他们自己的桌子上，你没有错。

只是延伸一下这个论点，尽可能的烦人，前两栏呢？他们不也是名单吗？我没有在这里展示它，但是中间名的列是很常见的。然而，几乎没有设计师会认为名字的三列是一个需要解决的问题。这是真的，尽管列名(名字、中间名、姓氏)比电话列更像是一个列表。正如 Chris Date 在本章开头的引言中所说，数据库设计“主要是一种艺术努力”

明确一点:如果您对 1NF 的理解是它意味着“没有重复列”，那么您将是大多数人。这不是最初的提法，但这就是它的含义。

第二和第三范式(2NF 和 3NF)

这两条规则几乎一样，所以我将它们放在一起讨论。他们所说的本质上是这样的:*所有的列都应该依赖于整个主键，而不是其他。*否则，表格可能包含冗余数据，这可能导致不一致。与 1NF 不同，2NF 和 3NF 不是您应该违反的规则。

以下表为例:

```php
+----------+-------+-------------+----------+
| city     | state | mayor       | governor |
+----------+-------+-------------+----------+
| Akron    | OH    | Plusquellic | Kasich   |
| Columbus | IN    | Brown       | Pence    |
| Columbus | OH    | Coleman     | Kasich   |
+----------+-------+-------------+----------+
```

主键是`(city, state)`。调控器的名称只取决于州，而州只是键的一部分，所以表不在 2NF 中。事实上，一项快速研究表明了问题所在:卡西奇是俄亥俄州州长的事实被重复了一遍。如果选举了新的调控器，有两行需要更新以保持表的一致性。如果不一致，获得显示谁是调控者的结果将取决于查询是如何形成的，一些查询甚至可能同时产生两个不同的答案。不好。

这里还有另一个问题:如果我们删除哥伦布所在的行，比如说，因为我们关闭了那里的分支机构，我们还会丢失 Pence 是 IN 的州长这一事实。

要修复这些问题，必须将`governor`列移动到一个表中，其中只有`state`是主键。因为主键只能出现一次，所以在那个表中 Kasich 只能出现一次。

这两种范式放在一起讨论，因为 3NF 几乎是相同的，除了它是关于一个非键列，如在这个表中，显示了服务于一个城市的主要航空公司以及预订号码(不要打电话，这些号码是真实的)。

```php
+----------+-------+---------+--------------+
| city     | state | airline | phone        |
+----------+-------+---------+--------------+
| Akron    | OH    | United  | 800-864-8331 |
| Columbus | IN    | Delta   | 800-221-1212 |
| Columbus | OH    | United  | 800-864-8331 |
+----------+-------+---------+--------------+
```

这个问题类似于前面的问题:电话号码取决于航空公司，而不是主键，主键也是`(city, state)`。如果数量发生变化，有两个地方需要更新。如果哥伦布去了，达美航空的电话号码也没了。

我从来不会去区分 2NF 和 3NF。实际上，由于我在一个表中几乎从来没有一个带有其他属性的组合键，所以违反 2NF 在我的数据库中不是问题。

这里有一个避免 2NF/3NF 麻烦的更简单的方法:*确保每个事实只被表示一次。*

顺便说一下，解决航空公司问题的方法是将电话号码移到`airline`表中，如果还没有这个表，就创建这个表。回想一下，我之前说过选择实体是数据库设计最重要的方面。一旦有了正确的实体，确定将每个事实(即每列)放在哪里就很容易了:它会进入与它相关的实体的表中。

第四范式(4NF)

第四范式认为一个表不应该包含两个或更多独立的多值事实。和往常一样，最好用一个例子来说明。假设您有一个主键为`employee_id`的`employee`表，并且您想要记录每个员工使用过的所有操作系统以及他或她知道什么编程语言。由于一个员工可能有不止一个操作系统和不止一种语言，这些事实是*多值的*。此外，操作系统和语言是独立于 ?? 的。所以 4NF 说，你不能把操作系统和语言放在同一个表中。真的吗？这看起来确实是个好主意，有一个像清单 4-7 中所示的表格。

***清单 4-7*** 。具有两个多值独立列的技能表

```php
+-------------+---------+----------+
| employee_id | os      | language |
+-------------+---------+----------+
|           1 | Linux   | SQL      |
|           1 | MacOS   | PHP      |
|           1 | Windows |          |
|           2 | Linux   | C++      |
|           2 | Windows | Java     |
|           2 |         | Lua      |
|           2 |         | SQL      |
|           2 |         | PHP      |
|           2 |         | Python   |
+-------------+---------+----------+
```

注意`os`和`language`列是独立的；不是说员工 1 懂 Linux 上的 SQL，只是说他(她)懂 SQL，用过 Linux。这两个数据项在同一行上只是为了填充表格。主键是`(employee_id, os, language)`，按照要求，它在各行中是唯一的。

那么，有什么问题吗？而是有很多方法可以把同样的事实摆在桌面上。例如，清单 4-8 中的变体非常不同，但包含完全相同的冗余信息。

***清单 4-8*** 。具有两个多值独立列的技能表

```php
+-------------+---------+----------+
| employee_id | os      | language |
+-------------+---------+----------+
|           1 | Linux   | SQL      |
|           1 | MacOS   | PHP      |
|           1 | Windows | SQL      |
|           2 |         | C++      |
|           2 | Windows | SQL      |
|           2 | Linux   | Java     |
|           2 |         | Lua      |
|           2 |         | SQL      |
|           2 | Windows | PHP      |
|           2 | Windows | Python   |
+-------------+---------+----------+
```

正如《精神病黑仔》中的“会说话的人”所唱的:“说一次，为什么要说第二次？”

在清单 4-8 中，与清单 4-7 相比，OS 与语言的巧合配对不同，有些 OS 重复，有些语言重复。因为所有列都是主键的一部分，并且没有水平列表，所以表的格式是 1NF、2NF 和 3NF。然而，清单 4-8 有冗余。如果雇员 2 忘记了他或她的所有 SQL，则有两行需要更新。如果他或她开始使用 Mac OS，不清楚是将该事实放入现有行，还是放入两个现有行，或者添加一个新行。所有这些都是有效的，表仍然在 1NF、2NF 和 3NF 中。更糟糕的是，不完全熟悉这个表格的人可能会认为它说雇员 2 懂 Windows 上的 PHP，但不懂 Linux。或者他或她知道 Windows 上的 SQL 或者根本不知道 OS 上的 SQL，但是不知道 Linux 上的 SQL，这是愚蠢的。

简而言之，表中充满了怪异的问题，不能认为是良构的。由于多值列是独立的，它们需要在自己的表中，一个叫做`os`，一个叫做`language`，如清单 4-9 所示。

***清单 4-9*** 。独立表中的多值独立列

```php
+-------------+---------+
| employee_id | os      |
+-------------+---------+
|           1 | Linux   |
|           1 | Mac OS  |
|           1 | Windows |
|           2 | Linux   |
|           2 | Windows |
+-------------+---------+
+-------------+----------+
| employee_id | language |
+-------------+----------+
|           1 | SQL      |
|           1 | PHP      |
|           2 | C++      |
|           2 | Java     |
|           2 | Lua      |
|           2 | SQL      |
|           2 | PHP      |
|           2 | Python   |
+-------------+----------+
```

现在，事实只能放在一个地方，没有冗余，因为在每个表中，两列都构成主键，主键总是唯一的。

很少有数据库设计人员关心 4NF，您也没有理由这样做。如果您曾经创建了一个不在 4NF 的表，您可能会意识到更新它涉及到数据应该去哪里的一些不确定性，然后您可以修复这个问题。

限制

默认情况下，一个 MySQL 表根本不需要有任何关于什么数据进入其中的规则，只要每个值适合列的类型，如果列有字符类型，几乎任何东西都可以。您不必有主键或任何键，并且可以有重复的行。你有一张桌子，但是你没有亲戚。(所有关系都有一个主键，这意味着不能有重复的行。)不过，对于你的数据库来说，你并不想生活在蛮荒的西部。你想要一些法律和秩序。

MySQL 约束

从用 MySQL Workbench 绘制的 ER 图构造的表确实有一些规则，称为*约束:*有一个主键，它是唯一的，也有外键约束，它防止被引用行被删除，直到引用行被首先删除(或引用被更改)，以防止悬空引用。

此外，我说过您可以声明一个或多个列是惟一的，如果有一个您不想作为主键的自然键，您会这样做。在这种情况下，您可能希望将候选(自然)键约束为惟一的，在`create table`语句中有如下内容:

```php
unique index unique_name (last, first)
```

我还强调了制作尽可能多的专栏的重要性。

所以，我已经提到的约束是

*   主关键字
*   外键(参照完整性)
*   独一无二的
*   不为空

SQL 定义了一个*检查约束*，它允许您为列指定一个条件，以更广泛地检查输入的数据，而不仅仅是不为空、唯一或引用一个主键。例如，如果一个表有一个`office`列，您可以编写如下代码:

```php
check (office in ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO'))
```

不幸的是，MySQL 没有检查约束。但是在版本 5 中，它确实有触发器，而且它们几乎可以同样有效地用来验证数据。

您可能想知道为什么要在数据库中检查数据，因为所有输入的数据都要通过您的 PHP 应用，您可以在那里检查数据。我的想法是，数据库不仅应该负责存储数据模型，还应该负责确保其完整性。这样，无论数据是如何进入的，即使是直接通过 MySQL Workbench 或其他实用程序，检查都会进行。甚至一个 PHP 应用也可能有多种方式将数据放入数据库:表单、转换程序或来自另一个系统的数据提要，可能是另一个应用或像 UPC 扫描仪这样的设备(杂货店收银台用来读取条形码的设备)。如果您将验证放在数据库中，您知道没有任何无效数据可以进入。

将约束放在数据库中的另一个优点是组织性的:它将更多的工作交给团队中负责数据库的任何人，因为一旦设计好了，除了随着需求的增加做一些修改之外，就没有更多的事情要做了。添加约束使工作变得更大，减轻了其他忙于完成应用的开发人员的工作。集中约束也使得它们更有可能被强制执行，而不是依赖于每个团队成员理解与他或她项目部分相关的所有约束。

MySQL 触发器的约束

MySQL 触发器是在对表进行插入、更新或删除之前或之后执行的操作，这意味着一个表最多可以有六个触发器。您用 SQL 编写操作代码。

例如，假设您有一个包含几列的`manager`表，其中包括一个名为`office`的列，并且您希望记录每次插入。这里有一个你可以使用的触发器。

```php
delimiter @
create trigger manager_trigger
before insert on manager
for each row begin
    insert into log
    set msg = concat('insert ', new.office);
end;
@
```

`delimiter`语句不是创建触发器的 SQL 的一部分，但它对`mysql`命令和 MySQL Workbench 的脚本部分很重要，因为`create trigger`语句包含一个分号(在倒数第三行的末尾)，这是默认的语句分隔符。所以改成了`@`，允许分号作为普通字符处理。

另一个有趣的语法是`concat`函数的第二个参数中的限定符`new`。如果触发器是为了更新，那么对于`office`,将会有两个感兴趣的值:旧值和新值；`old`和`new`限定符表示您想要哪个。对于插入触发器，只有新值，但仍然需要限定符。

该触发器在对`manager`表的任何插入之前执行，它导致对`log`表的插入。通过执行插入，您可以看到这一点。

```php
insert into manager
(last, first, office)
values ('Smith', 'John', 'TOKYO');
```

经理表现在包含

```php
+-------+-------+--------+
| last  | first | office |
+-------+-------+--------+
| Smith | John  | TOKYO  |
+-------+-------+--------+
```

并且插入导致日志表包含

```php
+--------+---------------------+--------------+
| log_id | datetime            | msg          |
+--------+---------------------+--------------+
|      2 | 2013-05-08 12:55:21 | insert TOKYO |
+--------+---------------------+--------------+
```

我想指出一些奇怪的行为，因为几个月前的大部分时间里，它让我相当困惑。假设您忘记在`office`前输入`new`，导致触发器出错。

```php
delimiter @
create trigger manager_trigger
before insert on manager
for each row begin
    insert into log
    set msg = concat('insert ', office);
end;
@
```

MySQL 将允许您创建触发器，但在触发器执行之前不会检查错误的引用。现在假设您尝试一个完全有效的插入。

```php
insert into manager
(last, first, office)
values ('Jones', 'Mary', 'PARIS');
```

您会得到以下错误消息:

```php
Error Code: 1054\. Unknown column 'office' in 'field list'
```

花尽可能多的时间盯着`insert`语句，看看为什么`office`是未知的，看看表定义，尝试用其他方式来表达它，改变数据，无论如何，你永远不会找到错误的来源，因为它在触发器中，而被引用的字段列表在触发器中，而不是在你正在看的插入中。就我而言，我在几周前就已经创建了触发器，并且已经忘记了它们。(明年 4 月 1 日，你可能会在同事身上试用，但请不要说你是在这里读到的。)

像这样设置自动日志记录实际上是有用的，您可能想要这样做，但是我们感兴趣的是约束。为此，你用 MySQL 的过程语言写一些代码，它没有名字，但是基于 ANSI 标准的 SQL/PSM(持久存储模块)规范。关于这种语言最好的入门书籍是 Guy Harrison 和 Steven Feuerstein 的《MySQL 存储过程编程》( O'Reilly Media，2006)。

这种语言有编程语言通常会有的条件和流控制语句，但是数据验证只需要很少的一部分。下面是如何更改触发器来完成上一节中 check 约束所做的事情。

```php
delimiter @
create trigger manager_trigger
before insert on manager
for each row begin
    if new.office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        -- generate an error
    end if;
end;
@
```

但是我们如何产生一个错误呢？MySQL 程序员过去常常通过执行非法操作来生成一个错误，例如更新一个不存在的表，该表的名称是由错误消息形成的，从而得到如下错误:

```php
Error Code: 1146\. Table 'mydb.ERROR: bad office' doesn't exist
```

然后，他们会对错误消息进行一些模式匹配，解析出“错误:坏办公室”部分。

但是现在，在 5.5 版本中，MySQL 有了`signal`语句，因此触发器可以编码如下:

```php
delimiter @
create trigger manager_trigger
before insert on manager
for each row begin
    if new.office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
end;
@
```

SQLSTATE 可以保存五个字符的字符串。所有内置的都是数字，所以如果你让你的以非数字开始，就不会有任何冲突。

关于 PHP 和 MySQL 的接口我还没有说太多(更多在第五章，但是我现在将给出一个例子来说明不仅信号会导致 MySQL 错误，而且 MySQL 的 PDO 接口会抛出一个异常，所以这个错误很容易被 PHP 捕获。清单 4-10 显示了一个试图插入无效数据的程序(`office`列中的“巨石”)。`insert`以粗体显示。

***清单 4-10*** 。插入无效数据会触发错误

```php
define('DB_HOST', 'localhost');
define('DB_PORT', '3306');
define('DB_NAME', 'mydb');
define('DB_USERNAME', 'root');
define('DB_PASSWORD', '...');
try {
    $dsn = 'mysql:host=' . DB_HOST . ';port=' . DB_PORT .
      ';dbname=' . DB_NAME . ';charset=utf8';
    $pdo = new PDO($dsn, DB_USERNAME, DB_PASSWORD);
    $pdo->setAttribute(PDO::ATTR_ERRMODE,
      PDO::ERRMODE_EXCEPTION);
    $pdo->query("insert into manager set office = 'BOULDER'");
}
catch (PDOException $e) {
    die(htmlspecialchars($e->getMessage()));
}
```

注意，我设置了 PDO 属性`PDO::ERRMODE_EXCEPTION`,这样任何错误都会引发异常。这是你应该经常使用的 PDO 界面的一个有价值的特性，但是，不幸的是，它在默认情况下是禁用的。还要注意异常处理程序中的函数`htmlspecialchars`，因为 MySQL 错误消息往往包含尖括号和其他特殊字符。

当我运行该程序时，我在屏幕上看到以下内容:

```php
SQLSTATE[CK001]: <<Unknown error>>: 1644 Invalid OFFICE value.
```

我喜欢将这个约束实现为触发器，因为它在数据库内部，所以这个或任何 PHP 程序都会自动得到错误。正如我之前所说，数据模型约束属于数据库，而不是应用。

当然，对更新进行同样的约束也很重要。这可以通过另一个触发器来完成(注意，它现在显示的是`before update`)。

```php
delimiter @
create trigger manager_trigger
before update on manager
for each row begin
    if new.office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
end;
@
```

但是，正如拥有冗余数据不是一个好主意一样，对约束进行两次编码也不是一个好主意。不幸的是，没有 MySQL 语法像

```php
before update or insert on manager
```

所以你需要两个完全独立的触发器。

好吧，程序员怎么把常用代码合并，这样就不用写两遍了？有了程序，就是这样。MySQL 代码也是如此——我将定义一个过程并从两个触发器中调用它，如清单 4-11 所示。

***清单 4-11*** 。两个触发器调用同一个过程(不起作用)

```php
delimiter @
create procedure check_manager() begin
    if new.office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
end;
@
create trigger manager_trigger_update
before update on manager
for each row call check_manager;
@
create trigger manager_trigger_insert
before insert on manager
for each row call check_manager;
@
```

当我试图更新经理表时，我得到以下结果:

```php
Error Code: 1109\. Unknown table 'new' in field list
```

问题是限定符`old`和`new`允许在触发器中使用，但不允许在过程中使用，即使这些过程是从触发器中调用的。因此，有必要传入`new.office`的值，因为该过程没有其他方法来获取列数据。事实上，所有的列都应该被传入，这样过程就可以访问整行，允许在一个过程中对表的所有约束进行编码。

清单 4-12 显示了修改后的代码，现在可以工作了。

***清单 4-12*** 。两个触发器调用同一个过程(有效)

```php
delimiter @
create procedure check_manager(last varchar(45),
first varchar(45), office varchar(45))
begin
    if office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
end;
@
create trigger manager_trigger_update
before update on manager
for each row call check_manager(new.last, new.first, new.office);
@
create trigger manager_trigger_insert
before insert on manager
for each row call check_manager(new.last, new.first, new.office);
@
```

我喜欢将每个表的所有约束代码放入它自己的过程中，但我不喜欢的是必须将参数列表写出三次，包括将所有类型写对。这意味着每当我修改一个表时，我都必须调整触发器和约束过程。此外，我的一些 CWA 表有很多列，甚至第一次写出参数列表也很痛苦。真的，我宁愿花四个小时写代码，也不愿花四分钟打一些无聊的东西。

所以，我就是我，本质上是一个工具铁匠，我决定自动写出参数列表，因为它都在`information_schema`中，我已经在“Nulls”一节中展示过了。

我将一点一点地构建 PHP 程序。清单 4-13 显示了依赖函数`add_triggers`来创建插入和更新触发器以及它们调用的过程的主要部分。

***清单 4-13*** 。代码调用`add_triggers` 来添加触发器和过程

```php
define('DB_HOST', 'localhost');
define('DB_PORT', '3306');
define('DB_NAME', 'mydb');
define('DB_USERNAME', 'root');
define('DB_PASSWORD', '...');
try {
    $dsn = 'mysql:host=' . DB_HOST . ';port=' . DB_PORT .
      ';dbname=' . DB_NAME . ';charset=utf8';
    $pdo = new PDO($dsn, DB_USERNAME, DB_PASSWORD);
    $pdo->setAttribute(PDO::ATTR_ERRMODE,
      PDO::ERRMODE_EXCEPTION);
    add_triggers($pdo, 'manager', "
    if office not in
    ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
    ");
}
catch (PDOException $e) {
    die(htmlspecialchars($e->getMessage()));
}
```

注意，`add_triggers`的第三个参数是将在过程内部结束的检查约束。它是从清单 4-12 中的代码复制而来的。

使用`information_schema`总是需要一些研究和实验，但是之后我想出了这个查询来列出一个表的列和它们的类型。

```php
mysql> select column_name, column_type
    -> from information_schema.columns
    -> where table_schema = 'mydb' and
    -> table_name = 'manager';
+-------------+-------------+
| column_name | column_type |
+-------------+-------------+
| last        | varchar(45) |
| first       | varchar(45) |
| office      | varchar(45) |
+-------------+-------------+
```

清单 4-14 显示了初始的`add_triggers`函数，它只显示了列的逗号分隔列表(`$cols`)和另一个列及其类型的逗号分隔列表(`$parms`)。

***清单 4-14*** 。初始`add_triggers`功能

```php
function add_triggers($pdo, $table, $sql) {
    $stmt = $pdo->prepare('select column_name, column_type
      from information_schema.columns
      where table_schema = :dbname and table_name = :table');
    $stmt->execute(array('dbname' => DB_NAME, 'table' => $table));
    $cols = $parms = '';
    while ($row = $stmt->fetch()) {
        $cols .= ", new.{$row['column_name']}";
        $parms .= ", {$row['column_name']} {$row['column_type']}";
    }
    $cols = substr($cols, 2); // extra ", " at front
    $parms = substr($parms, 2);
    echo "<p>$cols";
    echo "<p>$parms";
}
```

这是输出。

```php
new.last, new.first, new.office
last varchar(45), first varchar(45), office varchar(45)
```

下一步是获取这两个列表(`$cols`和`$parms`)并构建`create trigger`和`create procedure`字符串。清单 4-15 中的显示了这么多，它显示了清单 4-14 中最后一个`echo`之后的内容。

***清单 4-15*** 。`add_triggers`函数的更多代码

```php
$trigger1_name = "table_{$table}_trigger1";
 $trigger2_name = "table_{$table}_trigger2";
 $proc_name = "check_table_{$table}";
 $trigger1_create = "create trigger $trigger1_name
   before insert on $table for each row begin
   call check_table_{$table}($cols); end";
 $trigger2_create = "create trigger $trigger2_name
   before update on $table for each row begin
   call check_table_{$table}($cols); end";
 $proc_create = "create procedure $proc_name($parms)
   begin $sql end";
 echo "<p>$trigger1_create";
 echo "<p>$trigger2_create";
 echo "<p>$proc_create";
```

现在我得到了清单 4-16 中所示的输出，添加了一些换行符和空格以使其更具可读性。

***清单 4-16*** 。添加清单 4-15 中的代码时的输出

```php
new.last, new.first, new.office
last varchar(45), first varchar(45), office varchar(45)

create trigger table_manager_trigger1 before insert on manager
for each row begin
    call check_table_manager(new.last, new.first, new.office);
end

create trigger table_manager_trigger2 before update on manager
for each row begin
    call check_table_manager(new.last, new.first, new.office);
end

create procedure check_table_manager
  (last varchar(45), first varchar(45), office varchar(45))
begin
    if office not in ('DALLAS', 'BOSTON', 'PARIS', 'TOKYO') then
        signal SQLSTATE value 'CK001'
        set MESSAGE_TEXT = 'Invalid OFFICE value.';
    end if;
end
```

SQL 构建完成后，剩下的工作就是添加代码来删除现有的触发器和过程，并创建新的触发器和过程。清单 4-17 显示了完整的功能。

***清单 4-17*** 。最终`add_triggers`功能

```php
function add_triggers($pdo, $table, $sql) {
    $stmt = $pdo->prepare('select column_name, column_type
      from information_schema.columns
      where table_schema = :dbname and table_name = :table');
    $stmt->execute(array('dbname' => DB_NAME, 'table' => $table));
    $cols = $parms = '';
    while ($row = $stmt->fetch()) {
        $cols .= ", new.{$row['column_name']}";
        $parms .= ", {$row['column_name']} {$row['column_type']}";
    }
    $cols = substr($cols, 2); // extra ", " at front
    $parms = substr($parms, 2);
    echo "<p>$cols";
    echo "<p>$parms";
    $trigger1_name = "table_{$table}_trigger1";
    $trigger2_name = "table_{$table}_trigger2";
    $proc_name = "check_table_{$table}";
    $trigger1_create = "create trigger $trigger1_name
      before insert on $table for each row begin
      call check_table_{$table}($cols); end";
    $trigger2_create = "create trigger $trigger2_name
      before update on $table for each row begin
      call check_table_{$table}($cols); end";
    $proc_create = "create procedure $proc_name($parms)
      begin $sql end";
    echo "<p>$trigger1_create";
    echo "<p>$trigger2_create";
    echo "<p>$proc_create";
    $pdo->exec("drop procedure if exists $proc_name");
    $pdo->exec("drop trigger if exists $trigger1_name");
    $pdo->exec("drop trigger if exists $trigger2_name");
    $pdo->exec($trigger1_create);
    $pdo->exec($trigger2_create);
    $pdo->exec($proc_create);
    echo "<p>Success!";
}
```

回顾一下我刚才展示的内容:为了避免编辑列和类型的列表，我通过对`information_schema`的查询生成了它们。然后，我构建 SQL 语句来创建触发器和过程，并将这些语句发送到 MySQL 进行处理。我首先删除已创建的对象(如果它们存在的话)，这样程序就可以在每次模式改变时运行。实际上，针对单个表传递给`add_triggers`的 SQL 会更长，因为通常会有许多检查需要进行。您还可以为每张桌子调用`add_triggers`。但是`add_triggers`功能本身不必改变。机械地生成参数列表是值得的，因为它们可能很长，可能有很多表，并且它们必须随着模式的改变而保持最新。

嗯，用 MySQL 编码检查约束不像用 Oracle 这样更完整的 DBMS 那么容易，但也不错。但是，还有一个更严重的问题:带有 check 约束的触发器的存在并不意味着数据都检查正常，因为触发器可能在数据输入后被添加或更改。请记住，它只在插入或更新时触发。这是在输入任何数据之前对数据库设置所有约束是个好主意的原因之一。

交易 s

一个*事务* 是一个与数据库交互的短序列，由查询和/或更新组成，它们一起形成一个有意义的活动单元。实际上，您应该将一个事务看作是一组必须完全完成或者根本不完成的 SQL 语句。

例如，清单 4-9 中显示的两个表`os`和`language`，以及它们引用的`employee`表。假设您想要删除一个雇员，这需要删除所有三个表中该雇员的所有行，这将需要执行三个单独的 SQL `delete`语句(在没有级联的情况下)。这些构成了一个事务，因为如果由于某种原因它们都无法完成，您不希望任何数据被删除。删除员工完全失败是可以的；在这种情况下，用户将被简单地告知失败，他或她可以再试一次。比如说，删除语言，留下主雇员行和操作系统行是不行的。如果数据库处于这种状态，它将包含错误的信息。尽管这种不一致可能会很快得到解决，但仍然会有时间让另一个用户生成一个包含错误信息的报告。也许员工刚刚辞职，所以虚假信息对他或她来说无关紧要。但是报告的目的可能是判断经理的表现，他会因为有一个不懂编程语言的员工而受到批评。

事务的这种属性，要么完全完成，要么根本不做，被称为原子属性。有四个基本属性共同构成了首字母缩略词 ACID 。

*   正如我刚才解释的，A 代表原子。
*   **C** 代表*一致性*，这意味着当事务完成时，所有一致性约束(例如，外键和非空)必须为真。
*   **I** 表示*被隔离*，这意味着该事务的影响对于与数据库交互的任何其他进程都是不可见的。
*   **D** 代表*耐久性*，这意味着一旦完成，该事务的效果不能丢失，即使出现操作系统错误、硬件故障或断电。

Theo Haerder 和 Andreas Reuter 在 1983 年的一篇调查论文“面向事务的数据库恢复原则”(`www.minet.uni-jena.de/dbis/lehre/ws2005/dbs1/HaerderReuter83.pdf`)中创造了一个聪明的缩写词 ACID，意思是高质量的数据库必须通过“ACID 测试”，非常值得一读。

这些属性是数据库的责任，而不是您的应用的责任，前提是您已经指明了事务开始和结束的时间。通过 MySQL 的 PDO 接口，您可以通过调用`PDO::beginTransaction`和`PDO::commit`来实现。您还必须使用 InnoDB 存储引擎，无论如何您都应该这样做。其他存储引擎(有很多)可能也支持事务，但是对于大多数目的来说，InnoDB 是最好的。

在您的 PHP 代码中，一个事务看起来如下:

```php
$pdo->beginTransaction();
// ... several SQL statements ...
$pdo->commit();
```

如果执行在到达`commit`之前被中断，那么从`beginTransaction`开始的所有操作都将回滚，就像从未发生过一样——所有的删除、插入和更新。因为隔离，没有其他事务可以看到你的任何部分工作；如果有，并且您回滚了，它可能会看到看似存在但实际不存在的幻影数据。

如果您想强制回滚，因为可能有一个 SQL 错误，或者您已经检测到一些错误，或者用户取消了您的应用正在做的任何事情，您调用`PDO::rollback`函数。如果 SQL 语句失败，这不会自动完成；你必须自己捕捉异常并调用`rollback`。

如果不启动事务，每个 SQL 删除、插入或更新都是在 MySQL 所谓的*自动提交*模式下执行的，这意味着每个语句都是自己的事务。也就是说，你一边走一边提交。这是默认模式——如果您愿意，可以关闭它，如果有一长串不一定在事务中的更新，并且如果单个更新被排队等待以后处理，可以更有效地处理，那么您可能会这样做。

MySQL 的一致性属性不言而喻，因为没有办法像其他系统那样推迟约束。有了它们，任何延迟的约束都会作为提交的一部分得到处理；在 MySQL 中，约束(和触发器)逐个语句地操作。

默认情况下，MySQL(实际上是 InnoDB 引擎)提供的隔离赋予了*可重复读取*，这意味着事务中的任何普通(非锁定)`select`语句都可以看到一致的数据，即使某处的另一个事务试图更改该数据。如果需要，您可以用一个`set transaction isolation level`语句来改变它；选项有`read committed`、`read uncommitted`或`serializable`。我不会在这里讨论细节，但是你可以在 MySQL 文档的`dev.mysql.com/doc`中读到。

在我编写的应用中，几乎我所有的代码都使用了自动提交。偶尔我会做一些必须是原子的更新，所以我建立了一个事务。您希望避免让事务变得太大——例如，几十个，甚至几百个更新——因为整个事情可能必须回滚，并且许多行可能必须被锁定。如果您有那种批量更新，并且它确实需要是原子性的(可能不是——仔细想想),那么最好在数据库不被使用时运行它，如果有这样的时间的话。

当我有一个事务时，我将`rollback`调用放在错误处理代码中，如清单 4-18 中的所示。注意，我测试以确保设置了`$pdo`,因为如果构造函数失败就会抛出一个异常，在这种情况下它没有被设置。此外，在调用`rollback`之前，我会测试自己是否在一个事务中。(通常，我的应用不是这样组织的，因为`$pdo`设置远离事务代码。在第五章中会有更多的介绍。)

***清单 4-18*** 。调用错误处理程序中的`rollback`

```php
try {
    $dsn = 'mysql:host=' . DB_HOST . ';port=' . DB_PORT .
      ';dbname=' . DB_NAME . ';charset=utf8';
    $pdo = new PDO($dsn, DB_USERNAME, DB_PASSWORD);
    $pdo->setAttribute(PDO::ATTR_ERRMODE,
      PDO::ERRMODE_EXCEPTION);
    $pdo->beginTransaction();
    // ... several SQL statements ...
    $pdo->commit();
}
catch (PDOException $e) {
    if (isset($pdo) && $pdo->inTransaction())
        $pdo->rollBack();
    die(htmlentities($e->getMessage()));
}

```

数据库安全

数据库安全包括

*   *备份和恢复*:保护数据不因错误、设备故障或破坏而丢失，
*   *网络安全*:防止对 MySQL 服务器的未授权访问，以及
*   *访问控制*:防止未经授权的 SQL 操作，比如删除表。

我简要地讨论了其中的每一个，要了解更多信息，您可以查看位于`dev.mysql.com/doc`的 MySQL 文档。

备份和恢复

无论谁运行生产服务器，无疑都有某种备份和恢复系统，但问题是您是否能信任它。例如，您可以询问备份是否异地存储，多久异地移动一次，保留多少代等等，您会得到答案，但这些都将基于书面政策。当夜班操作员在凌晨 2 点打盹、给他或她的朋友发短信或者在外面抽烟时，实际上发生了什么，谁也说不准。

因此，除非数据库太大而不实用，否则您应该自己制作备份并将它们存储在本地计算机上。您可以从 MySQL Workbench 或使用*nix shell 脚本来完成。另一个想法是使用一个名为`s3cmd`的命令，用一个每天晚上自动运行的脚本将备份存储在亚马逊 S3(云存储)上。你可以在`gist.github.com/oodavid/2206527`找到这方面的文章。

注意，我这里说的备份和恢复是针对整个数据库的。它与回退事务(回滚)无关，回退事务在 MySQL 内部处理。

网络安全

如果运行在 web 服务器上的 PHP 程序和 MySQL 在同一台计算机上，那么您只需要从“localhost”默认访问 MySQL。它是安全的，因为没有任何其他计算机的访问。如果 MySQL 在它自己的计算机上，你需要从应用计算机上访问它，但是你可以把它限制在固定的 IP 地址上，这仍然是安全的，特别是如果它们在本地网络上。只要你设置正确，在公共互联网上进行更广泛的访问是安全的，不要过于慷慨地给出允许访问的 IP 地址。

您可以在 MySQL Workbench 中设置网络安全性。你需要的技术信息在`dev.mysql.com/doc`的 MySQL 文档的第六章中。

访问控制

MySQL 的访问控制允许您创建拥有自己密码的用户，然后控制他们拥有什么特权来操作数据库、表和行。为应用的每个用户创建一个 MySQL 用户是不切实际的，因为 MySQL 管理员必须创建 MySQL 用户，而且权限不能映射到应用功能中。

一般来说，对于本书主题的各种 PHP/MySQL 应用所使用的任何数据库，您只需要两个用户:一个拥有所有权限，用于管理数据库，另一个用于普通应用用户。第一个会在你安装 MySQL 的时候自动设置，也就是本书(`root`)的例子中出现的那个。你必须自己设置一个更有限的，用 MySQL Workbench 很容易做到。首先设置用户，这里称为`app`，如图图 4-17 所示。

![9781430260073_Fig04-17.jpg](img/9781430260073_Fig04-17.jpg)

图 4-17 。MySQL Workbench 中的用户应用设置

接下来，在“管理角色”选项卡上，您将该用户限制为只能进行一些 DML 操作，因此它可以读取和修改数据，但不能更改模式，如图 4-18 所示。

![9781430260073_Fig04-18.jpg](img/9781430260073_Fig04-18.jpg)

图 4-18 。用户应用的管理角色

在第五章和第六章中，我展示了如何让用户登录到你的应用中。每个人都以 MySQL 用户`app`的身份运行，除了管理员，他们以`root`或者你所称的管理用户的身份运行。在第七章的中，我会对面向应用的角色(*基于角色的访问控制*，或者 RBAC)有更多的介绍。

性能优化

关于数据库性能优化的第一条也是最重要的一条规则是，除非有证据表明你需要，否则你不应该这么做。即使你认为你有，你也不能做任何测量，直到有一些现实生活中的数据，所以你至少要等到那个时候。

如果有问题，尽量本地化。如何对查询进行编码会对它的运行时间产生巨大的影响。找到一个检索兆字节数据的查询，结果却是大海捞针，丢掉了干草，这是很常见的。一个更好的查询可能会运行得更快。

索引可能有助于加快连接或`where`子句的速度。每个主键和唯一约束都有一个，但更多可能会有帮助。它们会降低更新速度，但会大大加快查询速度。

如果您认为模式和 SQL 已经尽您所能做到最好，那么接下来的事情就是通过增加内存来扩大规模，如果这不起作用，就增加更多的 CPU/内核和更快的磁盘，甚至可能增加固态硬盘。如果必须向外扩展，有时可以逻辑地拆分数据库，例如，将每个销售区域放在自己的服务器上。这使得一些报告变得复杂，但是更新可能仍然很简单。最后一个办法是将一些数据转移到 NoSQL 数据库。

我没有足够的空间来详细讨论 MySQL 的性能，但是有一本关于这个主题的非常出色的书，由巴伦·施瓦茨、彼得·扎依采夫和瓦迪姆·特卡琴科合著的《高性能 MySQL 》( 2012 年，奥赖利媒体出版公司)。如果你有 MySQL 性能问题，这是必不可少的读物。

你有好的数据库吗？

现在您已经读到了本章的末尾，您会想知道您的数据库设计是否是一个好的设计。如果以下条件都为真，则为真:

1.  ER 图是可以理解的，所有的关系不仅有意义而且符合要求。
2.  所有的表和列都有很好的名称，具有一致的命名方案。外键列与其相关的主键同名，除非表中有多个这样的外键列。
3.  您已经完成了“从 ER 图到物理设计”一节中列出的所有步骤这意味着每个外键都有一个外键约束，所有候选键都有唯一的约束，它是第三范式(如果不是第四范式)，并且您已经建立了所有合理的完整性约束，包括触发器形式的检查条件。
4.  您已经用一个执行适当连接的查询测试了 ER 图上的每个关系。
5.  所有要从现有系统转换的数据都可以加载到数据库中。
6.  可以满足所有报告要求，这可以通过编写测试 SQL 查询来确定。(不需要自己创建报告。)
7.  可以满足所有 CRUD 要求。
8.  您已经浏览了每一个用例，并且您需要的数据库中的所有东西都在那里。

在测试关系(步骤 4)之前，您必须加载一些数据，这样您就有东西可以使用了。最好的选择是开发并运行你无论如何都需要的转换程序(第八章)，但是，因为这需要一些时间，你可能想用假数据来代替。关系(表示为外键)应该从 PHP 程序中插入，因为手工插入太繁琐了。原始数据(假名、地址等)的良好来源。)是网站`generatedata.com`。或者，用 PHP 编造你自己的假东西是相当容易的。如果你一直想认识名叫斯图·皮德利或丹·塔弗洛斯的人，现在你的机会来了。

如果您满足了这些条件，那么您就拥有了一个好的数据库！你应该祝贺自己，因为现在你的项目一定会成功。您有需求，这是成功的最重要的标准，还有数据库，这是实现的最关键的部分。完成转换，写报告，现在你需要的是一个像样的用户界面。这确实很难，但如果你第一次没有做对，你可以继续尝试，直到你做对为止，而不会影响系统的任何其他部分。

等等。。。。把失败从胜利的虎口中夺走还不算太晚。阅读下一节了解如何做到这一点。

开发对象关系映射层

如果您的团队中有任何面向对象的程序员，您几乎肯定会这样做，他们会希望用面向对象的模型包装关系模型，这样他们就可以假装他们真的在使用对象数据库。对象关系映射(ORM) 提倡用他们的编程语言，通常是 Java 或 C#，根据对象进行真正的设计；数据库，在某种程度上，他们想考虑它，只是一种方法，使这些对象持久化。

这种方法的好处是

*   应用与关系模型是分离的，所以如果模型改变，只有 ORM 的内部必须改变。
*   整个应用只有一个对象模型，而不是一个用于程序，另一个用于数据库(由实体和关系组成)。
*   只有在 ORM 层工作的程序员(或者程序员，如果是一个大项目的话)必须处理 SQL 和事务(ACID 属性)。
*   跟踪数据库的使用情况很简单，因为所有的访问都通过同一个界面。

我觉得很棒！但是，一如既往地，也有一些缺点。

*   ORM 将会有数百甚至数千行额外的代码，如果应用的程序员愿意并且能够直接处理 SQL，所有这些都是不必要的。换句话说，没有一行 ORM 代码与任何需求直接相关，因此也没有任何客户利益。它的唯一目的是实现一种特定的实施方法。
*   ORM 是数据不匹配、一致性故障、崩溃、错误查询和 ACID 故障的新来源。它必须配备人员、调试、测试、记录、移植和维护。
*   如果 ORM 要保护大多数程序员不受 SQL 的影响，那么这将是一个巨大的开发瓶颈，在一两个从事 ORM 工作的人实现他们需要的对象和方法之前，任何人都无法取得很大的进展。以数据库为中心的架构所提供的开发并行性被破坏了。
*   ORM 程序员的工作非常困难。将每个实体映射到一个对象很容易，但是应用的许多部分都要利用关系，这意味着实体之间的连接。这些都需要发明新的物体。事务也必须在 ORM 中实现。
*   应用开发人员被剥夺了 SQL 的好处，主要是将数据作为集合处理的能力，使用非过程的基于集合论的查询代替过程代码。
*   应用程序员对新的 ORM 特性的每一个请求都需要协商，如果我自己的经验有指导意义的话，还需要争论。这使得工作变得非常不愉快和低效。
*   由于前一点，程序员将通过已经实现的对象将查询编码为一系列循环，而不是让数据库做它擅长的事情，即以高度优化的方式运行`select`语句工厂(图 4-1 )，这可能需要对 ORM 进行更改。

我还应该提到一点，ORM 并没有*而不是*保护其余的应用代码免受数据模型变化的影响，因为大多数这样的变化都会改变 ORM 模型。您已经拥有了逻辑和物理模型之间的数据独立性，这是 Codd 最初对关系方法的证明，您不需要它两次。

啊哦！我可能暴露了我的位置！当然，我见过。为什么，有了一个强大的团队(第一章)、手头的需求或进展良好的需求(第二章)、建立了正确的平台(第三章)以及良好的数据库设计(第四章)，你会想用 ORM 把它搞砸呢？在这一点上，没有 ORM，你几乎不可能失败。编程转换(如果你还没有)，CRUD 和报告，你就完成了。事实上，在您构建 ORM 之前，您就已经完成了！

构建一个高效可靠的 PHP/MySQL 应用的最快方法是按照它本来的用途使用 MySQL，作为一个关系数据库。也许如果你使用一个对象数据库，你也可以做得很好(*也许*)，但是假装这就是 MySQL 将会是一个巨大的错误。

尽管如此，面向对象的狂热分子会要求 ORM，他们会无情地攻击任何不同意他们的人。尽你所能击退他们。他们的想法在一个长长的`Stackoverflow.com`帖子(`stackoverflow.com/questions/760834/question-about-the-benefit-of-using-an-orm`)的评论中被很好地捕捉到了。

当你让数据库决定你的应用设计时，你就失去了正确建模面向对象设计的能力，并开始让数据库决定你如何设计一个荒谬的应用。我不关心数据库。它是一个持久的数据存储，仅此而已。在应用中使用数据库仅仅是拥有可以以某种方式查询的持久数据存储的一种方式。

这是一个很棒的评论，因为它非常清楚地表达了我一直建议的完全相反的观点:数据库*应该*决定设计，你必须*非常关心它*，因为它建立了应用操纵的模型。

这让我想起我曾经看过的一篇关于摇滚唱片的评论，大意是音乐似乎来自讨厌摇滚的音乐家。我认为 ORM 的人讨厌数据库。

Ted Neward 在他的博客(`blogs.tedneward.com`)上称 ORM 为“计算机科学的越南”。这个比喻不错。用纽沃德的话说，ORM“代表了一个泥潭，开始很好，变得更复杂久而久之，不久就让用户陷入一个没有明确分界点、没有明确胜利条件、没有明确退出战略的承诺中。”还有这个:“。。。早期的成功产生了在成功变得更加难以捉摸的地方使用 O/R-M 的承诺，随着时间的推移，由于通过所有可能的用例来支持它所需的时间和精力开销，根本就不是成功。”

我将以一个真实的故事来结束这篇长篇大论:你还记得我在第一章中描述的超级任务项目吗？该项目的程序员为了开发一个 Windows 版本，耗尽了所有的风险投资，却一无所获。当我在他们工作了一年后接手工程时(50 万美元)，他们有一个看起来很像 Windows 文件资源管理器的外壳，一个非常好的数据库设计和一个 ORM。仅此而已。正如我提到的，我们得到了另外六个月的资金。我保留了数据库，扔掉了 shell 和 ORM。所有程序员都用 SQL 编写代码，有时被查询对象保护得很薄，这些查询对象是微软用于 Windows 应用的 MFC 类库的一部分，有时直接编写代码。这使得我们可以并行工作。我们完成了这个应用，把它安装在一些大型食品连锁店里，并通过把公司卖给一个更大的机构，让投资者和创始人都满意了。ORM 呆在它该呆的垃圾桶里。

正如爱丽丝·温的民权老歌所唱的，“把你的眼睛放在奖品上。”一只 ORM 不是。

章节总结

*   SQL 允许您以集合(元组/行)的集合(关系/表)的形式非过程地处理数据。
*   SQL 的重要部分是连接，主要是内部连接和左/右外部连接。
*   一种有效的高级建模符号是 er 建模，尽管还有其他符号。
*   识别实体是 ER 建模中最重要的部分，其次是关系，再次是属性。一旦建立了实体，关系和属性就由需求决定了。
*   物理上，关系由主键和外键表示。
*   第二和第三范式是必不可少的；第一范式主要是为了避免笨拙的编码和频繁的模式更改。
*   数据库的约束越多越好(unique、foreign-key、not null 和用触发器实现的 check 约束)。
*   将对数据库的访问保持在应用所需的最低限度，只有两个用户具有有限的网络访问权限，或者没有网络访问权限。
*   自己备份数据库，不管你的主机提供商声称在做什么。
*   根据您当时的需求，继续进行数据库设计，直到它是正确的。随着需求的发展，数据库当然也应该发展。
*   不要构建 ORM 层，如果你知道有人不这么认为，可以考虑进行干预。**