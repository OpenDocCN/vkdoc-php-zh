# 四、Laravel 简介

在本章中，您将了解各种 Laravel 工具的来龙去脉，当这些工具与最佳实践结合使用时，可以在相对较短的时间内产生显著的效果。正确设置环境很重要，网上有很多教程(或者访问 Laravel.com，阅读安装文档，这很棒)。我们将讨论如何在您的本地环境中安装 Laravel(使用 Composer 和 Laravel 安装程序脚本)。

Note

如果您阅读了安装文档并决定使用`homestead`虚拟主机选项，那么您不需要我在本章中概述的安装过程，因此可以随意跳到下一节。

在我们为 Laravel 开发做好适当的准备之后，我们将经历另一个您可能会在某个时候遇到的示例场景。我们将构建一个简单的表单，该表单接受并验证特定类型的文件，并点击定义为路由的各个端点，这些端点将请求转发到控制器，然后控制器将处理生成文件名并将其存储在文件系统中。

我们将复习 Laravel 基础知识，如下所示:

*   路由配置

*   控制器

*   Artisan 用于生成脚手架代码的命令行实用程序

*   请求和请求验证

*   前端和刀片模板
    *   设置 Ajax 请求和响应(就前端方面而言，我给出的例子有点过时，但我在本书中并不太关注前端。有关最新和最棒的前端技术的更多信息，我建议您查看 *React。*)

*   Laravel 的请求/响应周期

*   一个基本的“流程”,你可以重复它来开始你自己的项目

我们将修改 Artisan 工具提供的脚手架，以调整路由、请求、控制器和其他预构建的模板。我们将允许外部通过基于 URI 的路由访问*到*应用。我们将学习 Laravel 中的请求，包括请求/响应生命周期和传入请求数据的验证。我将向您展示如何通过在控制器方法中简单地输入提示来无缝地验证您的请求，以及如何在请求的`rules()`方法中设置适当的验证约束来自动验证整个请求对象。我们希望我们的 API 和应用尽可能地安全，Laravel 有许多优秀的特性，只需(通常)几行代码就可以轻松实现众所周知的安全实践。我将深入探讨这些问题，并讨论一些考虑因素和背景知识，这将有助于您开始理解事情。

你还将了解到 Laravel 的*运作方式。如果我们要创建一个使用 Laravel 框架和最佳实践实现的具有模型驱动设计的应用，我们需要全面了解 Laravel *和*这些实践。Laravel 将是本章的主题，但是我们将遵循 Laravel 本身所建立的最佳实践。*

我已经包括了几个部分，这些部分偏离了一些选择的主题，但是仍然是你不应该跳过的重要概念。这些边栏旨在让您更深入地思考一个特定的概念，包括我们在软件实现方面所做决定的利弊，并为您提供一些想法，以找到以不同方式完成相同任务的替代方法。在 Laravel 中，您可以自由地定制应用的行为方式、做什么以及如何做。当然，Laravel 应用有一个标准的“流程”,它内置于框架本身(否则它就不是真正的框架),但是它提供了足够的扩展点和程序的不同执行方式，允许我们完成几乎任何我们在标准 PHP 中可以完成的事情，只需要通过一个建立在可靠组件之上的明确定义的 API。

在这一章中，我已经省略了雄辩的 ORM 概念；然而，我们将在后面深入讨论口才，因为它是 DDL 中的关键角色。

Note

假设您的本地系统上已经安装了一份 PHP。如果没有，可以在这里阅读如何安装: [`http://php.net/manual/en/install.php`](http://php.net/manual/en/install.php) 。

现在，让我们继续学习 Laravel 的设置，并开始学习一些很酷的东西。

## 为什么是拉弗尔？

在过去的二十年里，我们已经看到了 web 开发领域发生了一些非常极端的变化——在史诗般的规模上。这些以前端和后端进步、系统设计模式以及新的方言和库的形式出现。2000 年，Cake PHP 推出了第一个 PHP web 框架，并在全球范围内对这种全新的推理和设计 web 应用的方式产生了反响。该系统的核心包括各种各样经过试验和测试的设计模式的实现，它本身被建模为 MVC 框架。在我看来，最重要的事情是，这是一种分离架构关注点的清晰方式，允许开发人员开始摆脱创建混杂层(UI+数据+基础设施)的混乱意大利式丛林，将它们塞进一个文件中。

在 MVC 出现之前，大多数 PHP 代码本质上都是过程化的。即使复杂的 web 应用也很少甚至没有层的划分。现实世界需要更好的东西。实现 MVC 模式的决定以新的(竞争的)PHP MVC 框架的形式引起了广泛的反响。这很可能是激发杨奇煜·普朗西开始 Symfony 框架项目的原因，也是促使 Zend 公司构建 Zend 框架的原因。随着 PHP v5.3 的发布，出现了各种更加进化的 PHP 框架。Symfony 2 和 ZF 2 完全改写了他们以前的自我，并接受了 PHP 5.3 中新的命名空间特性。隐藏在这些事情中间的是策划人泰勒·奥特威尔，他炮制了著名的拉勒韦尔框架。

我坚信熟能生巧的理念。也就是说，你从这一章中获得任何东西的最好方法是跟随并练习编写例子。复制和粘贴代码要容易得多(如果你正在阅读这本书的印刷版本，甚至更好)，因为通过在计算机上实际尝试并试图获得预期的结果，你会学得更快更好，我也提供了这一点。读代码好，写代码更好。我在这一章中保留了非常实用的内容，以便更好地让你了解现实世界中的事情会如何发展。

## 使用 Composer 安装

Composer 既是包管理器又是依赖管理器。要安装它，打开一个终端并进入一个新目录。运行以下命令:

```php
curl -Ss getcomposer.org/installer | php

```

您应该会看到如下所示的内容:

```php
All settings correct for using Composer
Downloading...
Composer (version 1.9.0) successfully installed to: /home/vagrant/Projects/laravel/composer.phar
Use it: php composer.phar

```

虽然有许多方法可以设置一个新的 Laravel 应用，但是我们将通过 Laravel Composer 脚本来完成。要安装此脚本，请运行以下命令:

```php
php composer.phar global require laravel/installer

```

这不仅会下载您在`composer.json`文件中指定的包，还会生成一个漂亮的小自动加载程序，您可以在一行代码中“即插即用”。

```php
require_once('vendor/autoload.php');

```

在我们即将设置的 Laravel stub 项目中，这个文件已经包含在系统内部的 public `index.php`文件中，所以我们不用担心；只要知道它的存在。键入以下命令来启动 Laravel 安装程序，这将导致安装最新的框架版本(在撰写本文时，它是 6.0):

```php
laravel new ddl

```

该命令将生成丰富的屏幕输出，如下所示:

```php
Crafting application...
Loading composer repositories with package information
Installing dependencies (including require-dev) from lock file
    1/3: https://codeload.github.com/laravel/framework/legacy.zip/f38711564c642ee88a58bf180010a0c7a7ab062e
    2/3: https://codeload.github.com/facade/flare-client-php/legacy.zip/a276603dbb7b9b35636d573d5709df5816dd4d2b
    3/3: https://codeload.github.com/facade/ignition/legacy.zip/1f92a209c1a5a60f43c5bbff196177810e817095
    Finished: success: 3, skipped: 0, failure: 0, total: 3
Package operations: 84 installs, 0 updates, 0 removals
  - Installing doctrine/inflector (v1.3.0): Loading from cache
{LONG LIST OF OTHER DEPENDENCIES INSTALLED FROM CACHE OR DOWNLOADED}
facade/ignition RUNS)
Discovered Package: suggests installing laravel/telescope (^2.0)
(LONG LIST OF OTHER SUGGESTED INSTALLS - IGNORE THESE)
Generating optimized autoload files
(A FEW COMMANDS THAT COMPOSER nunomaduro/collision
(A FEW OTHER DISCOVERED PACKAGES)
Package manifest generated successfully.
Application ready! Build something amazing.

```

如果这是您第一次安装应用的依赖项，您可能会看到一串`Downloading...`行，而不是`Loading from cache...`。如果是这种情况，耐心一点就好；有相当多的软件包需要让 Laravel 运行，可能需要几分钟。

您可以通过发出一个`ls`命令来调查*在文件系统中到底发生了什么*。

我们已经在第 [1](01.html) 章中对 Laravel 目录结构有了一个很好的了解，但是这里还有一些细节:

*   这是我们的应用代码和域模型所在的源文件夹。它是典型的 Laravel 应用中大多数自定义代码的位置。

*   `bootstrap/`:它保存了应用的启动脚本和一些类别映射文件。

*   `config/`:保存应用的默认配置，并被`.env`文件中定义的参数覆盖。

*   这存放了数据库文件，包括迁移、种子和测试工厂。

*   这是一个可公开访问的文件夹，保存着编译过的资产，当然还有 Laravel 的前门，即文件。

*   `resources/`:它保存前端资产，如 JavaScript 文件、语言文件、CSS/SASS 文件和刀片模板。

*   `routes/`:应用中的所有路线都在这里面；它们是 API 或浏览器特定的。

*   `storage/`:保存系统中的所有临时文件，包括应用生成的缓存数据和会话，以及编译后的视图文件和日志文件。

*   `tests/`:这包含单元和功能测试。

*   `vendor/`:它保存了 Composer 安装的依赖项。

现在，让我们用 Artisan 命令设置应用的其余部分。Artisan 是 Laravel 附带的命令行实用程序，在开发 Laravel 应用时非常方便。`.env`文件包含应用和外部包所需的所有值，并被用作覆盖在`/config`文件夹中找到的默认配置的手段。

需要注意的是 Laravel 内部的`Http`组件的结构。控制器、路由和中间件的概念已经被分组到一个名为应用的`Http`名称空间的父名称空间中。位于`/dll/app/Http`，分解如下:

*   `App\Http\Controllers`

*   `App\Http\Middleware`

*   `App\Http\Requests`

除了领域模型本身之外，我们还将与`App\Http`名称空间中的项目进行大量的交互，所以最好熟悉这个结构以及其中的项目。我建议先浏览一下名称空间中的所有文件，这样您就可以了解 Laravel 是如何构造的，以及它是如何处理 HTTP 请求的。

## 项目 4-1: Laravel 文件上传

Note

在完成示例项目(以及本文中的所有项目)时，我建议花些时间将源代码输入到我们在本章前面设置的本地环境中。我不建议您键入注释每个类和方法的 PHP 文档块，因为这些是由 IDE 生成的(特别是 JetBrains PHPStorm，我强烈建议您尝试一下)。VSCode 是微软开发的另一个 IDE。也不值得输入所有的评论，除非你觉得有必要这样做。还要注意，在本文的任何示例中都没有使用*或*注释；这是有原因的，我稍后会解释。

在本教程中，我们将构建一个简单的应用，它将完成以下任务:

1.  通过 HTTP 路由显示 web 表单。

2.  提供一种在客户端通过 Ajax 提交表单的方法，并向用户返回一个有效的响应，指示成功或失败以及保存文件的名称。

3.  创建一个表单请求对象，处理传入数据的验证(包括任何附加文件的验证)，然后将这些数据注入控制器。

4.  从请求中提取文件，生成文件名，并以新的名称将其存储在文件系统中。

5.  在客户端，表单提交请求的响应将通过 Ajax 发送和接收，响应将被解析，并在成功或失败的事件中适当地通知用户。

Note

对于这个例子，我没有考虑数据库级或用户级的安全问题。在现实世界的应用中，这些类型的事情应该在任何时候都作为最高优先级*。*

 *表 [4-1](#Tab1) 描述了我们对付这个怪物所需的各种组件。

表 4-2

我们的文件上传示例应用的路由配置

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

路线名称

 | 

URI 路由

 | 

目的

 |
| --- | --- | --- |
| `upload` | `/upload` | 这将是显示我们上传文件的 web 表单的主页。 |
| `process` | `/process` | 这是表单(位于`/upload`)开始提交数据到表单`action`值内路径的地方。 |
| `list` | `/list` | 这将列出系统中所有上传的文件。 |

表 4-1

文件上传演示应用所需的组件

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

组件类型

 | 

组件名称

 | 

描述

 |
| --- | --- | --- |
| 途径 | `/upload``/process``/list` | 定义客户端使用的端点，这些端点指向位于指定控制器(在本例中是`UploadController`)上的某个方法 |
| 模板 | `upload.blade.php` | 保存 web 表单和用于提交表单和检索响应的 Ajax 调用 |
| 表单请求 | `UploadFileRequest` | 用于描述表单的预期内容，还验证数据，并提供添加自定义身份验证逻辑的机制 |
| 控制器 | `UploadController` | 处理请求/响应周期 |

### 配置路线

Laravel 中的路由基本上是一个 URI 或端点，允许通过已知的 URL 地址从外部世界到特定控制器方法的通信，并且可能包含 URI 参数(查询字符串)。它基本上是一个客户端向一个定义的路由发出请求，该路由根据一组要求验证表单数据，并将请求转发到控制器上的适当位置，然后控制器委托用于存储上传文件的逻辑，并返回某种类型的响应，指示请求成功(成功或失败)。

一个路由可以是自包含的，具有在传入的闭包函数内完成请求所需的逻辑，该函数运行并返回给客户端，或者一个路由可以简单地转发给控制器上的特定方法，该方法接受请求并返回响应。使用闭包定义的路由也是一样，但是最大的区别是不能使用 Laravel 的缓存工具来缓存基于闭包的路由。您还可以声明能够被路由组中定义的名称空间命中的特定 HTTP 方法。参见[`https://laravel.com/docs/6.0/routing#basic-routing`](https://laravel.com/docs/6.0/routing%2523basic-routing)Laravel 文档中的路线部分。

Laravel 提供了一种方法来限制给定的路由只能通过特定的 HTTP 动词来使用，通过中间件将运行时逻辑附加到路由组，并用易于记忆(和键入)的名称来标记任何路由，这样在代码中引用不同的端点时就不必记住长串的 URL。它还为我们提供了许多关于如何构建路由和定义路由级参数的附加选项——这个组件有很大的灵活性。我建议查看文档，了解路由组件开箱即用的强大功能。整个应用的路由配置位于两个中心文件中(但是可以定制成任何您想要的结构):`routes/web.php`和`routes/api.php`。

在本书的后面，我们将通过将每一组定义的路由分离到我们的域模型中的相应模块中，来重新构建整个 Laravel 框架的目录和名称空间映射，使之更加领域驱动。我们将使用我们的域模型中定义的模块作为路由的直接“组”。在 Laravel 中，由于路由组件提供的健壮性和灵活性，这项任务变得很容易。

Note

如果您阅读了安装文档并决定使用`homestead`虚拟主机选项，那么您不需要我在本章中概述的安装过程，因此可以随意跳到下一节。

正如我前面提到的，路由不仅可以转发给控制器方法，还可以用*回调函数自定义。*想法是一样的:运行回调函数中的逻辑并返回某种类型的响应。下面是一个定义为闭合函数的简单路径示例:

```php
Route::get('/uri/something', function() {
     return 'You are at the path : /uri/something';
});

```

这是最简单的路线。它匹配 URL 字符串`/uri/something`并返回一个简单的“你在路径:/uri/什么地方。”你可以这样想，有一些 URI，在调用时，将返回回调函数的任何结果计算。它提供了与使用控制器相同的请求处理，并且它与使用控制器来定义特定路由的逻辑一样方便，所以实际上是由您和您的团队来使用。然而，我建议使用控制器来定义您的路由运行的逻辑，以便它与路由定义本身相分离。

如果您和我一样，不喜欢在一个(或多个)路由文件中混合路由配置和控制逻辑，您可以选择让路由将请求分派给控制器，在控制器中，您可以添加任何其他验证(稍后我们将看到)或定制逻辑，您需要这些来生成对请求的正确响应。

```php
Route::get('/uri/something', 'SomethingController@something');

```

我个人认为这是一个更好的方法，因为它没有用业务逻辑膨胀路由文件，而是使用控制器和路由文件方法，如下所示:

```php
/**
* Something Controller - something()
*/
Public function something()
{
     return 'You are at the path : /uri/something';
}

```

这实现了与闭合定义的路线相同的效果。

Note

当将请求路由到控制器时，关于路由应该被指定的方式有其他方法和理论。例如，Symfony 的做法是将您的“控制逻辑”和您的路由定义放在一起，但作为注释存在于控制器中，注释是代码的注释，可以被解析和使用。在这方面，将它们放在一起是有意义的，因为它们在不同的上下文中，而不是在 routes 文件中。我的观点是，它使用注释来验证参数和传入数据的方式太冗长了。Laravel 提供了一个比这更好更干净的解决方案，我将在本章后面演示。就这一点而言，注释极其丑陋，使代码看起来就像一开始就被注释掉的一堆乱七八糟的垃圾，所以乍一看并不总是很明显它们实际上在做什么。

我们有多条路线可以定义，做不同的事情。尽管不鼓励使用控制器来容纳核心域逻辑，但是将它们分组在一个控制器中可以保持关注点的清晰分离。记住，业务逻辑的适当位置是在域模型中；控制器位于域模型之外，负责通过请求与客户机“握手”，将需要完成的任何工作分派给其他组件，并返回指示请求成功或失败的响应。此外，最好使用控制器来定义路由的行为，而不是内联闭包函数，因为 Laravel 中的路由只有在路由定义中没有内联回调时才能被缓存。

#### 路由文件

路线存储在项目根目录下的`/routes`文件夹下的文件中。默认情况下，有几个不同的文件对应于应用的不同“侧面”(术语*侧面*来自六角形架构)。这些边一起形成了一个边界，将应用的业务逻辑封装在一个假想的形状(可能是六边形)中，域模型位于该形状的正中心，所有进入该形状的请求必须使用某种类型的适配器，以允许它们跨越边界进入应用。

在 Laravel 中，有一些开箱即用的不同路由文件。

*   这是面向公众的基于浏览器的路由。这些是最常见的，也是网络浏览器会碰到的。它们通过 web 中间件组运行，还包含 CSRF 保护功能(有助于抵御基于表单的恶意攻击和黑客攻击)，并且通常包含一个“状态”线程(我的意思是它们利用会话)以便在请求之间持久化数据。

*   `api.php`:这有对应于一个 API 组的路由，因此默认启用 API 中间件。这些路由是无状态的，没有会话或交叉请求内存(一个请求不与任何其他请求共享数据或内存；每一个都是自封装的)。API 路由通常位于授权机制(如承载令牌)之后，必须包含在每个请求头中。

*   这些路径对应于定制的 Artisan 命令，我们运行这些命令来生成 Laravel 组件的框架。稍后，我们将创建我们自己的 Artisan 命令，这些命令可以通过命令行运行，以构建许多快速且肮脏的过程，这些过程可以被调度或发送到消息队列。

*   `channels.php`:注册事件广播的路由。我们不会在本书中过多地讨论事件广播，但是 Laravel 确实为它提供了内置支持。要了解 Laravel 中事件广播的更多信息，请查看文档。

此时需要关注的主要文件是特定于浏览器的文件`web.php`。默认情况下，已经定义了一个路由，当用户导航到应用的 web 根目录(web 根目录位于公共目录中)或主页时，这个路由会被正确命中。值得一提的是，特定于 API 的路由并不适合返回一个要在浏览器窗口中呈现的完整 HTML 页面。API 通常有更简单的响应，通常由 JSON 编码的字符串和元数据组成，比如状态代码、可读消息或错误通知。这就是为什么有两个单独的路由文件。当您访问一个网页时，该路由来自于`web.php`路由文件。但是，如果您要在该页面上提交一个表单，您可能实际上会遇到一个 API route(在`api.php`)来执行表单的处理。我们需要三个不同的路径来运行我们的上传应用示例(见图 4-2)。

Note

如果我们想把显示上传表单*和*文件列表的所有逻辑放在一个页面上，可能不需要`/list`端点；然而，为了给我们的演示添加一些额外的上下文和范围，我暂时将它们分开。我们稍后将再次讨论这个问题。

让我们创建基本的 HTML 上传表单，从路由定义开始。打开你的`routes/web.php`文件，输入清单 [4-1](#PC10) 中的代码。

```php
// routes/web.php
Route::get('/upload', 'UploadController@upload')->name('upload');
Route::post('/process', 'UploadController@process')->name('process');
Route::get('/list', 'UploadController@list')->name('list');

Listing 4-1The Routes We Use in the Example file-uploader Application

```

对于每个所需的路由，我们使用一个可用的特定于 HTTP 的请求方法(`get()`、`post()`、`put()`、`patch()`、`delete()`和`options()`)在相应的路由文件(在本例中为`web.php`)中为其显式地创建一个单独的条目。要了解每一项的详细情况，请查看网站。这些方法的作用是指定允许哪些 HTTP 动词通过定义的 URI(或端点)访问给定的路由。如果您需要一个能够接受多个 HTTP 动词的路由(如果您使用一个页面来显示初始数据和提交的表单数据，就可能出现这种情况)，您可以使用`Route::any()`方法。一般来说，GET routes 用于提出问题或从应用中检索/读取一些数据，而 POST routes 用于提交应用中某些模型或数据结构的表单更新。PUT 用于创建模型或数据库实体新实例。

这些路由定义的第一个参数是您希望访问路由的 URI 或端点(web 服务器上的物理位置)。`Route::get()`和`Route::post()`方法(`Route` facade 支持的任何其他 HTTP-verb 相关方法)的第二个参数是代码的位置，该代码在使用允许的 HTTP 动词(GET、POST、PATCH 等)到达路由端点时执行。).Laravel 提供了一种简单的方法来指定路由器将转发请求的控制器/控制器方法组合。我们将`UploadController`用于所有三条路线，并以下列方式指定它们:

```php
Route::get('/upload', '{CONTROLLER_NAME}@{CONTROLLER_METHOD}`)

```

我们在每个路由上调用的最后一个方法是它的`name()`函数，该函数接受单个字符串作为参数，并用于用一个容易记住的名称(在我们的例子中是 upload、process 和 list)或多或少地“标记”一个特定的路由。我意识到，当 URL 名称相同时，给每个路由起自己的名字似乎不是一个很好的特性，但当你有一个像`/users/profile/dashboard/config`这样的特定路由时，它确实很方便，因为它更容易被记住为`profile-admin`或`user-config`。

Note

Laravel 的许多组件上都提供了这种方法链，允许您以一种非常类似英语的易用方式调用返回对象上的其他方法。这就是所谓的*流畅界面*。下面是一个来自 Laravel 迁移的例子，它用于定义和跟踪数据库模式的变化(在下面的例子中，我们定义了一个外键约束):

`$table->foreign('user_id')`

`->references('id')->on('users')`

`->onDelete('cascade');`

正如您所看到的，方法链接的“语言”构成了一个完整的英语句子，这通常比任意的方法名称更容易记忆。

##### 关于立面的一个注记

> **外观* *为应用的服务容器中可用的类提供一个“静态”接口。**

 *> *"它们提供了一种简洁、易记的语法，允许您使用 Laravel 的特性，而无需记住必须手动注入或配置的长类名。*
> 
> —旅行证件

在前面的路由定义中，我们使用路由外观，而不是手动实例化一个新的`Illuminate` / `Routing` / `Router`对象并在该对象上调用相应的方法。只是省打字的捷径。Laravel 框架中大量使用了外观；你可以也应该更熟悉他们。立面文件可在 [`https://laravel.com/docs/6.x/facades`](https://laravel.com/docs/6.x/facades) 找到。如果你不喜欢 facades，你可以使用静态方法调用来代替。

### 生成控制器

闲话少说(虽然这本书主要是 PHP，而不是 small talk)，让我们继续并生成控制器，它将成为应用层的一部分，作为处理请求的机制，即接受请求并返回响应。这是所有控制器都应该做的！

值得重复的是:以下是管制员应该做的*唯一*的事情:

*   *接受请求*:路由将一个 URI 连接到一个通用或特定的`Request`对象，其数据在被自动注入到路由中定义的控制器方法之前*被验证(通过简单地在控制器方法中类型提示请求对象来完成)。请求/响应生命周期的这一部分也可以被认为是客户端和应用之间的握手式机制。*

*   *返回响应*:在分派工作(很可能是以作业、命令或其他可操作的域对象或外观的形式)之后，需要根据用户访问系统的特定方法给请求用户一个响应。例如，对 web 应用提供的 API 的调用通常需要某种 JSON 编码的响应，带有可读的成功消息、HTTP 状态代码，可能还有一些关于请求状态的附加数据。另一方面，对浏览器请求的响应可能是一系列不同的 HTML、CSS 和 JavaScript 代码，由浏览器解析并显示在窗口中。

好消息是，Laravel 提供了易于使用的设施来完成所有这些甚至更多！为了获得控制器的基本结构，我们可以使用这个例子，从项目的根目录中运行以下命令:

```php
// inside the directory "ddl/"
php artisan make:controller UploadController

```

本质上，这个命令在主控制器目录中的`/app/Http/Controllers/UploadController.php`处为名为`UploadController`的控制器生成一个*存根*。打开来看一看。这很简单，因为它只是控制器的一个存根版本，具有正确的名称空间路径和它所扩展的必需类(参见清单 [4-2](#PC13) )。

```php
// ddl/app/Http/Controllers/UploadController.php

<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class UploadController extends Controller
{
    //
}

Listing 4-2Generated Controller Stub From

```

### 生成请求

在我们继续对`UploadController`生成的存根进行一些更改之前，让我们一次生成所有的搭建代码。这样，我们可以获得整个过程的清晰、高层次的画面，而不会迷失在使其内部工作的更细粒度的细节中。

Note

理解表单请求和请求对象之间的区别很重要。一个*表单请求*是一种特定于标准 HTML web 表单的请求，包含提交的数据和任何附件，以及请求的`rules()`方法中指定的验证需求。另一方面，request 对象是 Laravel 对 Symfony request 对象的扩展，它封装了一个真正的 HTTP 请求(例如，通过一个`curl`命令),并用易于使用的访问器和操纵器对其进行打包(稍后将详细介绍),还包含诸如头信息、查询参数、请求体参数、cookies、会话值、HTTP 动词、URL 和引用 URL 等数据。

处理请求的控制器方法必须在其签名中键入特定请求类的提示。Laravel 中有一些快捷方式可以让您访问令人惊叹的验证特性，针对诸如请求验证、数据库验证和参数验证等问题，它们让我们有机会使用`Illuminate\Contracts\Validation`契约的实现来创建额外的复杂域级验证。(在本章的后面你会学到更多。)现在，让我们再次使用 Artisan 命令来生成我们的请求存根。

```php
php artisan make:request UploadFileRequest

```

这个命令将在`app/Http/Requests/UploadFileRequest`中生成一个名为`UploadFileRequest`的文件。打开存根看一眼。你会发现它很简单，只包含两种方法，`authorize()`和`rules()` `.`

我们刚刚生成的内容被称为*表单请求*。这意味着从 HTML 表单中捕获任何传入的数据，根据我们指定的验证检查来验证传入的数据，并将其注入到一个可以使用或修改它的控制器方法中(尽管由于请求是不可变的，所以不建议使用后者)。

清单 [4-3](#PC15) 展示了生成的请求开箱后的样子。

```php
// ddl/app/Http/Requests/UploadFileReq    uest.php
<?php
namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class UploadFileRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return false;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            //
        ];
    }
}

Listing 4-3A Generated Form Request Stub

```

#### 定制生成的请求

让我们修改前面的请求存根，以满足我们的应用的需要。脚手架代码很好，因为它允许你基本上原型化你需要的各种组件，使你的应用做你需要它做的事情。

#### 创建验证逻辑

打开`UploadFileRequest`文件，将其更改为清单 [4-4](#PC16) 。

```php
// ddl/app/Http/Requests/UploadFileRequest.php

<?php

namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class UploadFileRequest extends FormRequest
{
    /**
    * Determine if the user is authorized to make this request.
    *
    * @return bool
    */
    public function authorize()
    {
        // NOTE: This is a convenient location to include any auth
        // checks or other authentication logic specific to this
        // specific form request.

        return true;
    }

    /**
     * Get the validation rules that apply to the request. It is here
     * that we specify how we want the data to be structured and what
     * it should look like.
     *
     * @return array
     */
    public function rules()
    {
      return [
           'fileName' => 'required|string',
           'userFile' => 'required|file'
       ];
    }
}

Listing 4-4Modified Request Stub for Our Upload Application

```

清单 [4-4](#PC16) 没有太多变化。首先，`authorize()`方法现在返回 true 而不是 false。该方法负责允许请求传入应用。如果评估结果为 false，它将阻止请求进入系统(即，不将请求传递给路由中定义的相应控制器方法)，而是返回某种错误响应。同样，这个响应将是特定于请求类型的:web、API 或。这将是一个方便的地方，可以对用户或任何其他逻辑进行授权检查，以确定请求是否可以前进到控制器方法，在控制器方法中处理请求并返回响应，或者，逻辑可以确定请求无效，而是发出带有 4xx 或 5xx 状态代码的错误响应(指示“未找到”错误或服务器问题)， 这可以使用特定的`Exception`类在后端记录错误来描述，但也可能在浏览器上显示为一般的错误页面。

现在，我们只需在这里返回 true，以允许任何东西使用请求，但这也是添加身份验证逻辑和其他与身份验证或授权相关的验证检查的好地方。请参阅下一节中更深入的示例。

另一个方法是`rules()`，这是验证的神奇之处。想法很简单:返回一个包含一组规则的数组，格式如下:

```php
'formFieldName' => 'pipe-delimited validators'

```

Laravel 支持各种现成的约束。如需完整列表，请查看在线文档 [`https://laravel.com/docs/6.x/validation#available-validation-rules`](https://laravel.com/docs/6.x/validation%2523available-validation-rules) 。对于我们的上传应用，将有两个字段通过来自前端表单的 POST 请求传递。`fileName`参数必须包含在表单主体中(即必需的),并用作我们将在存储器中存储文件的文件名(这在控制器中完成——我们稍后会用到它)。我们还通过添加管道字符(`|`)和单词`string`来指定文件名必须是一个字符串。约束总是由管道分隔，允许您在一行中为给定字段指定许多附加条件。这是一些强大的东西！

第二个参数`userFile`，是用户从网页上的表单上传的实际的*文件*。`UserFile`也是必需的，必须是文件。

Note

如果我们期望上传的文件是一个图像，那么我们将使用 image 约束，这将限制文件类型为最流行的图像类型之一(JPEG、PNG、BMP、GIF 或 SVG)。由于我们希望允许用户上传任何类型的文件，我们将坚持文件验证约束，而不检查扩展名。这是一个有效的安全措施还是一个潜在的安全缺陷，我们现在通过指定我们的应用所接受的允许的文件扩展名的类型来引入它？我将在“更大的图片”一节的后面讨论这一点，但是，更具体地说，我将在接下来的“使用 MIME 类型来验证上传的文件”一节中演示如何使用 MIME 类型来验证文件是否如它们所声称的那样。

关于请求对象的`rules()`方法需要注意的另一点是，如果由于某种原因我们省略了一个我们*希望*在请求中验证的参数，它显然不会有任何要求，并且会与用户使用表单提交的其他参数一起传递给控制器。只有当您在请求的`rules()`方法中指定表单中的所有字段以及它们的约束时，自动验证才会正确工作。此外，当您在`rules()`方法中包含一个不存在于表单传入值中的参数时，Laravel 将停止请求，因为它不符合相应路由定义中定义的控制器方法。

这就是请求对象的全部内容。它的主要工作是简单地保存一组可接受的标准(约束)，表单的主体参数必须满足这些标准才能更深入地应用。另外需要注意的是，这两个字段(`userFile`和`filename`)也必须以输入字段的形式在 HTML 代码内部指定(字段名对应请求对象内部的名称)。

您可能会问:当然，这定义了表单请求应该包含的特征，但是在哪里执行对这些约束的实际检查呢？我们将通过使用我们的请求中配置的验证，发现以自动化方式执行这些检查的最佳方式；但是，手动执行身份验证检查的方式如下所示:

```php
   $validatedData = $request->validate([
        'fileName' => 'required|string,
        'userFile' => 'required|file',
    ]);

```

#### 定制生成的控制器

我们准备定制控制器逻辑。打开`app/Http/Controllers/UploadController.php`并修改它，使它看起来像清单 [4-5](#PC19) 中列出的那个。请记住，如果您按照示例进行操作并手动输入应用，您不必担心转录注释，因为我在本书中没有使用注释来实现任何特殊功能。为了更有用的东西，避免额外的击键。然而，在生产环境中，或者在已发布语言或 API 文档的一部分中，文档块应该包含在每个类、方法和包中。

```php
<?php
namespace App\Http\Controllers;

use Illuminate\Contracts\Container\BindingResolutionException;
use Illuminate\Http\Request;
use App\Http\Requests\UploadFileRequest;
use Illuminate\Support\Facades\Storage;
class UploadController extends Controller
{
    /**
     * This is the method that will simply list all the files uploaded
     * by name and provide a link to each one so they may be
     * downloaded
     * @param $request : A standard form request object
     * @return \Illuminate\Contracts\View\Factory|\Illuminate\View\View
     * @throws BindingResolutionException
     */
     public function list(Request $request)
     {
          $uploads = Storage::allFiles('uploads');
          return view('list', ['files' => $uploads]);
      }
    /**

     * @param $file
     * @return \Symfony\Component\HttpFoundation\BinaryFileResponse
     * @throws BindingResolutionException
    */
    public function download($file)
    {
        return response()->download(storage_path('app/'.$file));
    }
    /**
     * @return \Illuminate\Contracts\View\Factory|\Illuminate\View\View
     * @throws BindingResolutionException
     */
     public function upload()
     {
        return view('upload');
     }
    /**
     * This method will handle the file uploads. Notice that the
     * parameter's type-hint is the exact request class we generated
     * in the last step. There is a reason for this!
     *
     * @param $request : The form request for uploading a file
     * @return array | \Illuminate\Http\UploadedFile |
     * \Illuminate\Http\UploadedFile[] | null
     * @throws BindingResolutionException
     */
     public function store(UploadFileRequest $request)
     {
          $filename = $request->fileName;
          //the request is valid at this point because of the defined
          //parameters we specified in the form request
           $file = $request->file('userFile'); //no isset() req’d

          //retrieve the original extension of uploaded file
           $extension = $file->getClientOriginalExtension();
          //create a new file name
           $saveAs = $filename . "." . $extension;
          //save the file to the local filesystem, inside uploads/
           $file->storeAs('uploads', $saveAs, 'local');
          //return a success message
          return response()->json(['success' => true]);
    }

}

Listing 4-5The Modified UploadController That Handles the Persistence of the Uploaded File

```

因此，这是一个相当简单的方法来保存上传到磁盘的文件。下面是对`upload()`方法的分析:

1.  在执行重要功能的控制器方法中键入提示请求类，这样我们就可以自动验证传入的数据。

2.  从控制器方法内的请求对象中获取文件(现在已经过验证)。

3.  从请求中获取文件名。

4.  生成将用于保存文件的最终文件名。`getClientOriginalExtension()`方法检索上传文件的原始上传扩展名(当然，如果您猜不出名字所隐含的明显功能)。

5.  使用其`storeAs()`方法将文件存储到本地文件系统，将`/storage`目录中的命名路径作为第一个参数，将文件名作为第二个参数。

6.  返回一个表明请求成功的 JSON 响应。

控制器中还包括一些方法来促进浏览器和应用之间的用户交互，例如下载给定的文件、查看过去上传的文件列表，或者在用户可以访问的页面上显示表单。

图 [4-1](#Fig1) 显示了正在发生的事情。

![img/488324_1_En_4_Chapter/488324_1_En_4_Fig1_HTML.jpg](img/488324_1_En_4_Chapter/488324_1_En_4_Fig1_HTML.jpg)

图 4-1

整个应用的概述，包括请求和响应

这种设计是可行的，但并不完美。仍有改进的余地。你能认出是哪里吗？如果你不能，我会给你一些提示(这样你就可以更好地处理现实生活中发生的这类事情)。我能给你的最重要的建议之一是:养成依靠最佳实践的习惯，熟悉设计模式、架构模式和核心软件设计原则，这样当你陷入困境或对如何构建应用感到困惑时，你就有地方可去了(正确的答案是与领域模型一致)。

如果你还记得在这一章的前面，我反复强调控制器应该被限制做两种可能的事情之一:接受一个请求或者返回一个响应。我之前创建的控制器确实可以工作，但是问题在于违反了核心软件设计原则:关注点分离。控制器的`store()`方法包含保存上传文件所涉及的实际业务逻辑(完整地！)时，它实际上应该与控制器分离，作为域模型的一部分。在中心主题中存在多个关注点的事实暗示了它们应该位于除了与控制器内联之外的其他地方。这里有几个例子:

*   为上传的文件创建一个新文件名，然后在新文件上附加与上传文件相同的扩展名

*   指定特定文件系统上的位置

*   指定要保存文件的文件系统

如果我们想要更改这些内容，我们必须在控制器中进行，这并不理想，因为使用它的客户端可能每次都期望相同的响应，如果我们不断更改逻辑的这一部分，这是不可能的，因为对于每个实现，依赖于它的调用代码也必须每次都更改。

这里要注意的另一件事是，尽管我们为从表单(通过表单请求)传递到应用的数据设置了适当的验证，并且确信数据在到达控制器的`store()`方法时应该是好的，但是我们没有对文件实际上成功保存进行额外的验证。按照现在的情况，如果文件没有正确保存到文件系统中，并且这导致了一个无声的错误，该错误记录到日志中，而不是显示在屏幕上，那么您将没有任何迹象表明保存上传文件实际上没有发生，并且会继续假设一切都很好，因为从该方法返回的唯一响应是一个基本的 JSON 类型的 API 响应， 只有打开您最喜欢的 web 浏览器的开发者工具插件并在一堆网络调用中搜索才能看到，这对于现实世界中的实际实现来说是完全低效的。 我们实际上缺乏对保存到指定文件系统的文件的任何验证。因为我们是专业的、高技能的(非常帅的)开发人员，他们欣赏他们工作的质量，我们会克服这个缺点并改正它。

如果这段时间还有其他事情困扰着你，那可能是因为我们使用了控制器的方法体来容纳我们对应用的主要关注:接受、验证和存储上传文件的过程。这些是应该在*领域模型*中处理的*领域关注点*。有许多不同的方法来处理这种情况。

让我们从`UploadController`中的`upload()`方法体内的逻辑错位开始。我们知道在这个控制器中发生了太多的事情，所以我们决定将涉及将上传的文件保存到存储器的域*逻辑*分开，我们将从我们的控制器内部委托一个调用。有许多其他方法可以解决这个问题，这将迫使我们将文件处理和存储逻辑下推到域层。我将重点介绍几种方法来做到这一点(还有许多其他方法也可以做到这一点)。

我们可以选择实现某种命令总线。本质上，命令总线是一种设计模式，它有两个组件，用于促进涉及应用服务层的操作，以及促进应用的响应:`Command`对象和`Handler`对象。`Command`对象只是保存一个用户请求(或客户端请求)，所有参数和传入的用户数据都封装到这个`Command`对象中——这就是“是什么”。`Handler`组件是执行者(或如何做),它封装了任何直接响应`Command`对象请求的逻辑。理论上，每个`Command`都有一个特定于那个`Command`对象的处理程序对象。可以把处理程序看作是执行封装在`Command`对象中的请求的一种方式。

由于命令总线架构的流行，出现了几个 PHP 特定的库，它们处理各种主题和工作命令总线的输入和输出。他们是百老汇( [`https://github.com/broadway/broadway`](https://github.com/broadway/broadway) )和战术家( [`https://tactician.thephpleague.com/`](https://tactician.thephpleague.com/) )。这两个包都写得很好，有高质量的代码和支持它们的测试，如果你要建立一个完整的命令总线管道，有事件源、CQRS 支持、事件重放和预测，你可能要考虑看看百老汇，因为它支持所有这些，甚至更多。

另一方面，如果您正在寻求实现一个更小的基于微服务的架构，该架构将具有基本的命令和处理程序设置，用于相对少量的最近可能的请求和响应，那么 Tactician 可能是一个更好的选择。战术家在磁盘上有一个小尺寸，是超级快速，有效，易于学习。它支持各种不同的中间件(或者您可以推出自己的中间件),并支持自定义扩展点，例如日志记录、缓存以及对触发和跟踪事件的支持。

非凡软件包联盟是一个为 PHP 社区创建和维护战术家和其他高质量独立软件的组织。你可以在这里找到它们，以及非常高质量的文档: [`https://thephpleague.com`](https://thephpleague.com/) 。

处理这种情况的另一种可能方式是将与处理和存储通过表单上传的文件相关的代码放在一个*域服务中。*每当我们对系统以及系统与我们的领域对象的交互进行建模时，对于我们向所有应用组件提出的基本问题，并不总是有一个简单明了、万无一失的答案:它是什么，它属于哪里？如果它不是一个东西，而是属于业务流程的范畴，那么就创建一个服务来封装业务逻辑，并从控制器中调用它，传递完成请求所需的任何变量或数据。然后，服务执行自己的任务，或者将结果返回给控制器，然后返回给客户端，或者将结果写入单独的日志，甚至将事件记录到任务或消息队列中。

另一个可能的解决方案是创建一个*职位。*作业存在于领域模型中，并作为独立的工作单元运行，可以从代码库中的任何地方调用。Laravel 完全支持创建和管理作业，甚至有一个单独的预建应用，它提供了一个强大的 UI，允许管理员以可视化的方式查看和管理系统中运行的不同作业。我们将在后面的章节中深入研究作业，但有一点需要注意(像 Laravel 中的大多数其他东西一样),有一种生成作业的机制，它将通过 Artisan 命令生成一个通用`Job`类的脚手架。在本章后面的“使用 Laravel 作业封装业务逻辑”一节中，我们将讨论一个这样的作业的可能实现

Using Mime Types to Verify Uploaded Files

我想后退一步，重新审视一下系统接受未经验证的文件类型的问题。在我们的系统中，除了回答最简单的问题“它是一个文件吗？”之外，基本上没有其他验证这应该是一个非常响亮的信号，表明需要额外的安全性，这样我们就不会因为对允许用户上传的文件类型过于宽松而在系统中造成巨大的安全漏洞。

假设验证文件扩展名提供了某种程度的安全性来防止恶意文件进入系统，则可以并且应该对其进行验证，以便“剔除”除了附加了特定扩展名的文件类型之外的任何文件类型。然而，除了防止合法用户选择错误的文件之外，它并不能很好地防止用户上传恶意文件。在通过 web 表单上传已知恶意文件之前，人们可以很容易地更改其扩展名。在没有任何适当验证的情况下，理论上，用户可以将包含蠕虫算法的文件上传到我们的系统，因为我们决定不实施更高级的方法来验证文件的真实类型。

Laravel 确实为我们提供了一些工具，我们可以利用它们来增强应用的安全性。我们需要通过使用其声明的 MIME 类型来验证传入的文件，以确定真正的文件扩展名(与在文件名中提供的对应于最后一个句点之后的所有内容的扩展名相反，这对于用户来说很容易更改，就像在上传文件之前重命名文件一样)。然后将从文件中提取的扩展名类型与由文件名后缀指定的文件扩展名进行比较。

当在名为`putFileAs()`的`File` facade 上使用一个方法或者通过调用直接位于请求内的文件上的`store()`方法时，这是自动完成的。

```php
//calling the store() method in a chain-like manner from the request
$path = $request->file('customers')->store('customers.csv');

//explicitly using putFileAs() on the Storage facade
Storage::putFileAs(‘customers’, new File('/path/to/customers'), 'customers.csv’);

```

这样做的唯一问题是，得到验证的 MIME 类型实际上是从有问题的文件所指示的 MIME 类型中获得的，可以很容易地修改它，使其看起来像是其他类型。Laravel 提供了一个 MIME 类型验证，我们可以使用它来尝试从文件的内容中猜测任何给定文件的 MIME 类型，而不是依赖于它的元数据。我们所要做的就是在表单请求对象的`rules()`方法中添加以下内容:

```php
//in ddl/app/Http/Requests/UploadFileRequest.php

//replace the rule for userFile to look like the following in the
public function rules() {
//...
'userFile' => 'mimetypes:video/avi,video/mpeg,video/quicktime,image/bmp,image/jpeg,image/gif'
//...

```

重要提示:虽然这为我们的应用提供了额外的安全性，但作为一种折衷，我们确实损失了一些灵活性，因为所做的更改将文件的 MIME 类型限制为键`userFile`处的`rules()`方法中列出的受支持的视频或图像格式之一。这是一场永无止境的斗争，你将在现实世界中不断面对:*安全与便利*。我们将在后面的章节中更深入地讨论这一点。

### 刀片模板

我们需要的应用的最后一部分是在浏览器中实际显示表单并处理所有 Ajax 调用的部分，这些调用实际执行提交表单和将文件上传到服务器所需的逻辑。在`ddl/resources/views/upload.blade.php`位置创建一个新文件(列表 [4-6](#PC22) )。

```php
<-- ddl/resources/views/upload.blade.php -->
<body>
   <h1>Upload a file</h1>
   <form id="uploadForm" name="uploadForm"
action="{{route('upload')}}" enctype="multipart/form-data">
       @csrf
       <label for="fileName">File Name:</label>
       <input type="text" name="fileName" id="fileName" required />
         <br />
         <label for="userFile">Select a File</label>
       <input type="file" name="userFile" id="userFile" required />
       <button type="submit" name="submit">Submit</button>
   </form>
   <h2 id="success" style="color:green;display:none">Successfully uploaded file</h2>
   <h2 id="error" style="color:red;display:none">Error Submitting File</h2>
   <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
   <script>
        $('#uploadForm').on('submit', function(e) {
            e.preventDefault();
            var form = $(this);
            var url = form.attr('action');
            $.ajax({
                url: url,
                type: "POST",
                data: new FormData(this),
                processData: false,
                contentType: false,
                dataType: "JSON",
                success: function(data) {
                    $("#fileName").val("");
                    $("#userFile").val("");
                }
            }).done(function() {
                $('#success').css('display', 'block');
                window.setTimeout(()=>($("#success").css('display',
                'none')), 5000);
            }).fail(function() {
                $('#error').css('display', 'block');
                window.setTimeout(()=>($("#error").css('display',
                'none')), 5000);
            });
        });
   </script>
</body>
</html>

Listing 4-6The Blade Template

```

这是一个包含 HTML 表单和 JavaScript/jQuery 的刀片文件的典型示例，用于添加异步功能(因此我们可以调用服务器端点并从这些调用中接收数据，而无需刷新当前页面)。有一个基本的`<form>`标签，没有方法属性(我马上会解释)，有一个奇怪的`action`属性，值为`{{route('file.upload')}}`。在刀片中，这就是所谓的*指令*。指令只是函数的一个花哨名字；有一些特定于刀片模板的函数，这些函数执行不同的操作，这些操作对于构建网页和 web 应用是常见的。为了更好地理解 blade 可以做的所有很酷的事情，请查看 [`https://laravel.com/docs/6.x/blade`](https://laravel.com/docs/6.x/blade) 。在前一个例子中，我们使用 route 指令为表单提交生成一个 URL。

请记住，我们之前在应用的`web.php`文件中定义了我们的路线，为每条路线指定了一个容易记住的名称。`{{route()}}`指令接受一个路由的名称，在内部缓存的路由列表中查找，并基于`web.php`文件中该路由的定义生成一个完整的 URL。对于第一种情况，我们指定希望表单将其提交的数据发送到`/process`端点，这被定义为 POST 路由。

您可能已经注意到的下一个奇怪的事情是开始表单标签下面的`@csrf`标签。在 blade 中，这个标签在表单上生成一个`_token`参数，在允许处理表单数据之前，在应用内部对这个参数进行检查。这可以确保表单中的数据来源有效，并防止跨站点请求伪造攻击。有关这方面的更多信息，请参见 [`https://laravel.com/docs/6.x/csrf`](https://laravel.com/docs/6.x/csrf) 。

Note

如果我们在前面的模板中省略了`@csrf`标签，Laravel 将不接受表单，而是返回一个“419: Page Expired”错误*，除非*您将表单所在的特定页面添加到位于`app/Http/Middleware/VerifyCsrfToken`的`VerifyCsrfToken`中间件的`$except`属性中，就像这样(在我们构建的示例项目中不要这样做；这仅用于演示):

```php
//inside VerifyCsrfToken.php
/**
 * The URIs that should be excluded from CSRF verification.
 *
 * @var array
 */
 protected $except = [
    '/payment-gateay-url'
 ];

```

现在，您应该能够使用以下命令启动本地开发服务器:

```php
php artisan serve

```

这应该会给您一个类似于下面的消息:

```php
Laravel development server started: <http://127.0.0.1:8000>

```

当您在浏览器中导航到此页面时，您将看到屏幕上显示的 Laravel 默认启动页面。继续并导航至`http://127.0.0.1:8000/upload`在屏幕上查看基本表单。填写某种类型的文件名，从您的计算机中选择任何类型的文件用于上传输入，然后单击 Submit。一旦你这样做了，你应该在屏幕上看到我们前面定义的成功消息，或者你可能会得到错误消息，如果事情不顺利(无论什么原因)。

需要注意的是，如果在提交表单后收到“403 : Unauthorized”错误，很可能是因为您忘记将表单请求的`authorize()`方法改为返回 true 而不是 false。

如果由于某种原因，您没有看到您期望看到的内容，或者如果表单过程由于某种原因失败，请确保您转录到自己的编辑器中的所有代码都是正确的。可能还有一些其他潜在的故障点，我们在编写这个功能时没有想到或预料到。这是对现实世界中 web 开发的准确描述。我们得到一个需求列表，通过对话和会议来确定*确切的*需求，设计*满足*这些需求的方法，并构建解决需求的解决方案的实现。当我们在软件中为一个请求编写规格说明时，我们不可能想到所有可能发生在这个请求上的事情。简直不可能。

相反，我们剩下的是依靠好的编程标准和最佳实践。在这种情况下，我们需要记住应用的概念是*迭代开发*，或者对应用进行小的、增量的更改，以在代码中充实所有的需求。

## 大局

让我们看看我们做了什么。

您应该还记得，我们在本教程开始时构建的请求对象应该在它的 rules 方法中定义了与 blade 模板中的表单相同的参数(如果没有，请重新阅读“创建验证逻辑”一节)。用户填写位于`/upload`的网页上的表单，该表单通过刀片模板引擎呈现并提交。模板底部的 jQuery 代码停止默认提交(它将自动重定向到表单的`action`参数中指定的页面)，创建一个 Ajax POST 请求，加载带有表单数据和上传文件的请求，并将整个内容发送到我们的应用中，应用创建内部使用的请求对象，该对象被提供给包含该端点逻辑的 route 或 controller 方法。

通过将`rules()`方法中的参数与提交的表单参数相关联来填充请求对象，然后根据每个指定的规则验证数据。如果满足所有规则，请求将被传递给与路由文件`web.php`中定义的值相对应的任何控制器方法。在这种情况下，是`UploadController`的`process()`方法在起作用。一旦我们点击控制器，我们已经知道请求通过了验证，所以我们不必重新测试给定的文件名是否实际上是一个`string`或`userFile`参数实际上保存了某种类型的文件。我们可以像平常一样继续。

然后，控制器方法从请求对象中获取经过验证的参数，通过将传入的参数`fileName`与`userFile`的原始扩展名连接起来生成文件名，将文件存储在应用的目录中，然后返回一个简单的 JSON 编码的响应，验证请求是否成功。

A Note on Security Concerns

问题:我们已经实现的系统(到目前为止)中，有没有哪个部分引起你的注意，成为错误或混乱的潜在来源？

答:除了很可能有效但未在此列出的其他问题之外，还有以下我们在应用中尚未考虑或防范的场景:

*   安全问题
    *   应用中没有用户级的授权，尽管一个可能的解决方案是实现一个策略，我将在本章后面的“验证表单请求和使用策略”一节中的示例中简要讨论这个问题。

    *   表单请求中缺少指定的约束，尤其是围绕上载到服务器的文件。如果保持原样，将不会有检查来保证文件不包含恶意软件或某种类型的僵尸网络复制软件。检查扩展只能帮你完成一部分。这个问题的解决方案可以在本章前面的“使用 MIME 类型验证上传的文件”一节中找到。

*   持久性问题
    *   一个不太明显的问题是表单中的另一个用户输入参数。`fileName`，必输字符串，是保存的文件进入系统后的对应名称。就目前的情况而言，用户可以提交任何有效的字符串，只要它既不是空的也没有被省略，我们的应用将很乐意接受它，验证字符串，并尝试使用它在给定的文件系统中保存文件。这个文件系统可能是一个 Dropbox 帐户，也可能是硬盘上的一个本地位置——我们不知道。因此，这些平台都对文件的命名方式、文件名的长度以及组成文件名的字符集有一定的限制。这个问题的一个解决方案是利用 Laravel 的漂亮的`League\Flysystem\Util::normalizePath()`方法，只需在定义了`$filename`变量之后，向`UploadController`的`store()`方法添加以下代码。

*   建筑问题
    *   业务逻辑的位置(它存在于控制器本身中)抛出了一面红旗，它尖叫着“重构我”，因为它明显忽略了关注点的分离。与业务或底层领域相关的最重要的逻辑应该移到领域层内的其他地方。控制器位于应用层，而域逻辑应该被分成...嗯，一个领域层。

**注**我鼓励你去看看非凡包联盟的 Flysystem 库中其他很酷的类似忍者的工具，我之前已经给你介绍过了。以防你忘记，这是他们的网站，特别是他们的 Flysystem 库，它帮助管理和执行对某些类型的支持文件系统的修改和添加: [`https://flysystem.thephpleague.com/docs/`](https://flysystem.thephpleague.com/docs/) 。

```php
$filename = League\Flysystem\Util::normalizePath($filename);

```

这一行简单的代码接受一个给定的字符串，并基于一个内部过程对其进行修改，该过程去除任何非法字符，并将字符串限制在特定长度，以便它可以用作正在上传的文件的有效名称。这样做的唯一缺点是，因为用户在表单中指定了文件的名称，所以他们会希望文件的名称与他们输入的名称完全一样，除非在提交文件后他们得到通知。我们可以通过多种方式解决这个问题，包括简单地通知用户文件以不同的名称存储，因为他们提供的名称无效，并且在响应中包含他们文件实际存储的名称。另一种解决方案是甚至不允许用户命名文件，而是生成文件名，然后将生成的文件名与拥有它的用户的 ID 和文件在文件系统上的位置一起存储在关系数据库中。清单 [4-7](#PC27) 显示了一个可能的解决方案，它实现了给定上传的自动生成的 ID 号，而不是允许用户指定 name 参数。

```php
//in ddl/app/Http/Controllers/UploadController.php

use App\UserUpload;
use Illuminate\Support\Facades\Auth;
//..
class UploadController extends Controller
{
     public function store(UploadFileRequest $request)
     {
           $file = $request->file('userFile')
           //save the file to the local filesystem, inside /uploads
           //*NOTE*: this also runs the MIME type check automatically:
           $path = $file->store('uploads');

           // $path will be a string returned from the store() method
           // corresponding to the saved path of the uploaded file
           $upload = UserUpload::create([
                 'user_id' => Auth::user()->id,
                 'filename' => $path,
                 //a way to track the source of the uploaded file
                  ‘form_id’ => $request->form_id //this is arbitrary
           ]);
           //return a success message
          return response()->json(['success' => true, ‘upload’ =>
                 json_encode($upload)]);
    }
}

Listing 4-7Possible Solution

```

jQuery 逻辑(驻留在 blade 模板中，在后面的示例中显示)接收响应，它执行一些与 UI 相关的任务，比如显示成功(或错误)消息五秒钟，然后隐藏它，并清除以前的表单条目。这是为了让用户确信请求成功，如果他们愿意，可以上传另一个文件。

另外，请注意图 [4-1](#Fig1) 中客户端和服务器之间的分界线。理解这个概念对您来说绝对是至关重要的，它将帮助您解决将来在处理各种问题时可能遇到的难题，例如，在任何给定的时间都可能出现多个异步请求。

通过一个请求对象，客户端关注点与服务器端关注点的分离就存在于我们应用的边界。请求对象本身可以被认为是客户端希望对我们的应用采取的操作，路由以某种方式使用这些操作来生成响应并返回给客户端(用户)，从而完成请求/响应生命周期。它通过运行我们在`FormRequest`的`rules()`方法中指定的验证，自动对从 web 浏览器传入的表单值进行初始验证和注册。

如果它们被认为是有效的，那么它们将被传递给控制器(或者路由定义的主体，如果它配置了闭包函数的话)。之前的一切都在前端(“客户端”字面意思是“在用户的计算机上”)。响应从应用返回到客户端，在客户端，我们的 jQuery 代码耐心地监听它的到达，并在收到响应后执行一些简单的 UI 任务，以便正确地通知用户请求成功或发生了错误。

## 其他注意事项

在本章的第一部分，我想把重点放在这个示例项目的核心功能上，以便让您清楚地了解这个过程是如何在一个较高的层次上完整地工作的，而不要过多地涉及这个项目在现实世界中开发时会遇到的细节和考虑事项。然而，在这样做的时候，我忽略了一些重要的部分，在现实世界的实现中，这些部分是需要纠正的。例如，在`list()`方法中，我们只是抓取特定目录中的所有文件，并将它们全部显示给最终用户。在现实生活中，我们显然不想公开显示其他用户的文件。在这种情况下，我们可能会选择以特定的格式保存文件，以便轻松地确定文件属于哪个用户。下面是一个文件名格式，它允许我们确定哪些文件属于哪个用户:

```php
{user-specified-file-name}.{userId}.{extension}

```

通过将用户 ID 硬编码到文件名中，我们可以确定每个文件的所有者。然而，这种方法会有一些其他的问题。如果我们考虑到应用可能包含许多用户和数百个文件，我们将不得不遍历给定目录中的每个用户和文件，以便按所有者来分隔文件。更好的方法可能是允许每个用户拥有自己的私有目录，该目录以标准格式命名，可能包括他们的`user_id`或用户名来标识每个用户。这样，我们就可以按名称查找目录，并返回该目录中存在的所有文件的集合。

更复杂的方法是在关系数据库表中存储一条记录，该表基本上将每个文件链接到其对应的所有者(很可能通过`user_id`字段上的外键)。这将是我们解决这个问题的最好方法，因为我们不需要在一个目录上执行 glob 并遍历每个文件，然后检查哪个文件名与哪个`user_id`匹配，我们可以简单地发出一个查询来获取属于给定用户的所有文件名，并使用文件的路径来显示每个文件名的链接，然后用户可以单击并下载或接收关于这些文件名的元数据。

这是现实生活中的应用在某个时候会出现的东西(也就是说，将文件保存在磁盘上，甚至保存在离站存储中，并通过某种类型的接口管理文件`)`)。 [`https://laravel.com/docs/6.x/filesystem#storing-files`](https://laravel.com/docs/6.x/filesystem%2523storing-files) 的文档详细说明了如何在不同类型的文件系统(本地和远程)中存储和检索数据，如何处理和更改文件的元数据，如何上传和下载文件，以及如何通过文件权限管理对文件的访问。

在控制器内部仍然存在混合关注的问题。用于存储上传文件的逻辑与控制器方法内联。这是一个问题，因为我们已经认识到控制器只是一个接收请求和返回响应的地方；然而，在我们的例子中，情况显然不是这样。控制器处理上传文件的处理和存储中涉及的所有逻辑，在我们的例子中，这是核心域逻辑。我们将在本章和未来讨论解决这一难题的不同方法。

## 政策介绍

以下部分描述了在企业 web 应用中发现的与安全约束相关的常见问题，对于该问题，唯一明确的解决方案是实现某种健壮的用户管理和授权系统来处理用户管理，以及通过`Role`实体管理每个用户的权限。通常，在执行完成请求所需的逻辑之前，您需要知道用户是谁以及用户可以做什么。我们可以在请求对象中使用这个漂亮的小点(在`authorize()`方法中),作为在允许用户访问和提交特定表单之前正确检查用户类型的一种方法，但是如果我们想要实现这样的业务策略，比如在每个域模型的基础上进行授权，以便一个域类的任何给定实例都具有与相同类型的任何其他实例相同的安全设置集，那该怎么办呢？我们可以使用 Laravel 的政策做到这一点，我们将在接下来讨论。

Authenticating form Requests and using Policies

例如，假设您的应用支持一个企业、公司或其他一些大中型公司。在该企业中，有一个内置于应用核心的自定义身份验证层，该层具有一组定义的用户类型和一个相应的权限、角色和/或组表，它们共同定义了允许每个用户在应用中访问、查看和执行的所有操作。

比方说，这个应用管理不同医生使用的索赔提交流程，该流程允许他们为满足特定收入和贫困水平的人提供的医疗服务和治疗向联邦医疗计划收费。其工作方式是，患者与系统中的签约提供者预约，他们出现在医生的办公室并接受一些医疗需求的护理。提供护理后，医生获得服务报酬的方式是向完全合格的医疗保健中心(FQHCs)提交医疗索赔，该中心负责向医疗服务保护伞下的提供者支付报销费用。

联邦政府对不准确的索赔申请绝不手软，只有在百分之百准确的情况下才会接受和支付。为患者完成的所需数据、文件和程序(在称为 CPT 编码系统的复杂系统中建模)、患者信息、提供者信息以及一系列其他检查和平衡确保患者有资格接受护理*在*之前，FQHC 将向提供者开出支票。

为了帮助这一过程，创建了一个应用，允许不同类型的用户登录到应用的不同部分，以便他们可以在不干扰系统其他用户的情况下完成工作。一组可用的权限决定了每个用户有权做什么或看什么。这些用户类型包括提供护理的医生、来自 FQHC 的负责管理付款的记账人、有权访问每份索赔以便“清理”并验证所有数据 100%准确的审核人，以及可以访问所有内容的系统管理员。

让我们假设我们负责适当地构建一个表单，该表单接受一组通常在这些医疗声明中找到的(虚假)数据。我们知道我们只想让医生和管理人员能够将医疗索赔表实际提交到系统中。医生显然需要提交索赔来获得他们的钱，管理员显然需要能够将假索赔发送到系统中进行测试。我们将如何着手做这样的事？

**利用表单请求的 authorize()方法**

如前所述，负责表示(和验证)索赔表单的表单请求可以基于用户类型进行限制，这可能发生在表单请求类本身内部。我们还将使用 Auth facade 来帮助我们完成这项任务，因为这是一种访问我们需要的关于当前登录用户的几乎所有信息的简单方法。

```php
public function authorize()
{
    $user = Auth::user();
    switch ($user->role) {
    case 'Administrator':
    case 'Provider':
        return true;
        break;
    default:
        return false;
        break;
    }
    return false;
}

```

典型表单请求类中的这个`authorize()`方法首先获取试图提交表单的登录用户，然后检查该用户的角色属性(在本例中，该属性评估为一个简单的字符串，描述用户类型的英文单词),以查看该用户是管理员还是医疗提供者。

**注意**在我们的 Laravel 应用中，用户的角色很可能是存储在数据库中的一些记录。例如，假设 MySQL 数据库中有一个包含两个外键的`user_roles`表:一个表示用户的`user_id`字段和一个表示用户所属特定角色的`role_id`字段。根据应用的需要，可以为一个用户分配多个角色，也可以只分配一个角色。

如果用户是接受的用户类型之一，则该方法返回 true，请求被授权，将请求本身转发给路由中定义的控制器方法。如果除了用户拥有这两个可能角色中的一个之外，还有任何其他条件为真，则该方法返回 false，表单的执行将暂停，并出现一个异常，说明表单请求未被授权(或者，如果在生产环境中，异常信息和堆栈跟踪将被写入日志文件)。

让我们增加一些复杂性，假设系统中有一个额外的用户类型，对应于医生办公室内的办公室助理，他将已经提交的索赔的更新信息——比如说，更正信息——输入到索赔的表单中，而不是医生(这是常见的做法，因为医生的时间显然比通过计算机将数据输入到系统中更有价值)。只有当这些办公室助理被注册为特定办公室的一部分(即，在医生的工资单上)时，他们才被允许将索赔表提交到系统中并更新预先存在的索赔。这是为了防止不同办公室的助理代表他们不直接为之工作的医生更新报销申请。隐私在医疗行业是一件大事，需要满足某些措施来保护患者隐私和建立受保护的健康信息(PHI)准则。

我们需要我们的应用能够处理这种限制，并且只允许类型为`OFFICE_ASSISTANT`的用户提交办公室的表单，前提是他们是为该办公室工作的注册用户。我们可能会想跳回到前面请求类，并更新`authenticate()`方法来包含对该需求的额外检查。这样做的问题是，我们实际上无法访问系统用提交的表单数据创建的虚拟的`Claim`对象*，也无法在调用`authenticate()`方法时将实际数据传递到请求中，因此我们无法验证数据是否来自提供者在同一帐户上雇佣的相应 office 助手。为了正确地构造这个身份验证特性需求，我们在某个时候需要登录的用户对象以及我们在相同的上下文*中对照*验证的对象，以便正确地检查它们并决定是否允许该用户提交声明。*

`Laravel Policies to Protect Resources`

幸运的是，Laravel 附带了一个叫做*策略*的组件。策略是负责验证单个特定类型的域对象的类。它基本上是一种组织与特定资源或实体相关的任何给定身份验证或权限检查的方法。例如，为了创建一个核心业务对象的保护性包装(像`Claim`模型)，我们将使用 Artisan 命令(就像我们通常在创建新的 Laravel 文件时所做的那样)来创建将成为`ClaimPolicy`的脚手架。

**注意**不要担心运行这些命令或者在这个部分中键入任何代码。它仅供参考，在这里使用是为了给你模型级安全性和策略主题的更多上下文。

```php
php artisan make:policy --model=App\Claim ClaimPolicy

```

这个命令在目录`ddl/app/Policies/UploadPolicy.php`中为我们创建了一个`UploadPolicy.php`文件，看起来像清单 [4-8](#PC31) 。

```php
// ddl/app/Policies/ClaimPolicy.php

<?php
namespace App\Policies;
use App\User;
use App\Claim;
use Illuminate\Auth\Access\HandlesAuthorization;
class ClaimPolicy
{
    use HandlesAuthorization;
    /**
    * Determine whether the user can view any Claim.
    *
    * @param  \App\User  $user
    * @return mixed
    */
    public function viewAny(User $user)
    {
        //
    }
    /**
    * Determine whether the user can view the Claim.
    *
    * @param  \App\User  $user
    * @param  \App\Claim  $claim
    * @return mixed
    */
    public function view(User $user, Claim $claim)
    {
        //
    }
    /**
    * Determine whether the user can create claims.
    *
    * @param  \App\User  $user
    * @return mixed
    */
    public function create(User $user)
    {
        //
    }
    /**
    * Determine whether the user can update the Claim
    *
    * @param  \App\User  $user
    * @param  \App\Claim  $claim
    * @return mixed
    */
    public function update(User $user, Claim $claim)
     {
       //
     }
    /**
    * Determine whether the user can delete the Claim.
    *
    * @param  \App\User  $user
    * @param  \App\Claim  $claim
    * @return mixed
    */
    public function delete(User $user, Claim $claim)
    {
        //
    }
    /**
    * Determine whether the user can restore the Claim.
    *
    * @param  \App\User  $user
    * @param  \App\Claim  $claim
    * @return mixed
    */
    public function restore(User $user, Claim $claim)
    {
        //
    }
    /**
     * Determine whether the user can permanently delete the Claim.
     *
     * @param  \App\User  $user
     * @param  \App\Claim  $claim
     * @return mixed
     */
    public function forceDelete(User $user, Claim $claim)
    {
        //
    }
}

Listing 4-8A Generated Policy Class That Provides Authentication for Claim Objects

```

一般的概念是由应用中的两个标准对象组成的:一个用户对象(代表试图访问我们的资源的用户)和一个`Claim`对象(我们正在保护的资源)。支架代码已经为我们预先创建了所有的类型提示，因为我们在生成这个类时，通过初始命令传入的参数`--model=`指定了资源。策略中的所有方法都对应于可以在任何给定的`Claim`模型(业务对象)上采取的各种“动作”。我们有查看、更新、存储和删除`Claim`资源的方法。剩下要做的就是指定您希望每个可操作的场景如何按照所需的逻辑运行，以确定用户是否被允许做某事。

在这种情况下，如果用户的角色是管理员或提供者，或者当且仅当助理被视为同一提供者办公室的注册员工时，如果角色是`Office_Assistant`，我们希望仅允许存储给定的索赔模型。最初，我们将逻辑放在请求对象的`authenticate()`方法中，但是策略提供了一种更健壮、可定制的验证方法，在处理*资源*(业务对象)时，这种方法更适合用于更高程度的控制。

为了充分利用这个讨论，我们将把重点放在需求的更新部分。如果他们是 office 的注册用户，office 助手可以更新已经提交的申请。清单 [4-9](#PC32) 展示了`create()`方法如何满足这个需求。

```php
/**
 * Determine whether the user can update the Claim
 *
 * @param  \App\User  $user
 * @param  \App\Claim  $claim
 * @return mixed
 */
 public function update(User $user, Claim $claim)
 {
     switch ($user->role) {
          case 'Administrator':
          case 'Provider':
               return true;
               break;
          case 'Office_Assistant':
               $employeeManager = (new EmployeeManager());
               $providerOffice = $employeeManager->
                    findRegistrationFor($user);
               if ($claim->provider === $providerOffice->provider) {
                    return true;
               }
               Return false;
               break;
          default:
               return false;
     }
 }

Listing 4-9Possible Implementation of a Policy’s update() Action on a Given Claim Object

```

这个例子定义了一个`update()`方法，它采用一个`User`对象和一个`Claim`对象来确定请求是否应该被允许继续。如果用户的角色是管理员或提供者，那么他们可以更新特定的`Claim`。如果用户属于`Office Assistant`类型，那么在`switch`语句中有额外的内嵌逻辑来创建一个新的域服务实例`EmployeeManager,`，该实例又会找到助手注册到的提供商的办公室，并将其与附加到`claim`的提供商进行比较。只有当这些值相同时，应用才允许请求进入系统内部。稍后我将向您展示如何使用您自己的策略。

此外，我已经省略了与实际实现该策略相关的所有代码，但是现在只需要知道它们可以通过几种不同的方式实现，这取决于您要完成的任务的上下文。

*   通过使用方法`can()`和`cant()`的`User`模型，这些方法接受要检查的模型以及该模型中对应于将用于授权检查的策略方法的动作

*   在给定的路线上，通过中间件

```php
if ($user->can(‘update’, $claim) {
     // perform update logic after the “update” method has
     // been called on the ClaimPolicy
}

```

*   通过助手方法在控制器内部

```php
Route::post(‘/claim/{claim}’, function (Claim $claim) {
     // perform update logic
})->middleware(‘can:update,claim’);

```

```php
/**
 * Update the given claim
 *
 * @param Request $request
 * @param Claim $claim
 * @return Response
 * @throws \Illuminate\Auth\Access\AuthorizeException;
 /*
public function update(Request $request, Claim $claim)
{
     $this->authorize(‘update’, $claim);
     //the current user can update the claim
}

```

表 [4-3](#Tab3) 显示了控制器方法到其用于认证的相应方法的映射。

表 4-3

控制器方法到策略上相应方法的映射

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

控制器方法

 | 

路由定义的 HTTP 动词

 | 

政策方法

 |
| --- | --- | --- |
| `index()` | 得到 | `viewAny()` |
| `show()` | 得到 | `view()` |
| `create()` | 得到 | `create()` |
| `store()` | 邮政 | `create()` |
| `edit()` | 得到 | `update()` |
| `update()` | 上传/修补 | `update()` |
| `destroy()` | 删除 | `delete()` |

注意，对于这些选项中的任何一个，Laravel 都会自动检查是否有针对给定模型的策略被请求访问；然而，如果没有，它将退回到`AuthServiceProvider`中定义的任何已定义的门验证关闭。

关于策略需要注意的另一件事是传递到策略方法中的域对象的类型，允许修改或删除该对象类型。传递给策略方法的对象类型是该策略所保护的模型(或资源)。这不要与资源模型混淆，资源模型是使用特定于特定模型上的动作的资源控制器来定义的。

关于它们的另一个真正伟大的事情是它们支持雄辩的关系，使得以直接和非介入的方式转换对应于其他对象的关系的对象变得容易。我们将在本书的后面部分触及所有这些内容。

## 设计 API 优先的应用

此时，我们知道了大多数请求细节(比如它们是什么以及如何验证它们)，所以我们现在可以开始在脑海中看到应用的整体结构。我们已经包含了表单进入我们的应用时我们所期望的表单的正确定义，这是您将与之交互的数据类型的一个很好的高层次概述。这是构建应用的方法，所以如果你不知道从哪里开始一个项目，API 是一个很好的选择。

在本书的后面，我们将讨论如何使用 Laravel 中提供的设施和管道设置来构建和实现一个实际的 API，但是为了吊起你的胃口，我在侧边栏中加入了一个叫做 *API 优先设计*的东西。

API-First Design and the Open API Specification

在专业的 web 开发中，API 优先的设计与我在本章中描述的过程有很大的不同。这样做的原因是因为我想让你熟悉拉勒韦尔流动的方式；做到这一点的最佳方式是允许您专注于特定的概念元素组，而不被更多的架构实践和模式分散注意力。随着这本书的进展，我们将在适当的时候了解这些。

主要区别在于，在 API 优先的设计中，通常从创建 API 将遵循的模式开始，以便完成模型所需的各种应用任务。这通常是以一种与语言和数据库无关的方式完成的，因此您最终得到的是 API 层的严格准则，下至诸如所请求的参数类型之类的本质细节，甚至是进入和离开应用的请求和响应的整个定义结构，通过端点分组到类似的功能焦点。您首先定义 API 中的所有端点，然后编写一行实际代码来使用它。

**开放的 API 规范和吹嘘**

在现实世界中，有多种方法可以做到这一点。我向你们提出的一个解决方案是利用所谓的开放 API 规范，就像 SwaggerHub ( [`https://swagger.io/tools/swaggerhub/`](https://swagger.io/tools/swaggerhub/) )这样的 API 设计工具应用所使用的那样。在您自己的应用中开始使用 Swagger 需要一定的学习过程，但是花时间学习是非常值得的。SwaggerHUB 的优点在于它提供了一种独特的方式来查看您在 API 中定义的数据结构(使用开放 API 规范作为一种手段)。它还提供了一系列很酷的特性，比如快照创建、版本跟踪、分叉/合并和发布特性。版本跟踪在团队环境中特别有用，因为它使得团队的所有成员在 API 标准建立时更容易使用最新版本。

这里有一些我觉得非常酷的东西:当从不同角度查看 API 并导航到特定定义时，SwaggerHub 提供的可视化非常有用，它们都是使用开放 API 标记语言生成的。学习如何定义您自己的应用中需要的各种结构、请求和响应需要一些时间，但是这是非常值得的。一旦掌握了窍门，您就可以快速定义对应用的成功至关重要的 API 设计细节。使用像 SwaggerHub 和 Open API 规范这样的工具，您可以保证定义是有意义的(因为它大约每五秒钟被解析和验证一次，重新生成对应于路由定义的可视化工具),并且您不会重复每个特定请求和响应中涉及的实体的定义。

您只需定义一次这样的结构(从*组件/模式*节点中),然后就可以在 API 中的任何端点、请求或响应定义中引用它们。如果你引用了一个*没有*定义的特定结构，你会得到一个友好的错误标记，解释为什么会有这个问题。验证是有帮助的，因为您为应用指定的 API 定义由客户端实现精确地遵循*，这意味着您为自己的 API 布局的定义、类型和数据结构必须是准确的。*

 *一旦您对组成您的 API 的所有结构的定义感到满意，那么您就可以将更改“发布”到一个特定的已发布版本，防止对该版本的进一步修改，除非创建了一个新版本(例如，使用形式为 *version.major.minor* 的增量版本控制)。您还可以指定使用哪个版本作为默认版本，这样您就可以拥有尽可能多的“进行中”版本，同时强制团队使用某个特定版本来开发使用该 API 的应用的其他区域。

## 中间件

中间件是一个在 PHP 世界获得广泛支持的概念，特别是在 Laravel 等 MVC 框架和 Node's Express 等其他服务器端框架中。中间件被用作过滤进入应用的 HTTP 请求的机制，它们可以用于您可能想做的几乎任何事情，无论是之前、之后还是之间。它们通常在 web 应用中用于各种有效和合法的目的，包括:

*   认证和授权检查

*   会话验证和会话变量的修改

*   读取、设置或修改请求和响应头(对应于中间件之前和之后)

*   记录事务和 API 调用

*   重定向和内部站点“流”定制，并中断标准的请求/响应生命周期以完全替换其中任何一个

*   发出或响应特定的领域事件

*   修改对应用的每个调用的请求或响应，或者只在特定的端点上，从特定的 IP 地址修改请求或响应，这些 IP 地址也限制请求，因此它们必须包括具有适当值的有效请求头，以及您可能需要的几乎任何其他安全问题

*   更加

作为另一个例子，在 Laravel 中，从应用内部运行的检查和平衡(可以这么说)通过一个必需的认证会话(使用 Cookie 头)来确保请求的有效性和真实性，通常实现为某种类型的令牌认证，以限制应用中不应该对系统的非用户可用的部分。Laravel 使用中间件在整个系统中建立几乎所有的认证操作。

要获得 Laravel 应用中默认配置的中间件的高层次概述，您可以查看 Laravel 应用的`Kernel`类，它位于`/ddl/app/Http/Kernel.php`，是 Symfony 著名的`HttpKernel`实现的扩展，几乎是所有现代 web 应用框架中事实上的标准`Kernel`。

```php
// ddl/app/Http/Kernel.php

<?php
namespace App\Http;
use Illuminate\Foundation\Http\Kernel as HttpKernel;
class Kernel extends HttpKernel
{
    /**
     * The application's global HTTP middleware stack.
     *
     * These middleware are run during every request to your application.
     *
     * @var array
     */
    protected $middleware = [
        \App\Http\Middleware\TrustProxies::class,
        \App\Http\Middleware\CheckForMaintenanceMode::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        \App\Http\Middleware\TrimStrings::class,
        \Illuminate\Foundation\Http\Middleware\ /
        ConvertEmptyStringsToNull::class,
    ];
    /**
     * The application's route middleware groups.
     *
     * @var array
     */
    protected $middlewareGroups = [
        'web' =>
      \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
       \Illuminate\Session\Middleware\StartSession::class,
    // \Illuminate\Session\Middleware\AuthenticateSession::class,
       \Illuminate\View\Middleware\ShareErrorsFromSession::class,
       \App\Http\Middleware\VerifyCsrfToken::class,
       \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],

        'api' => [
            'Throttle:60,1',
            'Bindings',
        ],
    ];
    /**
     * The application's route middleware.
     *
     * These middleware may be assigned to groups or used individually.
     *
     * @var array
     */
    protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' =>
\App\Http\Middleware\RedirectIfAuthenticated::class,
        'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
        'throttle' =>
\Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' =>
\Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
    ];

    /**
     * The priority-sorted list of middleware.
     *
     * This forces non-global middleware to always be in the given order.
     *
     * @var array
     */
    protected $middlewarePriority = [
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\Authenticate::class,
        \Illuminate\Routing\Middleware\ThrottleRequests::class,
        \Illuminate\Session\Middleware\AuthenticateSession::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
        \Illuminate\Auth\Middleware\Authorize::class,
    ];
}

```

`Kernel`类提供了特定中间件到给定路由类型的分配。我在这里使用*路由类型*来表示 web 路由和 API 路由。相比之下，我使用*路由组*来指代在一个中央路由文件中定义的单个路由组。每个中间件都有一个快捷语法，您可以在前面的代码中看到，它对应于为每个路由类型定义的数组键。我们将在本章末尾讨论这两种路由类型的区别。

清单 4-10 展示了一个中间件的例子。看一下文件`dll/app/Http/Middleware/RedirectIfAuthenticated.php` *。*该中间件对应于`web`路由配置组中的`guest`键(列表 [4-10](#PC37) )。

```php
// dll/app/Http/Middleware/RedirectIfAuthenticated.php

<?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Support\Facades\Auth;

class RedirectIfAuthenticated
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @param  string|null  $guard
     * @return mixed
     */
    public function handle($request, Closure $next, $guard = null)
    {
        if (Auth::guard($guard)->check()) {
            return redirect('/home');
        }
        return $next($request);
    }
}

Listing 4-10An Included Middleware in Laravel That Redirects Users Already Authenticated to the /home Route

```

中间件很方便，因为它位于进入应用的请求和域模型(或应用的核心)之间，它可以充当任何类型的身份验证/授权检查、缓存机制、应用日志记录、会话/cookie 参数的机制，或者通过 CSRF 保护检查来确保表单的有效性以防止 XSS 攻击。这些都是如何在 Laravel 应用中调用和建立这些东西的例子。然而，给定特性的特定实现的实际定义、协作和依赖关系通常位于其他类或组件中。中间件只是实现那些列出的关注点的一种机制，但不应该直接内联实现它们相应的逻辑。相反，设计架构以在域层中容纳这样的问题，然后您可以从特定的中间件或控制器方法中调用它，但是只有在您正在处理的问题的上下文中这样做才有意义。

保持这种关注点的分离允许我们更好地组织应用的核心逻辑，并给我们一个清晰的边界，即哪个逻辑需要在哪个层，甚至当域模型被实现为一系列跨越多个有界上下文的独立和专门的模块时，允许更细粒度的控制，并且这些有界上下文中的每一个都可以被认为是其封闭模块的一部分。这有助于在域级别上组织代码，这正是我们想要的。

另一个需要注意的重要事情是，这个机制在进入应用的每个请求以及应用发出的每个响应时都会被触发(调用)。当然，有一些方法可以配置中间件，使它们只“激活”应用的一部分，而不是每个请求/响应，但实际上处理请求的额外过滤的方法是添加确定是否应该运行或跳过中间件的逻辑——该逻辑应该放在中间件定义的主体内，并且应该立即返回下一个可调用的中间件(中间件之前),或者在检查执行之前或之后在堆栈上的中间件主体的末尾(中间件之后)。在本书的稍后部分，我将向您展示如何配置前中间件和后中间件。

如果您不希望中间件在每个请求上触发，您也可以指定一个路由或路由组来强制使用特定的中间件，就像清单 [4-10](#PC37) 中的那样。将特定的中间件分配给应用的相关部分，还有什么比使用路由配置更好的方法呢？因为我们使用特定于路由的 URIs 将所有不同的部分(组件)组合在一起，所以 Laravel 提供了一种直观和简单的方法，使特定的中间件只在特定的路由被客户端找到时才运行。

虽然我们还没有深入到在您自己的应用中实现中间件的细节，但是您对它们有一个基本的了解是很重要的，这样您就可以在本章的下一节中讨论路由文件。Laravel 中有两个主要的中间件组，对应于中间件实际涉及的范围，默认定义为:API 中间件组和 web 中间件组。这些组可以在位于此处的服务提供商内进行配置(和更改):`app/Providers/RouteServiceProvider`。如果你打开这个文件看一看，你会注意到一个基本的`map()`方法调用了同一个类中的两个默认方法:`mapWebRoutes()`和`mapApiRoutes()`。这两个中间件组由两个 URIs 确定，这是内部使用的机制，用于将给定的中间件映射到其激活的相应路由组(表 [4-4](#Tab4) )。

表 4-4

Laravel 的默认中间件配置

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

中间件组名称

 | 

路由前缀

 | 

有效路线示例

 | 

路由文件

 |
| --- | --- | --- | --- |
| `Api` | `/api/` | `/api/users/create` | `routes/api.php` |
| `Web` | `/` | `/about` | `routes/web.php` |

在典型的真实场景中，应用很可能包含其 API 的不同版本，这可以通过向一组选定的路由添加路由前缀来表示，该前缀指示给定客户端使用的 API 版本。以下是 API 路由端点的典型示例:

*   [T2`http://mysite.com/api/v1/`](http://mysite.com/api/v1/)

*   [T2`http://mysiteapi.io/api/json/v1`](http://mysiteapi.io/api/json/v1)

*   [T2`http://api.yoursite.com/v1/`](http://api.yoursite.com/v1/)

*   [T2`http://yoursite.com/api/v2/files`](http://yoursite.com/api/v2/files)

### 基于 Web 的路由的 Web 中间件➤

web 中间件组在`routes/web.php`文件中配置，被认为是用户通过浏览器与之交互的应用的“公共”范围。默认情况下，它对应于所有不以`/api`开头的 URIs，这通常是 web 应用中 URIs 的大部分。任何以`/`(除了`/api`)开头的东西都被认为是网络路由组的成员，因此有更多的公共设置，在这种情况下，允许非登录用户查看标准的网络路由。最基本的例子是应用的主页或它的“关于”页面。

### 用于基于 API 的路由的 API 中间件➤

无论如何，我们都不希望应用的所有 URIs(路线)对未经身份验证的用户(*来宾*)可用。应用的 API 也是如此，它通常包含已定义的 REST 接口，允许客户端访问和修改系统或域的核心部分。例如，如果我们要在我们的应用中建立一个新用户帐户的实现，我们会希望将 URIs (routes) *放在*之后，以便在未经身份验证的用户尝试一些恶意行为时提供安全手段(并且您总是必须假设他们会尝试这样的事情)。在这种情况下，我们可能会指定一个`/api/users`路由，它对应于一个 API 的 REST-ful 实现，允许该路由根据 HTTP 动词执行所需的功能，通过基于路由的闭包或者引用 Laravel 的快捷语法中定义的控制器方法来引用特定控制器上的单个方法。

这在 Laravel 中很容易配置，稍后我将向您展示细节。现在，只要确保您理解什么是中间件，并认识到可以(并且已经)通过 Laravel 应用中的每个中间件组配置的东西的类型。稍后我们将回到中间件的概念。

## Laravel 工作简介

本节介绍了*作业*的概念，它基本上是一组封装到单个对象中的事务或操作，其内部流程是为了解决领域级别的业务问题而创建的。作业可以像命令一样使用，可以在控制器中轻松调用，可以放在队列中，可以用 supervisorD 监控，以便并发处理它们(即*异步*)。您可以为现代任务和消息队列 sch 设置一个流行的选择，如 RabbitMQ、Kafka 或 ActiveMQ，以异步方式处理各个任务的通信、管理和报告，以便操作看起来更加流畅，等待时间比同步处理少。然而，对于这个示例，我们将只创建一个同步实现，并将作业的结果立即返回给调用代码(在控制器中)，而不是使用使异步处理如此流行的“设置好就忘了”技术。我们将深入研究如何使用消息队列。

Using Laravel Jobs to Encapsulate Business Logic

正如我们现在所知道的，在 MVC 架构中，控制器的目的应该仅仅是*与客户端握手，将任何域工作委托给域层(域层依次一次处理一个或使用直接使用域层的应用服务)，并返回指示给定请求成功或失败的响应。也就是说，我们最初设计的`UploadController`的`store()`方法包含了处理、命名和存储上传文件所需的所有逻辑。这个域逻辑应该封装在控制器方法体之外的某个地方，一种可能的方法是创建一个作业。*

要生成新的作业支架，请使用以下命令:

```php
php artisan make:job SaveUploadedFile

```

这个命令将在`app/Jobs/SaveUploadedFile.php`产生文件内的代码(列表 [4-11](#PC39) )。

```php
// ddl/app/Jobs/SaveUploadedFile.php
<?php
namespace App\Jobs;
use Illuminate\Bus\Queueable;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
class SaveUploadedFile implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }
    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        //
    }
}

Listing 4-11Scaffold Code Generated from make:job Command

```

这个类非常简单，只包含两个方法:构造函数和`handle()`方法。构造函数被用作依赖注入的一种方式。完成这项工作所需的任何附加对象都在构造函数的签名中进行了类型提示，并由 Laravel 的依赖注入组件自动解析。事实上，如果你需要更多关于完成特定任务的对象的定制，你可以指定*你想要如何*使用 Laravel 的服务容器构建注入服务或作业的对象(在 [`https://laravel.com/docs/master/container`](https://laravel.com/docs/master/container) 阅读)。我们将在本书的后面讨论服务容器的更高级的用法。

构造函数也是传递来自请求的任何数据的地方，这些数据是完成封装在该作业中的任务所需要的。因为我们关心的是存储用户提交的文件，所以我们需要包含任何曾经内嵌在控制器的`store()`方法中的参数，并将它们作为单独的项放在`Job`类的构造函数中。我们不会将整个请求对象传递给构造函数；这是不好的做法。

清单 [4-11](#PC39) 中的第二个方法是`handle()`方法，它是作业定义的核心。这是调用作业时主逻辑运行的地方。它基本上利用了您在构造函数中指定的任何对象(这些对象也应该作为类成员参数包含在作业定义中)。当作业被分派时(通常是从控制器)，它会在构造函数中注入任何需要的东西，并调用`handle()`方法。让我们看看保存用户上传的文件并将生成的文件 ID 存储在数据库中以跟踪哪个用户拥有哪个文件的作业是什么样子的。

```php
<?php
namespace App\Jobs;
use Illuminate\Bus\Queueable;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Symfony\Component\HttpFoundation\File\File;
use App\UserUpload;
class SaveUploadedFile implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected $fileName;

    protected $upload;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    public function __construct(File $upload)
    {
        $this->upload = $upload;

    }
    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
           //save the user’s file and grab its path on the filesystem
           $path = $this->upload->store('uploads');
           //create a record to track user’s uploaded files
           $upload = UserUpload::create([
                 ‘user_id’ => Auth::user()->id,
                  ‘filename’ => $path,
           ]);

           //do a final verification check that the saved file exists
           if (!is_file($path)) {
                  throw new Exception(“Problem with saving the file”);
     `}

           return $path;
     }
}

```

有了这个新的作业，我们可以修改我们的控制器，消除任何与文件存储相关的问题，而是简单地将该任务委派给新的`SaveUploadedFile`作业。通过一个静态方法，这可能看起来是这样的(我们实际上使用了 Laravel 中所有作业类附带的内置方法):

```php
public function store(UploadFileRequest $request)
{
     $file = $request->file('userFile');
     $filePath = SaveUploadedFile::dispatchNow($file);

     return response()->json(['success' => true]);
}

```

正如您所看到的，我们的控制器方法在大小和复杂性上都有所降低，因为我们现在将存储上传文件的任务委托给了一个作业类，而不是与处理请求的控制器方法内联。现在我们有了一个清晰的关注点分离，加上我们正在实践一个叫做*意图揭示接口*的东西，在这里我们以一种清楚地表明它们的目的的方式命名类、对象和参数，同时也尽可能清楚地定义和揭示对那些参数采取的动作。

## 在现实世界中保持质量

管理这种迭代开发过程并帮助您专注于解决系统的领域问题的最佳方式是采用在持续集成技术的应用中发现的概念，这样您就可以不断地用高质量的代码来开发软件，这些代码包括单元测试以及自动测试机制，您设置这些机制是为了在每次提交代码库或每次从拉请求进行合并时运行。这有助于确保您编写的新代码不会破坏任何旧的功能，并为您提供一条在应用用于生产后进行升级和维护的清晰道路。不破坏旧的代码对于维护高质量的 web 软件是至关重要的，一个可靠的 CI/CD 管道肯定会有所帮助。

总的来说，我在本章中概述的过程是这样的:

设计领域和架构➤生成通用代码➤定制通用代码➤重申系统设计➤重构新见解。

从更高的层面来看，它看起来更像这样:

设计➤原型➤实现➤重构。

增量变化的概念是几种流行的编程范例的核心基本点。极限编程(XP)和敏捷开发都依赖于开发的迭代周期给 web 应用开发工作带来的价值。你甚至可以在 [`http://continuousiteration.com`](http://continuousiteration.com) 找到关于这个主题的博客(不是“持续集成”，而是“持续迭代”)。所有好的域名都被占了，所以我试图想出一个意思相同，听起来接近相同的东西，这就是我想出来的。不讨厌。

## 结论

在这一章中，我使用 Composer 包管理器解决了依赖关系，检查了 Laravel 在本地系统上的安装。之后，我们看了一个使用 Laravel 构建的示例应用，了解了 Laravel 应用中涉及的主要组件。我向您展示了如何使用 Laravel 附带的 Artisan 命令行工具来为这些组件生成脚手架代码，然后我们使用它们来实现我们需要的功能。我们以与真实场景中大致相同的方式完成了这个例子:我们创建了一个天真的实现来满足系统的需求，然后我们返回并在设计中加入了一些额外的想法，并意识到它缺少一些重要的东西并违反了一些重要的规则。

我们用代码制作了模型的原型，很清楚它并不完美。我们慢慢地开始一遍又一遍地去除商业模式的弱点或不准确的表达，直到我们结束修补所有的漏洞。最终，这给我们留下了一个工作的软件，它与构建它的商业模型相一致。

在我们为上传应用构建了实现的粗略草案之后，我们回顾了应用的结构和组件的一些额外的考虑，还讨论了初始版本的一些缺点。您学习了如何尽可能地减少这些缺点，并对代码的结构和逻辑进行调整，让您(我希望)对如何处理基本请求、验证传入的请求参数、使用作业封装业务逻辑、使用控制器作为完成请求/响应生命周期的手段，以及使用 Laravel 提供的其他一些工具有一个坚实的了解。

现在你有了这样的理解，我们可以进入这本书的实质，讨论我们实际上在领域驱动的 Laravel 方面正在尝试做什么；然后，我们将解决如何在现实世界中实现它。***