# 4.高级功能技术

到目前为止，您已经对函数式编程风格及其带来的优势有了一些了解。你可以从今天开始使用这些技术，而不需要进一步阅读。不过，理想情况下，我已经激起了您的兴趣，让您更进一步，学习更多的函数式技术，以添加到您的程序员工具箱中。

在这一章中，你将会看到函数式编程的一些更高级的方面，这些方面将会让你以更加函数化的方式来构建你的 PHP 代码。这一章是“理论”的最后一节，在这本书的下一部分，你将开始讨论实际的例子。您将从 currying 开始，它将部分函数应用的概念扩展为一种将它们分解成低级版本的自动化方式。接下来，您将看到虚构的单子，它帮助您进行程序流控制，并允许您处理在现实世界中工作时会遇到的讨厌的副作用。在那之后，你会看到蹦床，这是一种控制递归的方法。最后，我将简单介绍一下使用类型声明的严格类型化和动态类型化，虽然严格来说这不是一个函数概念，但在某些方面是有用的(而在其他方面则不是)。

## Currying 函数

在前一章中，您看到了部分函数的优点，我提到了一种自动化这种函数分解的方法。分解是通过固定一个或多个参数的值，将多元函数分解成具有较小签名的函数的行为。你将要看到的自动分解方法叫做 currying，它是以 Haskell Curry 的名字命名的，他的名字(字面上)遍布函数式编程！

Currying 确实与部分函数应用密切相关，一个 currying 函数乍一看很像您创建的部分函数生成器。然而，有一些微妙但重要的区别。也就是说，部分功能应用只是一种奉承(或者反过来，取决于你和谁说话)，所以两者的好处是相似的。您选择使用哪一种取决于在您的情况下什么对您有效。

在部分函数生成器中，您接受一个函数，加上一个绑定到第一个参数的值，并返回一个签名少了一个参数的函数。在 currying 中，通过获取一个函数和一个或多个参数的列表，并将所有这些参数绑定到返回的新函数，可以使这一点更加灵活。到目前为止，currying 是类似的(如果更一般)。要获得函数的实际结果，您需要到达已经绑定和/或传入所有函数参数的点，然后函数将执行并返回值。

生成器返回的部分函数和 currying 函数(在这两种情况下都是闭包)是两者区别的关键。使用您看到的简单部分生成器，返回的函数是一个具有简化签名的函数(即，调用它所需的参数数量减少)。如果您想进一步减少它以创建另一个部分函数，您可以在返回的闭包上再次调用部分函数生成器。相比之下，curry 例程返回的闭包是一个独立的函数，可以自动进一步 curry。例如，如果您有一个有五个参数的函数，您通过修改两个参数来处理它，您将得到一个接受三个参数的闭包。如果您随后用一个或多个参数调用这个闭包，那么它不会在没有一组完整参数的情况下执行(正如前面显示的部分函数那样)，它会自动搜索自己并返回一个接受两个参数的闭包(如果用另一个参数调用，它还能够进一步搜索自己)。将这与您的生成器中的部分函数进行对比；如果您向接受三个参数的部分函数提供一个参数，它将尝试使用减少的参数集执行，这通常会导致错误。

和往常一样，这个例子可能会更清楚。由于编写一个格式正确的 currying 函数并不容易，您将使用 Matteo Giachino 编写的名为`php-curry`的库来帮助您。这可以在 GitHub 的 [`https://github.com/matteosister/php-curry`](https://github.com/matteosister/php-curry) 获得，可以通过 Composer 安装，也可以直接通过包含它来安装，如清单 [4-1](#Par8) 和清单 [4-2](#Par9) 所示。

```php
<?php

include('Curry/Placeholder.php');
include('Curry/functions.php');

use Cypress\Curry as C;

# Let's make a function place an order with our chef
# for some delicious curry (the food, not the function)

$make_a_curry = function($meat, $chili, $amount, $extras, $where) {

    return [
                    "Meat type"=>$meat,
                    "Chili hotness"=>$chili,
                  "Quantity to make"=>$amount,
                    "Extras"=>$extras,
                  "Eat in or take out"=>$where
                 ];
};

# We think that everyone will want a mild Rogan Josh, so
# let's curry the function with the first two parameters

$rogan_josh = C\curry($make_a_curry, 'Lamb','mild');

# $rogan_josh is now a closure that will continue to
# curry with the arguments we give it

$dishes = $rogan_josh("2 portions");

# likewise $dishes is now a closure that will continue
# to curry

$meal = $dishes('Naan bread');

# and so on for meal. However, we only have 1 parameter
# which we've not used, $where, and so when we add
# that, rather than returning another closure, $meal
# will execute and return the result of $make_a_curry

$order  = $meal('Eat in');

print_r( $order );

# To show that our original function remains unmutated, when
# we realize that actually people only want 1 portion of curry
# at a time, with popadoms, and they want to eat it at home, we
# can curry it again. This time, the parameters we want to bind
# are at the end, so we use curry_right.

$meal_type = C\curry_right($make_a_curry, 'Take out', 'Poppadoms', '1 portion');

$madrass = $meal_type('hot', 'Chicken');

print_r( $madrass );

# We could curry the function with all of the parameters
# provided, this creates a parameter-less closure but doesn't
# execute it until we explicitly do so.

$korma = C\curry($make_a_curry,
                        'Chicken', 'Extra mild', 'Bucket full', 'Diet cola', 'Eat in');

print_r($korma());

Listing 4-1.currying.php

```

```php
Array
(
    [Meat type] => Lamb
    [Chili hotness] => mild
    [Quantity to make] => 2 portions
    [Extras] => Naan bread
    [Eat in or take out] => Eat in
)
Array
(
    [Meat type] => Chicken
    [Chili hotness] => hot
    [Quantity to make] => 1 portion
    [Extras] => Poppadoms
    [Eat in or take out] => Take out
)
Array
(
    [Meat type] => Chicken
    [Chili hotness] => Extra mild
    [Quantity to make] => Bucket full
    [Extras] => Diet cola
    [Eat in or take out] => Eat in
)
Listing 4-2.currying-output.txt

```

Currying 提供了一种更简洁的方式来管理部分函数，特别是当您经常需要一个给定函数或一组部分函数的许多不同版本时。由于额外的 currying 代码，这种权衡在闭包中是一个更大的开销，但是这通常是一个无关紧要的考虑。您也失去了允许可选参数的能力(至少对于这里实现的 currying 来说是这样的)；在所有参数都被赋值之前，该函数不会执行。

除了曲线拟合，还有相反的过程，通常称为去曲线拟合或去曲线拟合，它采用一组 n 个单参数函数，并将它们组合成一个 n 元函数。这通常应用有限，所以我不会在本书中涉及。

## 神秘的单子

单子是程序控制的一种通用形式，是现实世界副作用问题的解决方案(比如从文件中读取和打印到屏幕上)，也可以说是函数式编程(或一般生活)中最难理解的概念之一。如果你查找关于单子的介绍性文章或视频，他们总是会首先告诉你，专家说你需要理解范畴定理、内函子等数学主题，可能还有其他相关的深奥概念。然后他们会说，实际上，你不需要理解这些，因为他们已经找到了一种简单易懂的方式来解释单子。然后，他们将开始讨论函子(数学函子，不是编程函子)、应用函子、幺半群等等，最终根据这些概念定义幺半群，并在此过程中失去 90%的读者。然后，他们会声称他们给出了一个简短的非技术概述，这里有一个完整的数学解释的链接，以帮助澄清这一切，在这一点上，每个人都放弃了单子，函数式编程，有时甚至是他们迄今为止的整个生活方式。所以我不会那么做。

著名的 JavaScript 教育家道格拉斯·克洛克福特在他的谷歌技术演讲“单子和生殖腺”中有一句名言:

“单子的诅咒是，一旦有人知道单子是什么以及如何使用它们，他们就失去了向其他人解释(它们)的能力。”

一种不那么轻率的说法是，也许你对单子是什么以及单子能做什么的理解通常会随着时间的推移而发展。当你已经完全掌握了它们的力量，并且这个概念已经完全“点击”时，很难记得所有那些导致理解它们如何工作的更小的“发现”时刻。

所以，我从问题的另一端开始。我不会试图从基本原理中推导出单子，我会告诉你单子是什么，你用单子做什么，并给你看一些例子。一旦你习惯了使用它们，你就会有自己的“哦，是的，我现在明白了”的时刻，即使你不明白背后的数学原理。当然，我也会在最后提供与数学相关的解释的必要链接。

## 什么是单子？

monad 是一种函数，它封装了值，并在 monad 的上下文中将函数应用于这些值。你可以把它们看作是处理状态的容器，不同类型的单子在状态上承担不同种类的工作。你能用单子做什么？

*   控制程序流(作为功能组合的一种形式)
*   封装副作用(把它们从你的纯函数中去掉，使它们仅仅是程序本身的一个效果)
*   降低代码复杂性(好吧，一旦你理解了单子本身)

虽然单子是“唯一的”函数，您可以用 PHP 函数实现它们，但是使用对象创建它们通常更方便，因为这给了您更多的灵活性(并且允许您有时用额外的帮助方法作弊)。这是大多数实现单子的 PHP 库采用的方法。请记住，方法本质上只是在对象的上下文中调用的一个函数(事实上，闭包本质上是一个具有单一方法的对象，该方法对封装在其上下文中的一组数据进行操作)。

那么，野外的单子长什么样？它将有两个关键方法。

*   一个构造函数方法，它接受一个值并创建一个“包装”该值的 monad 对象
*   一种“绑定”方法
    *   接受一个函数(或其他可调用函数)作为输入
    *   在前面提到的构造函数包装的值上调用它
    *   返回通过对被调用函数的结果调用构造函数方法而创建的新 monad

如您所见，bind 方法是这里的关键。它接受一个函数，将其应用于存储在 monad 中的值(即状态)，并返回一个新的 monad 对象，其结果(“新”状态)作为该新 monad 的值。它还具有三个关键的数学属性，这使它有别于其他恰好保护一个值并绑定一个函数的结构。稍后您将详细查看这些内容，并了解如何使用它们来测试某个东西实际上是否是单子。

是时候看一个例子了。您不用编写自己的 monad 类，而是使用 Anthony Ferrara 编写的名为 MonadPHP 的库(可在 GitHub 的 [`https://github.com/ircmaxell/monad-php`](https://github.com/ircmaxell/monad-php) 获得)。这是单子的一个简单的“玩具”实现，非常适合学习。我强烈建议看一下源代码，因为它写得很好，很容易理解。您可以用 Composer 安装它，或者只需要这些文件，正如我将展示的那样。您将首先查看清单 [4-3](#Par30) 中的身份单子(输出如清单 [4-4](#Par31) 所示)，它唯一的工作是调用包装值上的传递函数。它不是很有用，但是演示了一个基本单子的结构和属性。

```php
<?php

require('MonadPHP/Monad.php');
require('MonadPHP/Identity.php');

# Use the namespace

use MonadPHP\Identity;

# Define a couple of pure functions

$double = function ($n) { return $n*2; };

$add_ten = function ($n) { return $n+10; };

# Create a monad by calling the static unit method,
# with a value (33). The unit method is a constructor
# which checks if what we are passing in is already
# an instance of this monad, or create a new one if
# not by calling the _construct method to bind
# our value (33) and return a monad object

$monad_a = Identity::unit(33);

# Let's check it is an object of class MonadPHP\Identity
# encapsulating the value 33

var_dump( $monad_a );

# Now we bind one of our functions to the monad

$monad_b = $monad_a->bind($double);

# $monad_b should be a new monad object.
# Let's check that it is and that we haven't
# just mutated monad1

var_dump( $monad_a ); # should be the same as above

var_dump( $monad_b ); # should be a new monad encapsulating 66

# This library includes a helper method "extract" to
# get the encapsulated value back out of the monad

var_dump( $monad_b->extract() ); #66

# Let's bind that function again to the new monad...

$monad_c = $monad_b->bind($double);

var_dump( $monad_c->extract() ); #132

# ... and check that monad_b is unchanged

var_dump( $monad_b->extract() ); #66

# finally, bind the function again to monad_b,
# to demonstrate again that its encapsulated value
# isn't mutated.

$monad_d = $monad_b->bind($double);

var_dump( $monad_d->extract() ); #132

# Let's now repeatedly bind methods
# in a chain

$monad_e = $monad_d->bind($double)  # *2
                                ->bind($add_ten)  # +10
                                ->bind($add_ten); # +10

var_dump( $monad_e->extract() ); # 284

# and take a look at the returned monad_e,
# take note of the object identifier (#7)

var_dump( $monad_e );

Listing 4-3.monad.php

```

```php
object(MonadPHP\Identity)#3 (1) {
  ["value":protected]=>
  int(33)
}
object(MonadPHP\Identity)#3 (1) {
  ["value":protected]=>
  int(33)
}
object(MonadPHP\Identity)#4 (1) {
  ["value":protected]=>
  int(66)
}
int(66)
int(132)
int(66)
int(132)
int(284)
object(MonadPHP\Identity)#7 (1) {
  ["value":protected]=>
  int(284)
}
Listing 4-4.monad-output.txt

```

在该示例的最后一部分，您将一组绑定调用链接在一起，这看起来很像您在前一章中看到的那种函数组合。虽然您确实可以以这种方式使用 identity 函数来组合函数，但是 monads 不仅仅是将前一个函数的输出传递给下一个函数的输入。看一下散列值(#3、#4 等。)在清单 [4-4](#Par31) 的`var_dump`输出中。这些是 PHP 在当前上下文中创建的对象的内部标识符(数字形式)。(它从#3 开始，因为#1 和#2 是你的纯函数`$double`和`$add_ten`，它们是闭包类型的对象。)具体来说，#3 对应`$monad_a`，#4 是`$monad_b`。你不用在它们上面使用`var_dump`，但是`$monad_c`会是#5，`$monad_d`会是#6。#7 是`monad_e`。为什么这很重要？它演示了每次您在单子上调用`bind`时，您会完全获得另一个对象。您每次都在围绕您的边界值改变上下文(状态),而不只是像简单的合成那样传递它。这允许你创建一些奇特的单子，做有趣的(和有用的)事情，你马上就会看到。

但是您在`$monad_d`上创建`$monad_e`的绑定调用“链”是什么呢？你已经应用了三个函数，但是最后你只得到一个新的单子。事实上，您正在创建三个新的单子，并使用 PHP 的对象解引用将下一个函数绑定到上一个单子。一眨眼的功夫，单子就在“幕后”被创造出来，然后被销毁，这就是为什么你看不到它们的原因。如果你不相信，你可以添加一个不纯的`echo('creating')`调用到身份构造器方法，你会看到它为每个绑定调用输出`creating`。

这些是单子的基础。现在让我们做一些有用的事情。虽然您可以发明单子来做您能想到的任何事情，但是您会遇到一些常见的单子来解决常见的函数式编程问题并实现典型的函数式模式。在像 Haskell 这样的纯函数式语言中，单子很受欢迎，因为它们几乎是完成实际工作的唯一方法。你将会看到一些最常见的单子来展示这种结构的可能性和力量。

### 可能单子

在前面的例子中，Identity monad 刚刚调用了绑定函数，其值封装在 monad 中。Maybe monad 更进一步，在用它调用绑定函数之前添加了一个对值的测试。

“我称之为我的十亿美元错误。”不，那不是我在谈论写这本书。这是查尔斯·安东尼·理查德·霍尔爵士的话，他是参考文献的发明者。Null 虽然是一个很好的传递信息的工具，比如失败或者缺少值，但是它也有自己的问题。函数通常返回 null，表示没有实际值要返回，这通常是因为函数中存在错误或类似错误，或者传递给函数的参数有问题。这使得调用者能够判断是否是这种情况，例如，返回值是否合法地为 0、false、空数组或类似的值，如果 null 不存在，这些值可能会被用作错误代码。然后调用者可以测试是否为空，并适当地处理它。

要了解这为什么会有问题，请考虑您在函数组合示例中看到的函数链。如果其中一个函数返回 null 作为返回值，会发生什么？空值作为输入被送入链中的下一个函数，这意味着现在需要修改所有的函数来测试和处理空值，否则就会出现问题。向前迈进一步，使用 Maybe monad，您可以处理“可能”会失败或“可能”会正确工作的函数，而不必在每个函数中编写额外的代码来检查。Maybe monad 通过在每次调用一个函数后检查是否有 null 返回值来实现这一点，如果发现 null，就不调用下一个函数。让我们看一个例子(参见清单 [4-5](#Par38) 和清单 [4-6](#Par39) )，然后我将讨论它是如何工作的以及为什么工作。您将再次使用 MonadPHP 库。

```php
<?php

require('MonadPHP/Monad.php');
require('MonadPHP/Maybe.php');

use MonadPHP\Maybe;

# We'll use the shopping list array from the previous chapter.
# It's a nested array, and not all elements have the
# same level of nesting.

$shopping_list = [
    "fruits" => [ "apples" => [ "red" => 3, "green" => 4], "pears" => 4, "bananas" => 6 ],
    "bakery" => [ "bread" => 1, "apple pie" => 2],
    "meat" => [ "sausages" =>
                                ["pork" => ["chipolata" => 5, "cumberland" => 2], "beef" => 3],
                                 "steaks" => 3, "chorizo" => 1 ]];

# Let's create some functions.

# This function takes a category (e.g. fruits) and returns either
# a) a closure that returns that category from the supplied list
# or
# b) null if the category doesn't exist.

$get_foods = function ($category) {

    return function ($list) use ($category) {

        echo("get_foods return closure called\n");

        return isset($list[$category]) ? $list[$category] : null;

    };

};

# This function does the same, except it returns a closure that returns
# the  foods (e.g. apples, pears...) from the category (fruit), or null

$get_types = function ($food) {

    return function ($category) use ($food) {

        echo("get_types return closure called\n");

        return isset($category[$food]) ? $category[$food] : null;

    };

};

# and lastly another function of the same type to get the types of food
# (e.g. red, green) from the food, or null

$get_count = function ($type) {

    return function ($types) use ($type) {

        echo("get_count return closure called\n");

        return isset($types[$type]) ? $types[$type] : null;

    };

};

# Now let's create a Maybe monad, encapsulating our
# shopping list as its value.

$monad = Maybe::unit($shopping_list);

# We'll repeatedly bind our functions against it as
# we did in the previous example.

var_dump( $monad  ->bind($get_foods('fruits'))
                                    ->bind($get_types('apples'))
                                    ->bind($get_count('red'))
                                    ->extract() # returns 3
                );

# None of our closures test for null parameters, so what
# happens if we try to look for something that doesn't exist?

var_dump( $monad  ->bind($get_foods('fruits'))
                                    ->bind($get_types('apples'))
                                    ->bind($get_count('purple')) # doesn't exist
                                    ->extract() # returns null
                );

var_dump( $monad  ->bind($get_foods('cheeses')) # doesn't exist
                                    ->bind($get_types('cheddar')) # doesn't exist
                                    ->bind($get_count('mature')) # doesn't exist
                                    ->extract() # returns null
                );

var_dump( $monad  ->bind($get_foods('bakery'))
                                    ->bind($get_types('pastries')) # doesn't exist
                                    ->bind($get_count('danish')) # doesn't exist
                                    ->extract() # returns null
                );

Listing 4-5.maybe_monad.php

```

```php
get_foods return closure called
get_types return closure called
get_count return closure called
int(3)
get_foods return closure called
get_types return closure called
get_count return closure called
NULL
get_foods return closure called
NULL
get_foods return closure called
get_types return closure called
NULL
Listing 4-6.maybe_monad-output.txt

```

(注意，如果你在 PHP 7 上运行这个，你会得到一个抛出的警告，因为这个库从 PHP 5 开始就没有更新过；您可以更改库中的绑定声明，也可以安全地忽略该警告。)

我在那里加入了一些不纯的`echo`语句，这样你就可以看到闭包何时被调用。正如您所看到的，当您试图从数组中获取不存在的项时(因此您的闭包返回 null)，链中的后续函数调用不会被执行，即使您将它们绑定到 monad。那么，这是如何工作的，为什么呢？在这种情况下，单位单子的功能如下:

1.  首先创建一个 monad，将购物清单作为它的值。
2.  然后将第一个函数绑定到它，它用购物清单值调用这个函数。
3.  这将返回一个值(数组的请求部分或 null)，该值将被放入一个新的 monad 对象中并返回。
4.  然后像前面一样将下一个函数绑定到新的单子上，以此类推，直到所有的函数都被绑定。

与同一性单子的关键区别在于，在绑定函数的阶段，条件语句检查单子的值，如果是 null，它不调用函数，而是将 null 返回到新单子中。因此，只要链中的一个函数返回空执行，所有后续的函数都会被跳过，因为封装在每个单子中的值都是空的(并且不会改变，因为它是空的，所以没有一个函数可以被调用…！).每次仍然在链中创建单子，但是封装的值(null)只是沿着链传播。

因此，作为程序员，您仍然需要编写一个空检查，但只在链的末端编写一次，而不是针对每个单独的函数。这允许您编写更简单的函数，这些函数可以假设它们将获得有效值(或者至少非空值)作为输入进行操作。如果您的函数对它们的输入值有其他共同的要求(例如，它们总是需要一个整数作为输入)，您可以很容易地构造类似的条件单子，以您想要的任何方式检查它们的封装值。

这种在每次函数调用时执行代码的能力是 monads 相对于您在前一章中看到的简单函数组合技术的优势之一。它被比作“可编程的分号”,因为 PHP(像许多编程语言一样)一个接一个地执行语句，语句之间用分号隔开。想象一下，如果你能让分号做点什么；这应该给你一个单子在这种情况下的力量的概念。

## 单子公理

正如我在单子介绍中提到的，单子必须遵守三个公理(或定律)才能归类为单子。理解这些对判断你使用的东西是否真的是单子是有用的。明确地说，一些类似单子的结构只有一两个数学属性，仍然非常有用，但是您需要格外小心，以确保它们以您想要的函数方式运行，以确保您的代码具有您期望的全功能代码的属性。

同样，我不会试图推导或解释这些公理的方法和原因，但我会以一种有用的方式呈现什么。我将用 PHP 将它们表示为伪代码，而不是用它们的数学符号。

### 单子公理 1

```php
bind( unit($i), $func ) == $func( $i )

```

这意味着如果你将一个函数`$func`绑定到一个用值`$i`创建的单子上，这相当于直接在`$i`上调用`$func`。`unit`是单子构造函数的常用名称。

### 单子公理 2

```php
bind($monad, unit) == $monad

```

这说明如果你将构造器单元函数绑定到一个单子上，结果就等同于那个单子。

### 单子公理 3

```php
bind ( bind($monad, $f1), $f2) == bind ($monad, function($i) {return bind($f1($i), $f2($i)})

```

现在这个才是最难的！

左边说，“将一个函数`$f1`绑定到一个单子，将另一个函数`$f2`绑定到结果单子。”

右边说这相当于取一个单子`$monad`，绑定一个返回单子的函数，单子是绑定函数`$f2($i)`应用于`$function $f1($i)`的结果，其中`$f1`是返回单子的函数。

如果您没有遵循或理解任何公理(尤其是最后一条)，也不要担心。在实践中，如果你需要使用它们，它总是作为一个测试，你可以直接应用它们。如果你真的想更好地理解它们，请看本章后面的“进一步阅读”部分。

## 测试单子公理

所以，让我们看看这个身份单子到底是不是真的单子(见清单 [4-7](#Par61) 和清单 [4-8](#Par62) )。一个简单的测试是创建一个测试值和函数，创建一个单子，然后采用前面的公理并用合适的 PHP 编写它们，测试每个公理的计算结果是否为真。

```php
<?php

require('MonadPHP/Monad.php');
require('MonadPHP/Identity.php');

use MonadPHP\Identity;

# 1\. bind( unit($i), $func ) == $func( $i )

// define some test variables and functions

$i = 10;
$func = function ($i) {   return $i*2; };

// create a new monad to test

$monad = Identity::unit($i);

// see if the 1st Axiom holds (should output true)

var_dump ( $monad->bind($func)->extract() == $func($i) );

# 2\. bind($monad, unit) == $monad

// and see if the 2nd Axiom also holds

var_dump ( $monad->bind(Identity::unit) == $monad );

# 3\. bind ( bind($monad, $f1), $f2) ==
#          bind ($monad, function($i) { return bind( $f1($i), $f2($i) } )

// create some more test functions

$f1 = function ($i)  { return Identity::unit($i); }; // returns a monad
$f2 = function ($i) { return $i*6; };

// and see if Axiom 3 holds

var_dump (

     $monad->bind($f1)->bind($f2) ==
          $monad->bind(function ($i) use ($f1, $f2)
                          { return $f1($i)->bind($f2); }
                      )

);

Listing 4-7.monad_test.php

```

```php
bool(true)
bool(true)
bool(true)
Listing 4-8.monad_test-output.txt

```

嗯，看起来都不错。功能稍微强一点的单子怎么样？你将以完全相同的方式处理这个问题(参见清单 [4-9](#Par64) 和清单 [4-10](#Par65) )。

```php
<?php

require('MonadPHP/Monad.php');
require('MonadPHP/Maybe.php');

use MonadPHP\Maybe;

# 1\. bind( unit($i), $func ) == $func( $i )

// define some test variables and functions

$i = 10;
$func = function ($i) {   return $i*2; };

// create a new monad to test

$monad = Maybe::unit($i);

// see if the 1st Axiom holds (should output true)

var_dump ( $monad->bind($func)->extract() == $func($i) );

# 2\. bind($monad, unit) == $monad

// and see if the 2nd Axiom also holds

var_dump ( $monad->bind(Maybe::unit) == $monad );

# 3\. bind ( bind($monad, $f1), $f2) ==
#          bind ($monad, function($i) { return bind( $f1($i), $f2($i) } )

// create some more test functions

$f1 = function ($i)  { return Maybe::unit($i); }; // returns a monad
$f2 = function ($i) { return $i*6; };

// and see if Axiom 3 holds

var_dump (

     $monad->bind($f1)->bind($f2) ==
          $monad->bind(function ($i) use ($f1, $f2)
                          { return $f1($i)->bind($f2); }
                      )

);

Listing 4-9.maybe_test.php

```

```php
bool(true)
bool(true)
bool(true)
Listing 4-10.maybe_test-output.txt

```

这也通过了所有三个公理试验。当然，这不是一个全面的测试；公理必须适用于传递给 monad 的任何和所有(构造良好的)输入/函数，但是如果您想要更彻底地测试您创建的 monad 的行为，它应该会为您提供一些关于如何进行的线索。

## 其他有用的单子

您已经了解了什么是单子，以及它如何成为组合函数的通用方式。在本章的介绍中，我说过我将解释如何使用单子来解决函数式编程中的一些问题，例如处理否则会被归类为副作用的操作。这就是我在这一节要做的事情。

首先，你会看到一个常见的单子，称为作家单子。编写软件时的一个常见任务是随着程序的进展将信息记录到磁盘上。这可以是从调试信息或审计日志到跟踪信息和事务记录的任何内容。通常，发送到日志的消息在被记录时被直接或通过调用日志记录函数写入磁盘。在函数式程序中，你可以创建一个日志记录函数，但是如果它向磁盘写入任何东西，它就不是一个纯粹的函数。如果没有的话，它作为一个日志功能就没有多大用处了！

用于处理副作用的一种技术(或者更好的称呼是妥协)是将所有“不纯的”行为推到程序运行的末尾。通过这种方式，程序的大部分是“适当的”功能性的，能够被完全测试，并且容易推理，至少如果混乱不纯的部分有问题，它都在一个地方，并且你知道它发生在哪里。

那么，如何将所有的日志写到程序的末尾呢？一种方法是创建一个全局变量来收集要记录的信息，最后将它一次性写入磁盘。然而，正如我已经讨论过的，在函数式编程中，全局状态通常被认为是一个坏主意，因为您在函数流之外引入了状态，而您在任何时候都不能(容易地)推理或确信这一点。另一种方法是在进行过程中沿着函数链传递日志信息；每个函数都可以从上一个函数的输入中获取“日志”,添加自己的日志记录，并将日志作为其返回值的一部分传递给链中的下一个函数，只有在函数链中有最终值时才写入磁盘。这将是一个非常好的函数方式，除了这意味着您需要改变每个函数的签名来接受传递这些额外的数据，可能使用数组或类似的东西来保持日志信息和实际函数输出的分离和组织。你可能已经猜到了，问题的答案是作家莫纳德。

Writer monad 提供了一种方法，可以像您期望的那样编写和组合函数，而不必改变它们接受的参数。在后台，编写器 monad 用“写入的”信息(例如，在这种情况下，要记录的字符串)构建单独的数据结构，并且在 monad 函数链的末端，返回两个值(正常返回值和日志数据)。为了在实践中演示这一点，这次您将使用一个不同的单子库，名为`php-fp-writer`，由 Tom Harding 编写，您可以从 [`https://github.com/php-fp/php-fp-writer`](https://github.com/php-fp/php-fp-writer) 下载。你可以用 Composer 安装它，或者简单地包含我在这里展示的文件。

但是，在实现 Writer 示例之前，您需要创建一个称为幺半群的结构。在运行函数链时，monad 中需要一个结构来“收集”和保存日志消息(或者 Writer monad 将为您处理的任何数据)，monad 本身处理实际的函数返回值，就像前面的例子一样。

什么是幺半群？它的两个关键特性是，它有一个“关联二元运算”和一个“单位元素”在某些方面，幺半群感觉有点像单子；它包装一个值(保持静态)，应用一个函数，并返回一个新的幺半群作为输出，而不是对自身进行变异。数学家桑德斯·麦克兰恩在《工作的数学家》一书中说:

总之，X 中的幺半群只是 X 的内函子范畴中的幺半群，其乘积 X 被内函子的复合所取代，单位集被单位内函子所取代

对于不知道内函子是什么的外行人来说，解释这段引文，单子实际上只是更一般的幺半群的一个特例。像单子一样，你将创建单子作为对象。因为它们要简单得多，你将编写自己的幺半群类(见清单 [4-11](#Par76) )。您的对象将要执行的“关联二进制操作”是连接，在这种情况下，您将把(日志条目的)字符串连接到一个数组中。identity 元素是一个元素(或值),当对其他值执行操作时，这些值保持不变。对于串联(到一个数组中)，identity 元素是一个空数组。在这种情况下，您不打算使用 identity 元素，所以为了清楚起见，您将省略它，但是如果您愿意，您可以添加一个`empty()`方法，该方法返回一个以空数组作为其封装值的幺半群。

```php
<?php

class Monoid {

    public function __construct($value) {

        $this->value = $value;

    }

        public function concat($to) {

        return new Monoid(array_merge($to->value, $this->value));

    }

};

Listing 4-11.monoid.php

```

您将使用幺半群作为添加和保存日志数据的结构。然后你要写你的“有用的”纯函数，所以下面的事情发生了:

*   返回值是一个写者单子。
*   monad 是通过调用执行以下操作的`Writer::tell`静态方法创建的:
    *   创建一个附加了幺半群的编写器幺半群对象
    *   绑定实际“有用”的函数，准备在主函数值上调用

这允许您使用 monad 的 chain 方法将函数链接在一起。

为了使这一点更清楚，请看清单 [4-12](#Par84) (以及清单 [4-13](#Par85) )。您将使用上一章中的冰淇淋温度示例，该示例将温度作为一个整数，作为函数链的返回值。您还将收到第二个返回值，这是一组准备记录到磁盘或屏幕上的语句。正如您将注意到的，这个库创建和链接 monads 的方法与您看到的第一个库略有不同，这表明有多种方法可以为 monad cat 换肤，但它应该足够熟悉，以便理解正在发生的事情。如果你愿意，你总是可以用你之前看到的公理来测试以这种方式创建的单子，以确保你很高兴这就是你所使用的。

```php
<?php

include('src/Writer.php');
include('monoid.php');

use PhpFp\Writer\Writer;

function double($number) {

    $log = new Monoid(["Doubling $number"]);

    return Writer::tell($log)->map(

            function () use ($number)
            {
                    return $number * 2;
            }
    );
};

function negate($number) {

    $log = new Monoid(["Negating $number"]);

    return Writer::tell($log)->map(

            function () use ($number)
            {
                    return -$number;
            }
    );
 };

function add_two($number) {

    $log = new Monoid(["Adding 2 to $number"]);

    return Writer::tell($log)->map(

            function () use ($number)
            {
                    return $number + 2;
            }
    );

};

list ($mango_temp, $log) = double(6)->chain('negate')->chain('add_two')->run();

echo $mango_temp."°C\nLog :\n";

print_r($log->value);

Listing 4-12.
writer_monad.php

```

```php
-10°C
Log :
Array
(
    [0] => Doubling 6
    [1] => Negating 12
    [2] => Adding 2 to -12
)
Listing 4-13.writer_monad-output.txt

```

查看前面的输出，您可以看到您获得了正确的-10°c。您还获得了第二个数组，包含作为您调用的三个函数的结果的三个“log”字符串，您现在可以在您的“不纯”代码中使用它(例如，通过写入磁盘等)).这两个输出被包装到一个数组中，所以使用`list`语言构造将数组分成两个变量(`$mango_temp`和`$log`)。

关于前面的代码，需要注意的另一个有趣的地方是在函数链的末尾使用了`run()`方法。如果您忽略这一点并运行脚本，您会发现您的链中没有一个函数被真正调用。这种类型的 monad 构建函数链，然后只在构建后“运行”它。这对于测试非常有用，是典型的单子，可以帮助您处理潜在的副作用，您将在下一种单子 IO 单子中看到这一点。

## 木卫一单子

在前面的例子中，Writer monad，你把所有不纯的操作推到脚本的末尾，把你想操作的信息收集到一个数组中，一直带着它直到所有纯函数完成，然后把它和你的脚本的主返回值一起返回，以处理写入磁盘或类似操作的讨厌的副作用。这是处理副作用的好方法，但是在很多情况下，等到代码结束才开始与外部系统对话是不现实的。例如，您可能需要从外部来源(API、文件、数据库)收集输入，这些来源会根据某个纯函数中途进行的计算以及其他函数的计算而变化。你需要另一个工具来利用不纯的动作，这个工具就是 IO monad。您将使用 Tom Harding 的`php-fp-io`库，可从 GitHub 的 [`https://github.com/php-fp/php-fp-io`](https://github.com/php-fp/php-fp-io) 获得，它是早期`php-fp-writer`的姐妹库，因此遵循相同的结构和风格。

看一看下面的代码。该模式在 Writer monad 示例中应该很熟悉，但是正如您将看到的，您调用了三个被认为是不纯的函数/语言构造(它们有副作用),您需要在进行过程中调用它们。

*   `random_bytes`:这引入了来自外部状态源的值(在 Linux 上通常是`/dev/urandom`),当用于创建函数的返回值时，显然意味着从给定的输入参数集你将无法确定返回值。
*   这个函数(就像大多数文件系统函数一样)不能保证没有副作用，即使你没有从中读取未知的值。例如，如果文件或文件系统没有处于您期望的状态，就会产生错误和异常，因此您不能可靠地推断您的函数执行了预期的操作。
*   由于它只是输出到屏幕上(或网络服务器上)，也许你认为 echo 不会出什么问题，不会对你的功能造成问题/副作用？考虑一下，如果你的脚本有一个名为`fclose(STDOUT)`的地方，或者`STDOUT`流在你不知情的情况下从你的程序外部被关闭了；那么调用`echo`会导致你的程序在没有警告的情况下终止。

当然，还有许多其他函数具有与 I/O 相关的不同类型的副作用，您可以使用它们来演示这里的原理。

那么，让我们来看看你的剧本。你得到 100 个随机字节，并把它们转换成一个十六进制字符串(为了更容易印在书里！)，将它们写入一个名为`random.txt`的文件，最后向屏幕输出一条消息，确认你已经完成了任务。但是实际上你要把它分成两个脚本。第一个是`io_monad.php`，它设置了完成任务所需的所有函数，并创建了一个函数链。然后它“返回”最后一行的链。如果你没有见过像这样使用`return`(例如，在函数之外),不用担心。您这样写是为了在第二个脚本中可以“包含”第一个脚本作为函数体。注意`run_io.php`中 include 调用周围的括号；这些构成了一个立即调用的函数表达式(IIFE ),它执行 tin 上所说的内容:它立即调用括号内的代码，就好像它是一个被调用的函数一样。这是 PHP RFC 关于统一变量语法的一部分，是作为 PHP 7 的一部分引入的。因为第一个文件中的代码被作为函数调用，`return`语句现在应该更有意义了！参见清单 [4-14](#Par95) ，清单 [4-15](#Par96) ，清单 [4-16](#Par97) ，清单 [4-17](#Par98) 。

```php
<?php

include('src/IO.php');

use PhpFp\IO\IO;

# Some functions that define how to create
# some other, impure functions

# Make a random string of hex characters from $length random bytes

$string_maker = function($length) {

    return new IO( function () use ($length) {

                                        return bin2hex(random_bytes($length));

                                        }

                                 );
};

# Write a string to $filename on disk

$file_writer = function($filename) {

    return function ($string) use ($filename)  {

        return new IO( function () use ($filename,$string) {

                                    file_put_contents($filename,$string);

                                    }
                                 );
                    };
};

# Send ($string) to STDOUT

$printer = function($string) {

    return function () use ($string)  {

        return new IO( function () use ($string) {

                                    echo($string."\n");

                                    }

                                 );
                    };
};

# Chain those functions together, and return the resulting
# monad

return  $string_maker(100)
                                                ->chain($file_writer('random.txt'))
                                                ->chain($printer('All done'));

Listing 4-14.io_monad.php

```

```php
<?php

# Start an IIFE

(

    # Execute the io_monad.php file to get the monad

    require('io_monad.php')

    # At this stage, we have a monad full of functions
    # that have not been called (and so haven't done)
    # any "impure" work

# Finally call the unsafePerform() method on the monad to
# call the "impure" functions

)->unsafePerform();

Listing 4-15.run_io.php

```

```php
All done
Listing 4-16.run_io-output.txt

```

```php
935998b29780e9f8f56435120208f7196854f677a666abcc510fee8a7162d12f6d923e470b4373f232dfbb0bf1a9da28e9b8a3f84af15273fc516ccf74c493ebce3931922a59d83ba80d77cfc41e8c76ffd90d79d91e32bcf2fbdf15a85ec38b1c5186cc
Listing 4-17.random.txt

```

所以，这里发生的事情是，在`io_monad.php`中，你使用 IO 单子以类似于 Writer 单子的方式设置你的函数链。在第二个文件`run_io.php`中，您实际上使用名副其实的`unsafePerform()`方法调用了这个函数链。为什么要这样构造呢？第一个文件中的所有函数在实际运行之前都是“纯”的。第一个文件中的函数仅仅构造不纯的函数(通常称为延迟函数)；他们实际上并不运行它们，也不做任何 I/O，所以它们就像积雪一样纯净。这意味着`io_monad.php`，就其本身而言，是一个纯粹的函数式程序，可以进行全面的测试、推理等等。如果这看起来有点像欺骗，那是因为它是。测试的价值可能是有限的，因为它可能不会测试你的程序的“肉”,其中大部分功能依赖于不纯的动作。当然，您并不局限于以这种方式使用不纯函数；你可以巧妙地将它们与纯调用和其他单子混合在一起，所以当你的程序更多的是纯的而不是不纯的时候，像这样构造它的可测试性就会增加。

## 了解更多关于单子的信息

如果前几节已经让你对单子感到兴奋，那么接下来的“进一步阅读”部分将帮助你了解单子背后的数学细节和理论。警告:有时阅读量会很大，所以先给自己冲杯咖啡。如果你对单子不感兴趣，那么你会对第 7 章[感兴趣，这一章着眼于结构化应用(剧透:我建议完全可以忽略单子及其同类)。](07.html)

### 进一步阅读

*   单子的维基百科条目，给出了一般背景
    *   [T0](https://en.wikipedia.org/wiki/Monad_(functional_programming)T1】
*   维基百科中关于幺半群的条目，再次给出了一般背景
    *   [T2`https://en.wikipedia.org/wiki/Monoid`](https://en.wikipedia.org/wiki/Monoid)
*   单子和生殖腺道格拉斯·克洛克福特的谷歌技术演讲视频，他用 JavaScript 解释单子，以一种合理的可理解的方式
    *   [T2`https://www.youtube.com/watch?v=b0EF0VTs9Dc`](https://www.youtube.com/watch?v=b0EF0VTs9Dc)
*   不要害怕单子，布莱恩·贝克曼解释单子的 MSDN 视频，这次用了更多的数学
    *   [T2`https://www.youtube.com/watch?v=ZhuHCtR3xq8`](https://www.youtube.com/watch?v=ZhuHCtR3xq8)
*   Haskell 手册中关于单子的部分(Haskell 负责在编程中推广单子，这是对单子相当简洁的处理。)
    *   [T2`https://wiki.haskell.org/Monad`](https://wiki.haskell.org/Monad)
*   三个单子公理的(面向 Haskell 的)解释
    *   [T2`https://wiki.haskell.org/Monad_laws`](https://wiki.haskell.org/Monad_laws)
*   单子的物理类比，来自 Haskell wiki，通过 Wayback 机器
    *   [T2`https://web.archive.org/web/20100910074354/http://www.haskell.org/all_about_monads/html/analogy.html`](https://web.archive.org/web/20100910074354/http://www.haskell.org/all_about_monads/html/analogy.html)
*   相当全面的 monad 教程和相关文章的时间表；虽然它在 Haskell wiki 上，但它不是 Haskell 特有的
    *   [T2`https://wiki.haskell.org/Monad_tutorials_timeline`](https://wiki.haskell.org/Monad_tutorials_timeline)

## 蹦床递归

如果你认为蹦床只对孩子有意思，你显然不是一个函数式程序员！在前一章中，你已经看到了递归，它是一种非常有用的程序控制形式，在很多情况下可以用来代替传统的命令式循环。我还提到了一个主要的缺点，那就是(潜在地)无限的资源使用导致了堆栈溢出等等。

在递归中，你创建一个函数，然后这个函数调用它自己。PHP(和大多数编程语言)的工作方式是，对于每个仍然活动的函数，关于该函数的信息保存在调用堆栈中。每次你的函数调用它自己，一个新的函数就被激活；因此，另一帧信息被添加到堆栈中，使用更多的内存来保存程序的当前状态。原始函数仍然是活动的，等待它刚刚调用的自身复制的结果，所以在复制完成之前它不能从堆栈中移除，依此类推。只有当递归函数的最内层调用完成时，堆栈才会展开，然后所有先前的函数也可以完成。如果在此之前用完了分配的内存，就会出现堆栈溢出错误(或者机器崩溃，这取决于对堆栈大小的任何强制限制)。与简单的`while`或`for`循环相比，这里唯一保持的状态是任何相关变量的当前状态。每个循环可能会改变它们，但(通常)不会增加所保存的状态信息量。

因此，避免递归问题的一个方法是不使用它，重写任何递归函数，这些函数可能会像命令循环一样破坏堆栈。然而，这不是很实用，意味着你错过了编写递归代码的好处。当然，您可以在代码中进行一些硬限制检查，以确保您的递归只在那些您可以保证它将在可用堆栈/内存限制内完成的值上调用，但是这些可能很难预先确定，这意味着一些计算根本无法完成。

许多语言提供了一种叫做尾部调用优化(TCO)的解决方案。这是编译器使用的一个技巧，让它将某些递归函数展平成命令式的循环结构。当递归调用(对自身的实际调用)是函数中的最后一次调用(尾部调用)，只调用自身时，会发生这种情况。此时，编译器可以重用包含函数状态的帧，而不是创建额外的帧，因为它知道调用函数没有其他操作要执行。这极大地减少了存储的信息，实际上使递归变成了一种循环。

不幸的是，PHP 虚拟机不使用 TCO。如果是的话，你可以确保你的递归函数是在函数的末尾用递归调用编写的。相反，您可以使用一个 trampoline 函数来完成基本相同的任务。在计算中，trampoline 是一个自动创建另一个函数来帮助调用另一个函数的函数，在这种情况下“弹跳”您的函数以避免递归！

在看蹦床函数之前，有必要全面了解一下什么是尾调用。尾部呼叫具有以下特征:

*   是递归的(即，它必须是调用自身的函数)
*   必须是返回语句(即`return this_function()`)
*   必须只返回它自己
*   必须是最后执行的函数，如果它是一个“返回”值
*   调用中必须没有其他操作发生(即不返回`$something+this_function()`)

如果你的功能不满足这些标准，那么它就不能被 TCO'd，你的蹦床就不能工作。有很多方法可以将大多数递归函数重写为尾调用递归函数(TCR ),如果需要的话，可以搜索一下。

对于这个例子，您将使用大多数 TCO 文章使用的经典例子——阶乘函数。如果你不熟悉，一个数 x 的阶乘(通常写成 x！)是 x * (x-1) * (x-2) * … * (1)。换句话说，5！= 5 × 4 × 3 × 2 × 1 = 120.这可以在标准递归函数中实现，并且总是有一个递归尾调用。您将使用 Gilles Crettenand 编写的函数式 PHP 库中的一个蹦床实现，该实现可从 GitHub 的 [`https://github.com/functional-php/trampoline`](https://github.com/functional-php/trampoline) 获得；可以通过 Composer 安装，也可以直接包含。参见清单 [4-18](#Par131) 和清单 [4-19](#Par132) 。

```php
<?php

# Include and use the trampoline library

include('trampoline/src/Trampoline.php');
include('trampoline/src/functions.php');

use FunctionalPHP\Trampoline as T;

# First define our standard recursive function

$factorial = function ($i, $total = 1) use (&$factorial) {

        # if $i is 1, return the total, otherwise
        # recursively call the function on $i-1,
        # multiplying the accumulating total by $i

    return $i == 1 ? $total : $factorial($i - 1, $i * $total);

        # note that $factorial is the tail call here
        # when it is returned

};

# Now the same function again, but this time using the
# trampoline function. The only difference (other than
# the name!) is that we wrap the tail call in T\bounce()

$bounced_factorial = function ($i, $total = 1) use (&$bounced_factorial) {

    return $i == 1 ? $total : T\bounce($bounced_factorial, $i - 1, $i * $total);

};

# We use T\trampoline() to call the "bounced" function.
# We'll wrap it in a helper function called $trampolined
# for ease of use

$trampolined = function ($i) use ($bounced_factorial) {

    return T\trampoline($bounced_factorial, $i);

};

# We'll create a function to time how long our
# function runs take, in seconds

$timer = function($func, $params) {

    $start_time = microtime(true);

    call_user_func_array($func,$params);

    return round(microtime(true) - $start_time,5);

};

# So let's run our normal recursive function
# and the trampolined version, both to
# calculate the factorial of one hundred thousand.
# The result will be the same, we're only
# interested in the time they take here.

var_dump ( $timer($factorial, [100000]) );

var_dump ( $timer($trampolined, [100000]) );

# Now let's limit the memory we're working with
# and run them again, this time to calculate
# the factorial of one million. We'll run the
# trampolined first, for reasons that you will
# see.

ini_set('memory_limit','100M');

var_dump ( $timer($trampolined, [1000000]) );

var_dump ( $timer($factorial, [1000000]) );

Listing 4-18.
bounce.php

```

```php
float(0.0254)
float(0.07143)
float(0.63219)
PHP Fatal error:  Allowed memory size of 104857600 bytes exhausted (tried to allocate 262144 bytes) in bounce.php on line 18
Listing 4-19.bounce-output.txt

```

如果您看一下输出，您会看到标准递归函数(第一行)的运行速度要比蹦床版本(第二行)快得多。然而，当您开始处理大数字时，尽管践踏版本需要更长的时间来运行(第三行)，递归版本(第四行)会耗尽内存并关闭脚本。

因此，使用蹦床的代价是较低的性能(就执行时间而言)。在某些情况下，这可能意味着您坚持使用普通的递归版本。但是要记住，完成速度较慢的函数通常比完成速度较快的函数要好。考虑你的脚本的用户将会有哪些可用的资源，以及你期望你的脚本处理哪些输入，并且在适当的时候使用一个蹦床版本来安全地运行它。

### 递归 Lambdas

有趣的是，注意我之前写阶乘函数的方式。我使用闭包而不是命名函数，这在像这样的玩具程序中纯粹是出于选择，但是在真实的程序中，您可能有很好的理由这样做，以允许您获得我在本书前面谈到的闭包带来的优势。现在，递归函数(无论是命名函数还是闭包)需要能够调用自身。对于命名函数来说，这很简单；它在全局空间中有一个名字，所以你可以很容易地从它内部调用它。然而，在一个闭包里，这就不那么简单了。因为从技术上来说，它是一个对象，这里你通过把它赋给一个全局变量，在全局范围内声明了它，它不存在于它本身的范围内。您可能认为您只需要“使用”您赋予它的变量，就像您在闭包中使用任何变量一样。如果您尝试这样做，您将得到一个错误，因为您只能“使用”一个存在的变量(因此有一个值，因为默认情况下您在 PHP 中通过值传递)。变量直到闭包创建后才存在，在此期间，错误将会发生，因为变量不存在！正如您将从我的代码中看到的，解决方法是通过引用`use`子句来传递它(在变量前放置一个&符号)，这回避了还没有值被传入的事实。

这种递归闭包通常被称为递归 lambda (lambda 是匿名函数的另一种说法)或匿名递归。传统的编程智慧(不管是什么)宣称这是不可取的，要在命名函数上实现递归以保持代码清晰易懂。然而，许多语言都支持匿名递归，比如 JavaScript，它提供了反射功能使之变得更容易，正如你所看到的，我喜欢它！一如既往地务实，看看什么最适合你的代码。

## PHP 类型系统

您可能知道，PHP 是一种动态类型语言，与静态类型语言相反。它也是弱类型的而不是强类型的。这意味着您不必指定类型(整数、字符串、布尔值等。)声明变量时(在编译时)。该类型是隐式的，由运行时分配给变量的值决定。弱类型意味着您可以通过为其分配不同的值来更改类型。当需要处理变量时，PHP 会自动将变量的类型转换为所需的类型，例如，当您试图添加一个整数和一个字符串时。在 PHP 中使用弱动态类型非常有用，但这也是很多新手(特别是那些来自静态或强类型语言的人)犯的错误，并导致 PHP 的一些负面关注。为什么 PHP 是动态/弱类型的？好吧，回到时间的迷雾中，当拉斯马斯·勒德尔夫创建 PHP 时，它的目的是作为一种简单、直接的方式来创建交互式网站，而不是一种完全成熟的通用编程语言。当时使用弱动态类型似乎是显而易见的；毕竟，它是为处理网站而设计的，对于 HTTP 来说，没有整数和布尔值的概念——一切都是字符串！因此，如果脚本中的所有内容都是强静态类型的，那么要获得任何有用的值作为输入并将任何内容作为输出发送回来，您的脚本将需要进行大量的类型争论。那么，为什么不把所有的麻烦都去掉，让它变得弱而有活力呢？

相比之下，在大多数函数式编程语言中，强静态类型非常流行。以 Haskell 为例；它有一个强大的静态类型系统，尽管这种被推崇为函数式编程典范的语言也用其恰当命名的动态类型向动态语言的实用性致敬。静态类型在函数式编程中占重要地位的主要原因可以追溯到函数式编程带来的一个主要优势:轻松阅读和推理代码的能力。思路是，如果您被迫在代码中显式声明变量的类型(包括函数的参数类型)，那么在给定特定函数的定义的情况下，您可以很容易地推断出当您通读函数实现时，任何给定的输入将会发生什么。当然，除了函数式编程之外，静态类型化还有其他很好的理由，比如编译器/解释器能够在程序开始运行之前发现某些类型的错误。

当然，也有不利的一面，并不是每个人(包括我)都认为静态类型在函数式编程中完全是一件好事，尤其是在 PHP 中。正如您马上会看到的，尽管它本质上是动态的，PHP 确实有一个类型声明系统，以前称为类型提示，可用于建议或强制函数参数和返回类型的特定类型。但是，使用这种语法工具只能带来有限的好处。它不是强类型，所以当变量作为参数传入时，虽然您(和编译器)可以推断变量的类型，但是一旦您在函数中对变量做了任何事情，任何显式类型保证都将失效。并且假设您从一个打开严格类型检查的文件中调用该函数；否则，它只不过是“指导”，在任何阶段都不提供任何保证，只是试图将一种类型扯到另一种类型。尽管好处不多，但声明每种类型的额外语法降低了代码的简洁性和可读性。但是没有输入信息，你怎么能对你的代码进行推理呢？我建议你用同样的方式来思考这个问题，即使你使用了类型声明。如前所述，函数的内部(因此，代码库的很大一部分)将不会考虑您所做的类型声明。以清单 [4-20](#Par140) (和清单 [4-21](#Par141) 为例。

```php
<?php

declare(strict_types=1);

function my_function(bool $a) {

var_dump($a);

$a = $a * 22;

var_dump($a);

};

my_function(true);

Listing 4-20.types1.php

```

```php
bool(true)
int(22)
Listing 4-21.types1-output.txt

```

如您所见，您已经用`declare`语句打开了严格类型，并且使用了类型声明来声明`$a`是一个布尔值。在第一个`var_dump`中一切都是好的，但是等等，第二个`var_dump`告诉你`$a`是一个整数。“当然，”你说，“当你把一个布尔值乘以一个数时，PHP 把这个布尔值转换成一个`int`，`true`变成 1，所以 1 * 22 是 22，这是一个`int`，所以这是意料之中的。”很好。我刚刚展示了在使用类型声明时如何对代码进行推理，这是通过理解 PHP 使用的动态类型系统来实现的。您可以使用这些知识以同样的方式推理非类型化函数。事实上，你不一定知道你开始的类型，这并不会让你远远落后于你知道的情况。事实上，如果您的函数可能被不使用严格类型的其他人使用，那么假设您的类型声明会受到尊重而不是防御性地编码可能是危险的。PHP 只对用`declare(strict_types=1)`语句从文件中调用的函数执行严格的类型检查，不管定义该函数的文件是否有该声明。因此，如果您的函数假设它将接收一个整数，因为您已经将`int`指定为类型声明，并在您的文件中打开了严格类型，但是其他人包含了不使用严格类型的文件，那么您的函数很可能会改为使用`float`来调用。当发生这种情况时，在许多情况下，PHP 可以将一种类型强制转换为另一种类型，不会抛出类型错误。float 会被悄悄地强制成整数值(截断，有人吗？).这种强制是在正常的 PHP 规则下发生的，当它需要争论类型时就会发生，但是您的代码不知道它已经发生了，即使您预料到了，您也不能测试它。如果没有类型声明，您的函数将获得 float，因此您可以测试它，并选择当您想要的是整数时如何处理它。

另外，纯函数式编程语言(和/或程序员)经常在代码中避免赋值，部分是为了确保不变性。例如，在这种情况下，不为变量赋值将保证类型保持不变。但是，没有分配导致疯狂，所以你不会在这里练习那种黑暗的艺术。

在使用类型声明进行函数式编程时，另一个问题(尽管更具理论性)是 PHP 只允许在函数之外捕捉和处理类型错误(例如，通过将函数调用封装在`try` / `catch`块中)，这意味着这种错误实际上是副作用。如果你回头看看第 [2](02.html) 章中关于副作用的讨论，你会发现如果你在函数本身内部捕捉并处理一个错误，那么就没有副作用。最好的方法是在函数中处理参数和任何必要的测试/转换，这意味着不要使用类型声明。

正如您所猜测的，许多开发人员和专家认为，即使是 PHP 的有限类型强制也是利大于弊的，归根结底，决定您是否在特定程序或函数中使用类型声明的通常是个人选择或实用考虑。在本书的其余部分中，您不会使用它们来保持代码的整洁并专注于其他主题，但是在这里，如果您想要或需要，我将概述如何使用 PHP 类型系统。

## 类型声明

在 PHP 5 中，类型声明被称为类型提示。5 和 7 之间的主要区别(除了名称更改)如下:

*   在 5 中，违反类型提示会导致可恢复的致命错误；在 7 中，不符合类型声明会导致类型错误。
*   在 5 中，提示支持的类型只有`class` / `interface`、`self`、`array`和`callable`。7 中的声明添加了标量(`bool`、`float`、`int`、`string`)类型。
*   仅在 7 中支持严格类型。
*   仅在 7 中支持返回类型。

注意，根本不支持类型别名，所以例如，您不能使用`boolean`来指定`bool`类型。PHP 将别名视为类名，所以它会假设类型为`boolean`的参数期待来自`boolean`类的对象，而不是`bool`(真/假)标量变量。

您也可以将参数设置为“可空”也就是说，它将接受空值以及指定类型的值。为此，通过在参数名称后添加`=null`将参数的默认值设置为 null。

除了为每个参数指定类型之外，还可以为返回值指定类型。参数类型在每个参数之前，返回类型在参数列表之后用冒号和 type 指定。

打开严格类型(在 PHP 7 中可用)后，与指定类型不匹配的参数或返回值将导致类型错误。关闭严格类型(这是默认设置)，在 PHP 的正常规则下，参数和返回值将被强制转换为指定的类型，而不会抛出错误。如果强制是不可能的(例如，从字符串“hello”到整数)，则抛出类型错误。

您可以在同一个函数中混合和匹配带有和不带声明类型的参数。同样，指定返回类型是可选的，不依赖于指定参数类型。

让我们看看一些示例代码中的这些要点(参见清单 [4-22](#Par157) ，清单 [4-23](#Par158) ，清单 [4-24](#Par159) ，清单 [4-25](#Par160) )。

```php
<?php

# Examples of non-strict typing

# Our function accepts two nullable ints, and returns an int

$add = function (int $a = null, int $b = null) : int {

    return $a + $b;

};

var_dump( $add(7, 3) ); #10

var_dump( $add(2.5, 4.9) ); #6, not 7.4

var_dump( $add("5Three", "6Four") ); #11, plus Notices thrown

var_dump( $add(true, false) ); #1 (true == 1, false == 0)

var_dump( $add(null, null) ); # 0 (null is coerced to 0)

var_dump( $add("Three", "Four") ); # Type Error

Listing 4-22.types2.php

```

```php
int(10)
int(6)
PHP Notice:  A non well formed numeric value encountered in types2.php on line 7
PHP Notice:  A non well formed numeric value encountered in types2.php on line 7
int(11)
int(1)
int(0)
PHP Fatal error:  Uncaught TypeError: Argument 1 passed to {closure}() must be of the type integer, string given, called in types2.php on line 23 and defined in types2.php:7
Stack trace:
#0 types2.php(23): {closure}('Three', 'Four')
#1 {main}
  thrown in types2.php on line 7
Listing 4-23.types2-output.txt

```

```php
<?php

# Turn on strict typing

declare(strict_types=1);

# A function which accepts $a of any type,
# and a nullable int $b, and return a
# value of type int

$divide = function ($a, int $b = null) : int {

    if ( ($a / $b) == intdiv($a, $b) )  {

        return intdiv($a, $b); # returns an integer

    } else {

        return $a / $b; # returns a float (not good!)

    }

};

# As we'll be experiencing a lot of errors, lets create
# a function to catch and deal with the errors so the
# script can complete all of our calls without dying

function run($func, $args) {

    try {

        # run the function and var_dump the return result

        var_dump( call_user_func_array($func, $args) );

    } catch ( Error $e ) {

        # print the error message if one occurs

        echo "Caught : ".$e->getMessage()."\n";

    }

};

run( $divide, [10, 2] ); # int(5)

run( $divide, ["10","2"]); # Type Error, as no type coercion

run( $divide, [10, 2.5] ); # Type Error, as no type coercion

run( $divide, [true, false] ); # Type Error, as no type coercion

run( $divide, [23, null] ); # Division by zero warning & intdiv type error.
# Note that our input parameter is declared an int, and intdiv requires
# an int. But we still get an error, because ints are nullable in
# user function parameters, but not in all PHP function parameters

run( $divide, [10,3]); # Return Type Error (float 3.3333333...)

run( $divide, [6.4444 % 4.333, 9.6666 % 2.0003]); # int(2)
# all that matters is the type of the value of an expression passed
# as a parameter, not the types of the operands of that expression.

Listing 4-24.types3.php

```

```php
int(5)
Caught : Argument 2 passed to {closure}() must be of the type integer, string given, called in types3.php on line 36
Caught : Argument 2 passed to {closure}() must be of the type integer, float given, called in types3.php on line 36
Caught : Argument 2 passed to {closure}() must be of the type integer, boolean given, called in types3.php on line 36
PHP Warning:  Division by zero in types3.php on line 13
Caught : intdiv() expects parameter 2 to be integer, null given
Caught : Return value of {closure}() must be of the type integer, float returned
int(2)
Listing 4-25.types3-output.txt

```

因此，正如你所看到的，如果你使用类型声明，最好确保你知道所有关于它们如何操作的注意事项，不要让自己陷入虚假的安全感。例如，如果您打开了严格类型，声明函数的返回类型为`float`，并尝试返回一个`int`，您认为会发生什么？还记得我说过 PHP 不会试图强制类型吗？所以，你应该得到一个返回类型错误，对不对？让我们试试(见清单 [4-26](#Par162) 和清单 [4-27](#Par163) )。

```php
<?php

# Turn on strict typing

declare(strict_types=1);

# Declare two functions that are EXACTLY
# the same apart from the return type (and name).
# intdiv returns an integer. (int) casting
# ensures that even if we've somehow messed
# up, intdiv returns an int into $a, and
# the return value is forced to int.

$the_func_int = function () : int {

    $a = (int)intdiv(10,2);
    return (int)$a;

};

$the_func_float = function () : float {

    $a = (int)intdiv(10,2);
    return (int)$a;

};

var_dump( $the_func_int() ); # int(5). As expected.
var_dump( $the_func_float() ); # float(5). Errr?!

Listing 4-26.types4.php

```

```php
int(5)
float(5)
Listing 4-27.types4-output.txt

```

没有错误，当它离开你的手的时候，返回一个肯定是`int`的东西，从另一端出来就是一个 float！考虑到这一点，这是有意义的，因为 PHP 中任何有效的`int`都可以表示为一个有效的 float。但是假设严格的类型化坚持使用完全相同的类型名，例如，`var_dump`，就会带来麻烦。你可以在 PHP 手册中了解更多关于类型声明的细节。

### 进一步阅读

*   PHP 手册中的类型声明
    *   [T2`http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration`](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration)
*   PHP 手册中的返回类型声明
    *   [T2`http://php.net/manual/en/functions.returning-values.php#functions.returning-values.type-declaration`](http://php.net/manual/en/functions.returning-values.php#functions.returning-values.type-declaration)

作为一个有点轻率的事后想法，认为这个世界上没有什么新的东西。在 Perl、PHP 和 Python 这样的新贵带着他们时髦的现代弱动态系统出现之前，强静态类型是多年前类型管理的主要形式，这是未来的发展方向。读一读最近的 PHP“最佳实践”网站，或者听听伟大的 PHP 改革家们讲述他们希望如何发展这门语言，你很快就会发现，对于 PHP 来说，要真正完成向现代范式的转变，它需要有适当的强大的静态类型……于是轮子又转了。

## 摘要

在这一章中，你看了几个更高级的函数式编程主题。当您得知许多纯函数式语言的程序员将这些视为一般的主题时，您不会感到惊讶，事实上，您可能会发现它们在解决许多函数式“问题”时非常有用鉴于一些函数式语言缺乏命令性和“不纯”的功能，它们是完成任何实际工作所必需的。然而，由于 PHP 提供了将函数式代码与命令式代码混合和匹配的灵活性，并且假设您不是执意只编写函数式代码，那么您通常可以在不使用这些技术的情况下编写函数式代码。用你作为程序员的判断和经验来决定什么时候它们会增强你的程序，什么时候你只是为了“功能性”而写这样的代码。