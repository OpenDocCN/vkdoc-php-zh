# 19.安全 PHP 编程

任何暴露在互联网上的网站或服务都可以被认为是一座不断受到野蛮人攻击的城堡。正如传统战争和信息战的历史所显示的，攻击者的胜利并不完全取决于他们的技术或狡猾程度，而是取决于城堡防御中的一个疏忽。作为电子王国的守护者，您面临着大量可能造成破坏的潜在入侵，尤其包括:

*   **软件漏洞** : Web 应用程序由多种技术构建而成，通常是数据库服务器、Web 服务器和一种或多种编程语言——所有这些都运行在一个或多个操作系统上。因此，在攻击者利用问题之前，不断了解并解决所有任务关键型技术中新发现的漏洞至关重要。确保您的所有软件都安装了最新的安全补丁。这适用于操作系统以及用于网站或服务的软件堆栈。在许多情况下，该软件依赖于其他包中的库和功能，即使您的站点没有使用这些库和功能。

*   **用户输入**:利用因用户输入处理不当而产生的漏洞可能是对您的数据和应用程序造成严重损害的最简单方式，这一论断得到了无数此类成功攻击报告的支持。对通过 HTML 表单、URL 参数、cookies 和其他容易访问的途径传递的数据的操纵，使攻击者能够攻击应用程序逻辑的核心。这可能是网站中开发者控制力最强的部分。开发人员有责任以消除安全漏洞的方式编写代码。永远不要相信任何对你的网站或服务的输入。它被暴露在互联网上，任何了解它的人都可以使用他/她所拥有的任何工具来尝试访问数据或注入恶意代码。

*   **保护不力** **数据**:数据是你公司的命脉；丢失风险自担。然而，由于容易识别的 URL，数据库帐户常常受到可疑密码的保护，或者基于 web 的管理控制台大开方便之门。这些类型的安全失误是不可接受的，尤其是因为它们很容易解决。

因为每种情况都对您的应用程序的完整性构成了巨大的风险，所以必须对所有情况进行彻底的调查并做出相应的处理。这一章回顾了你可以采取的许多步骤来对冲——甚至消除——这些危险。

### 小费

验证和净化用户输入是一个非常严肃的问题，所以我不想等到本版的第 19 章来讨论这个话题。因此，关于处理用户输入的重要信息已被移至第 [13 章](13.html)。如果你还没有仔细阅读这些材料，我强烈建议你现在就阅读。

## 安全地配置 PHP

PHP 提供了许多配置参数，旨在大大提高其安全意识水平。本节介绍了许多最相关的选项。

### 注意

多年来，PHP 提供了一个被称为安全模式的特定于安全的选项，它试图通过限制对 PHP 的许多本机特性和功能的访问来使 PHP 和 web 服务器更加安全。然而，由于安全模式解决的问题越多，产生的问题也越多，很大程度上是因为企业应用程序需要使用安全模式禁用的许多特性，所以开发人员决定从 PHP 5.3.0 开始弃用该特性。因此，尽管你会在网上找到很多关于安全模式的参考，你应该避免使用它，而是寻求实现其他的安全措施(其中很多在本章中介绍)。

### 与安全相关的配置参数

本节介绍几个配置参数，它们在更好地保护 PHP 安装中起着重要作用。在你开始深入这一部分之前，你应该考虑你的网站或服务的托管环境。如果您在一个共享环境中，您可能对 PHP 配置有有限的控制，并且您将与同一主机的其他用户共享可用资源。如果另一个网站使用了所有的磁盘空间或内存，您的网站可能会停止工作或变得不稳定。我建议使用专用的托管环境，如虚拟专用服务器(VPS)或专用硬件。

#### disable_functions = *字符串*

范围:`PHP_INI_SYSTEM`；默认值:`NULL`

您可以将`disable_functions`设置为您想要禁用的函数名的逗号分隔列表。假设您只想禁用`fopen()` `, popen()` `,`和`file()`功能。如下设置该指令:

```
disable_functions = fopen,popen,file

```

这个选项通常用在共享主机环境中，主机提供商希望限制每个 PHP 开发人员可以访问的功能。在允许多个开发人员为同一个站点或服务编写代码的环境中，它也很有用。

#### disable_classes = *字符串*

范围:`PHP_INI_SYSTEM`；默认值:`NULL`

考虑到 PHP 对面向对象范式的接受所提供的新功能，用不了多久，您就可以使用大型类库了。然而，在这些库中可能有一些你不愿意使用的类。您可以使用`disable_classes`指令来阻止这些类的使用。例如，您可以完全禁用两个名为`administrator`和`janitor`T3 的类:

```
disable_classes = "administrator, janitor"

```

#### display_errors = *开* | *关*

范围:`PHP_INI_ALL`；默认值:`On`

在开发应用程序时，如果脚本执行过程中出现任何错误，立即得到通知是非常有用的。PHP 将通过向浏览器窗口输出错误信息来满足这一需求。但是，这些信息可能会被用来揭示有关您的服务器配置或应用程序的具有潜在破坏性的详细信息。当应用程序转移到生产环境时，请记住禁用此指令。当然，您可以通过将这些错误消息保存到日志文件或使用其他日志机制来继续查看它们。参见第 8 章了解更多关于 PHP 日志特性的信息。

#### max_execution_time = *整数*

范围:`PHP_INI_ALL`；默认值:`30`

这不是一个安全设置，而是一种控制脚本使用资源的方式。该指令指定脚本在终止前可以执行的秒数。这有助于防止用户的脚本消耗过多的 CPU 时间。如果`max_execution_time`设置为`0`，则不设置时间限制。在 PHP 的 CLI 版本中，这默认为 0，即使在 php.ini 中定义了另一个值。

#### 内存限制= *内存*

范围:`PHP_INI_ALL`；默认值:`128M`

同样，这不是一个与安全相关的选项，而是用于限制脚本可以使用的资源量。这个指令以兆字节为单位指定一个脚本可以使用多少内存。请注意，您不能用兆字节以外的术语来指定这个值，并且您必须始终在数字后面加上一个`M`。该指令仅适用于在配置 PHP 时启用了`--enable-memory-limit`的情况。

#### open _ base dir =字符串

范围:`PHP_INI_ALL`；默认值:`NULL`

PHP 的`open_basedir`指令可以建立一个基本目录，所有的文件操作都将被限制在这个目录中，就像 Apache 的`DocumentRoot`指令一样。这可以防止用户进入服务器的其他受限区域。例如，假设所有 web 资料都位于目录`/home/www`中。为了防止用户通过几个简单的 PHP 命令查看和潜在操纵文件，比如`/etc/passwd`，可以考虑这样设置`open_basedir`:

```
open_basedir = "/home/www/"

```

#### user_dir = *字符串*

范围:`PHP_INI_SYSTEM`；默认值:`NULL`

该指令指定用户主目录中的目录名，PHP 脚本必须放在该目录中才能执行。例如，如果`user_dir`被设置为脚本，用户 Johnny 想要执行`somescript.php`，Johnny 必须在其主目录中创建一个名为`scripts`的目录，并将`somescript.php`放入其中。然后可以通过 URL [`http://example.com/~johnny/scripts/somescript.php`](http://example.com/%257Ejohnny/scripts/somescript.php) 访问这个脚本。该指令通常与 Apache 的`UserDir`配置指令一起使用。

## 隐藏配置详细信息

许多程序员更喜欢把他们部署开源软件的决定作为一个徽章让全世界看到。然而，重要的是要认识到，您发布的关于您的项目的每一条信息都可能为攻击者提供重要的线索，这些线索最终可能被用来渗透您的服务器。考虑另一种方法，让您的应用程序保持独立，同时尽可能对技术细节保持沉默。尽管混淆只是整个安全画面的一部分，但它仍然是一种应该永远记住的策略。请记住，心怀不轨的人可以访问开源库的源代码，这使他们能够找到漏洞。

### 隐藏阿帕奇人

Apache 输出包含在所有文档请求和服务器生成的文档中的服务器签名(例如，500 内部服务器错误文档)。两个配置指令负责控制这个签名:`ServerSignature`和`ServerTokens`。

#### Apache 的服务器签名指令

`ServerSignature`指令负责插入与 Apache 的服务器版本、服务器名称(通过`ServerName`指令设置)、端口和编译模块相关的单行输出。当启用并与`ServerTokens`指令(接下来介绍)一起工作时，它能够显示如下输出:

```
Apache/2.4.18 (Ubuntu) Server at localhost Port 80

```

很可能你宁愿把这些信息留给自己。因此，考虑通过将其设置为`Off`来禁用该指令。

如果`ServerSignature`被禁用，则该指令没有实际意义。如果由于某种原因必须启用`ServerSignature`，考虑将指令设置为`Prod`。

#### Apache 的 ServerTokens 指令

如果启用了`ServerSignature`指令，则`ServerTokens`指令确定提供何种程度的服务器细节。有六种选择:`Full`、`Major`、`Minimal`、`Minor`、`OS`和`Prod`。表 [21-1](#Tab1) 中给出了各自的示例。

表 21-1

ServerTokens 指令的选项

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

[计]选项

 | 

例子

 |
| --- | --- |
| `Full` | Apache/2.4.18 (Ubuntu) PHP/7.2.1 服务器 |
| `Major` | Apache/2 服务器 |
| `Minimal` | Apache/2.4.18 服务器 |
| `Minor` | Apache/2.4 服务器 |
| `OS` | Apache/2.4.18 (Ubuntu)服务器 |
| `Prod` | Apache 服务器 |

### 隐藏 PHP

您可以掩盖 PHP 正在您的服务器上使用的事实。使用`expose_php`指令来防止 PHP 版本细节被附加到您的 web 服务器签名中。阻止对`phpinfo()`的访问可以防止攻击者了解你的软件版本号和其他关键信息。更改文档扩展名，使页面映射到 PHP 脚本不那么明显。

#### expose _ PHP =1 | 0

范围:`PHP_INI_SYSTEM`；默认值:`1`

启用时，PHP 指令`expose_php`将其细节附加到服务器签名中。例如，如果`ServerSignature`被启用，`ServerTokens`被设置为`Full`，并且该指令被启用，则服务器签名的相关组件将如下所示:

```
Apache/2.4.18 (Ubuntu) PHP/7.2.1 Server

```

当`expose_php`被禁用时，服务器签名将如下所示:

```
Apache/2.4.18 (Ubuntu) Server

```

#### 移除 phpinfo()调用的所有实例

`phpinfo()`函数为查看给定服务器上 PHP 的配置摘要提供了一个很好的工具。然而，如果在服务器上不受保护，它提供的信息对攻击者来说就是一座金矿。例如，这个函数提供关于操作系统、PHP 和 web 服务器版本、配置标志的信息，以及关于所有可用扩展及其版本的详细报告。让攻击者能够访问这些信息将极大地增加潜在攻击媒介被发现并随后被利用的可能性。

不幸的是，似乎许多开发人员没有意识到或不关心这样的披露。事实上，在搜索引擎中键入*phpinfo.php*会产生超过 400，000 个结果，其中许多直接指向执行`phpinfo()`命令的文件，因此提供了大量关于服务器的信息。快速细化搜索条件以包括其他关键字会产生初始结果的子集(旧的、易受攻击的 PHP 版本),这些结果可能成为攻击的主要目标，因为它们使用了已知的不安全版本的 PHP、Apache、IIS 和各种支持的扩展。

允许其他人查看来自`phpinfo()`的结果实质上相当于为公众提供了一个路线图，让他们了解你的服务器的许多技术特点和缺点。不要仅仅因为懒得删除或保护这个文件而成为攻击的受害者。使用`disable_functions`指令在生产环境中禁用该功能是一个好主意。

#### 更改文档扩展名

支持 PHP 的文档很容易通过它们独特的扩展名来识别，最常见的是`.php`、`.php3`和`.phtml`。你知道吗，这可以很容易地改变成你想要的任何其他扩展名，甚至是`.html`、`.asp`或`.jsp`？只需更改您的`httpd.conf`文件中的行，内容如下

```
AddType application/x-httpd-php .php

```

您可以随意扩展，例如

```
AddType application/x-httpd-php .asp

```

当然，您需要确保这不会导致与其他已安装的服务器技术或开发环境的冲突。或者，您也可以使用 web 服务器的 URL 重写功能来创建没有文件扩展名的更友好的 URL。

## 隐藏敏感数据

位于服务器文档树中并拥有足够权限的任何文档都是任何能够执行`GET`命令的机制的合理检索对象，即使它不是从另一个网页链接的，或者不以 web 服务器识别的扩展名结尾。不信服？作为练习，创建一个文件，在这个文件中输入*我的秘密*。将这个文件保存到你的公共 HTML 目录下，命名为*秘密*，使用一些奇怪的扩展名，比如`.zkgjg`。显然，服务器不会识别这个扩展名，但它会尝试检索数据。现在转到您的浏览器，使用指向该文件的 URL 请求该文件。很可怕，不是吗？

当然，用户需要知道他想要检索的文件的名称。然而，就像假定包含`phpinfo()`函数的文件将被命名为`phpinfo.php`一样，要找到受限文件，需要一点技巧和利用 web 服务器配置缺陷的能力。幸运的是，有两种简单的方法可以彻底纠正这个问题。这个问题由于开源库的使用而变得更加严重。任何其他开发人员/黑客都可以下载相同的库，并通读代码以找到利用该库的可能方法。当发现漏洞时，很容易扫描网站以检查它们是否暴露了漏洞。

### 隐藏文档根

Apache 的`httpd.conf`文件中有一个名为`DocumentRoot`的配置指令。这被设置为您希望服务器识别为公共 HTML 目录的路径。如果没有采取其他保护措施，则在此路径中找到的任何文件，如果分配了足够的权限，都能够得到服务，即使该文件没有可识别的扩展名。但是，用户不可能查看位于此路径之外的文件。因此，考虑将您的配置文件放在`DocumentRoot`路径之外。

要检索这些文件，您可以使用`include()`将这些文件包含到任何 PHP 文件中。例如，假设您像这样设置`DocumentRoot`:

```
DocumentRoot C:/apache2/htdocs    # Windows
DocumentRoot /www/apache/home     # Linux

```

假设您正在使用一个日志包，它将站点访问信息写入一系列文本文件。您肯定不希望任何人查看这些文件，所以将它们放在文档根目录之外是个好主意。因此，您可以将它们保存到先前路径之外的某个目录中:

```
C:/Apache/sitelogs/     # Windows
/usr/local/sitelogs/    # Linux

```

### 拒绝访问某些文件扩展名

防止用户查看某些文件的第二种方法是通过配置`httpd.conf`文件`Files`指令来拒绝对某些扩展名的访问。假设你不希望任何人访问扩展名为`.inc`的文件。将以下内容放入您的`httpd.conf`文件中:

```
<Files *.inc>
    Order allow,deny
    Deny from all
</Files>

```

添加之后，重新启动 Apache 服务器。您会发现，任何通过浏览器请求查看扩展名为`.inc`的文件的用户都被拒绝访问。但是，您仍然可以在脚本中包含这些文件。顺便说一下，如果你搜索一下`httpd.conf`文件，你会发现这是用来保护访问`.htaccess`的相同前提。

## 数据加密

*加密*可以定义为将数据转换成除目标方之外的任何人都无法读取的格式。然后，目标方可以通过使用某种秘密——通常是密钥或密码——对加密数据进行解码，或*解密*。PHP 支持几种加密算法；比较突出的在这里描述。

### PHP 的加密功能

在深入了解 PHP 的加密功能之前，有必要讨论一下它们的用法，这与解决方案无关。除非运行加密方案的脚本在支持 SSL 的服务器上运行，否则 Web 上的加密在很大程度上是无用的。为什么呢？PHP 是一种服务器端脚本语言，所以信息必须以纯文本格式*发送到服务器，然后才能被加密。如果用户没有通过安全连接进行操作，当信息从用户传输到服务器时，不希望的第三方可以通过多种方式看到这些信息。过去，为 web 服务器获取 SSL 证书是有成本的。最近几年价格已经下降，甚至还有像 [`https://letsencrypt.org`](https://letsencrypt.org) 这样的免费服务，可以让你获得有效期为三个月的 SSL 证书。他们甚至提供了一些工具来简化证书的更新。不再有任何借口不拥有使用 HTTPS 协议而不是 HTTP 的加密网站。如果您接受来自用户的任何形式的数据(用户 id、密码、信用卡信息等)。)，您应该始终提供到 web 服务器的加密连接。有关设置安全 Apache 服务器的更多信息，请访问 [`https://httpd.apache.org/docs/2.2/ssl`](https://httpd.apache.org/docs/2.2/ssl) 。如果您使用不同的 web 服务器，请参考您的文档。对于您的特定服务器，即使没有几个安全解决方案，至少也有一个。有了这个警告，让我们回顾一下 PHP 的加密函数。*

#### 使用 hash()散列函数散列数据

`hash()`函数可用于使用多种不同散列算法之一创建所谓的散列。哈希数据是一种不可逆的数据编码方式，因此它们不再可读；因为它是不可逆的，所以不可能从中产生原始价值。存储密码或创建数字签名时会使用哈希数据。如果您要验证密码或数字签名，您必须创建一个新的哈希值，并将其与存储的哈希值进行比较。反过来，数字签名可以用来唯一地识别发送方。它的原型是这样的:

```
string hash(string algo, string data [, bool raw_output])

```

支持许多不同的算法。这些有不同的复杂性。一种更简单的算法叫做 MD5。它不再被认为是安全的，不应以任何方式用于保护数据或访问网站。如今，像 sha256 或 sha512 这样的算法具有更高的复杂性，因此更难破解。

使用`hash_algos()`功能可以获得支持算法的完整列表。随着新算法的开发和添加到 PHP 中，您可以使用这个函数来检查当前可用的函数。当前列表如下所示:

```
Array
(
    [0] => md2
    [1] => md4
    [2] => md5
    [3] => sha1
    [4] => sha224
    [5] => sha256
    [6] => sha384
    [7] => sha512/224
    [8] => sha512/256
    [9] => sha512
    [10] => sha3-224
    [11] => sha3-256
    [12] => sha3-384
    [13] => sha3-512
    [14] => ripemd128
    [15] => ripemd160
    [16] => ripemd256
    [17] => ripemd320
    [18] => whirlpool
    [19] => tiger128,3
    [20] => tiger160,3
    [21] => tiger192,3
    [22] => tiger128,4
    [23] => tiger160,4
    [24] => tiger192,4
    [25] => snefru
    [26] => snefru256
    [27] => gost
    [28] => gost-crypto
    [29] => adler32
    [30] => crc32
    [31] => crc32b
    [32] => fnv132
    [33] => fnv1a32
    [34] => fnv164
    [35] => fnv1a64
    [36] => joaat
    [37] => haval128,3
    [38] => haval160,3
    [39] => haval192,3
    [40] => haval224,3
    [41] => haval256,3
    [42] => haval128,4
    [43] => haval160,4
    [44] => haval192,4
    [45] => haval224,4
    [46] => haval256,4
    [47] => haval128,5
    [48] => haval160,5
    [49] => haval192,5
    [50] => haval224,5
    [51] => haval256,5
)

```

如果使用 hash()函数创建存储在数据库中的值，需要确保数据库中的列足够宽，能够容纳所用算法的值。

例如，假设你的秘密密码 *toystore* 有一个`7518ce67ee48edc55241b4dd38285e876cb75b620930fd6e358d4b3ad74cac60`的 sha256 散列。您可以将此哈希值存储在服务器上，并将其与用户尝试输入的密码的 sha256 哈希值进行比较。即使入侵者得到了加密的密码，也不会有太大的不同，因为入侵者无法通过常规手段将字符串还原为其原始格式。下面是一个使用`hash()`散列字符串的例子:

```
<?php
    $val = "secret";
    $hash_val = hash('sha256', $val);
    // $hash_val = "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b";
?>

```

请记住，要在数据库中存储完整的 sha256 哈希，需要将字段长度设置为 64 个字符。虽然散列只有 256 bilt 长，但输出是用十六进制表示法编写的，每个字节使用两个字符。

虽然`hash()`函数可以满足大多数哈希需求，但是您的项目可能需要使用另一种哈希算法。PHP 的散列扩展支持许多散列算法和变体。在 [`http://us3.php.net/hash`](http://us3.php.net/hash) 了解更多关于这个强大扩展的信息。

请注意，MD5 函数已经显示为不同的输入提供相同的哈希值。这个函数不再被认为是安全的密码哈希或创建签名，但它可以用来创建一个文件的内容哈希。然后，散列可以存储在数据库中，当为另一个文件创建散列时，很容易比较该文件是否以前见过。如果您创建了一个用户可以上传图像的站点，这将非常有用。如果同一个图像被上传了不止一次，您可以检测到这一点，并简单地引用同一个图像。

PHP 提供了一个特殊的哈希函数来处理名为`password_hash()`的密码。这个函数将处理 salt 值和散列算法，对于相同的密码值，为相同的密码返回的字符串永远不会相同。为了将密码与保存的密码进行比较，您必须调用函数`password_verify()`。该函数将使用与创建原始散列相同的 salt 和算法来创建密码散列，然后比较两个散列值。接下来的两个示例显示了如何创建密码哈希以及如何验证密码:

```
<?php

$password = "secret";
$hash = password_hash($password, PASSWORD_DEFAULT);

echo $hash;
?>

```

执行此示例将生成如下输出:

```
$2y$10$s.CM1KaHMF/ZcskgY6FRu.IMJMeoMgaG1VsV6qkMaiai/b8TQX7ES

```

每次运行代码，都会生成不同的输出。为了验证密码，您可以使用类似于下例的代码:

```
<?php

$hash = '$2y$10$s.CM1KaHMF/ZcskgY6FRu.IMJMeoMgaG1VsV6qkMaiai/b8TQX7ES';
$passwords = ["secret", "guess"];

foreach ($passwords as $password) {
   if (password_verify($password, $hash)) {
      echo "Password is correct\n";
   }
   else {
      echo "Invalid Password\n";
   }
}

?>

```

在本例中，我们测试两个不同的密码。第一个是上一个示例中用于生成哈希的密码，第二个是不正确的密码。该代码生成以下输出:

```
Password is correct
Invalid Password

```

在实际应用程序中，您应该将密码的哈希存储在数据库或文件中。将真实密码存储在数据库中将允许该数据库的管理员读取其他用户的密码，并且他们将能够使用该密码进行恶意操作。

### 使用 OpenSSL 加密数据

谈到以安全的方式存储数据，PHP 提供了一个名为 OpenSSL 的库。这个库允许您使用加密密钥加密和解密值。如果您的硬盘或数据库遭到破坏，黑客将无法读取加密内容，除非您也将加密密钥留在了硬盘上。

有两种基本类型的密钥可用于加密和解密。第一种是对称密钥，加密和解密使用相同的密钥。第二种类型使用公钥和私钥对，其中一个密钥用于加密，另一个用于解密。这可以用来在交换信息时增加额外的安全层。如果发送方使用私钥加密，然后使用接收方的公钥再次加密该值，则接收方可以使用自己的私钥，然后使用发送方的公钥进行解密。这确保了只有预期的收件人可以打开文件，并且收件人肯定知道文件来自预期的来源。

使用非对称密钥对大量文本进行加密可能需要很长时间，加密方式通常略有不同，使用对称密钥对有效负载进行加密，然后使用一个或两个非对称密钥对简短的对称密钥进行加密，加密的有效负载和加密的对称密钥都将被交换。

在下一个例子中，我们将创建一个使用对称密钥加密和解密字符串的类。这将是对`openssl_encrypt()`和`openssl_decrypy()`函数的包装。这两个函数都有三个强制参数($data、$cipher 和$key)和五个可选参数。该示例利用了前两个可选参数($options 和$iv)。

密码值用于选择要使用的加密方法。该类默认使用 AES-128-CBC。通过调用`openssl_get_cipher_methods()`函数可以获得可用密码的完整列表。$iv 参数是初始化向量，它生成为对应于所选密码长度的多个随机字节值。函数`openssl_cipher_iv_length`()和`openssl_random_pseudo_bytes`()用于获取长度和随机字节列表。重要的是，加密和解密使用相同的初始化向量，以确保发生这种情况。$iv 值与签名哈希一起被添加到加密字符串的前面，在解密时可以使用签名哈希来确保该值不被更改。

```
<?php
//
class AES {
    private $key = null;
    private $cipher = "AES-128-CBC";

    function __construct($key, $cipher = "AES-128-CBC") {
        $this->key = $key;
        $this->cipher = $cipher;
    }

    function encrypt($data) {
        if (in_array($this->cipher, openssl_get_cipher_methods())) {
            $ivlen = openssl_cipher_iv_length($this->cipher);
            $iv = openssl_random_pseudo_bytes($ivlen);
            $encrypted = openssl_encrypt($data, $this->cipher, $this->key, OPENSSL_RAW_DATA, $iv);
            $hmac = hash_hmac('sha256', $encrypted, $this->key, true);
            return base64_encode($iv.$hmac.$encrypted);
        }
        else {
            return null;
        }
    }

    function decrypt($data) {
        $c = base64_decode($data);
        $ivlen = openssl_cipher_iv_length($this->cipher);
        $iv = substr($c, 0, $ivlen);
        $hmac = substr($c, $ivlen, $sha2len=32);
        $encrypted = substr($c, $ivlen+$sha2len);
        $hmac_check = hash_hmac('sha256', $encrypted, $this->key, true);
        if (hash_equals($hmac, $hmac_check)) {
            return openssl_decrypt($encrypted, $this->cipher, $this->key, OPENSSL_RAW_DATA, $iv);
        }
        else {
            return null;
        }
    }
}

```

下一个例子展示了如何使用扩展的简单例子。在这个例子中，使用的密钥是一个静态的纯文本字符串，但是一个更好的密钥可以是一个字符串的散列或一个随机字节的字符串。关键是加密和解密必须使用相同的密钥。

```
<?php
include "./aes.inc";

$aes = new AES('My Secret Key');

$e = $aes->encrypt("This message is secure and must be encrypted");
echo "Encrypted: '$e'\n";

$d = $aes->decrypt($e);
echo "Decrypted: '$d'\n";

```

输出将类似于下面的清单。由于初始化向量中的随机字节，输出将随着每次执行而改变。该示例显示消息被成功解密。

```
Encrypted: 'Nc+Oq+exEF1ZrepYbcV6f2XL8stA1WGJy5JmLPIqTOrRGfLWMIx9roLWgGEhbQppOv3VVXGxs4PJodKh7dQsviMUW9asCXDStbEfh+4PRZTQDFer/WQ9aOjKs9DF3kKm'
Decrypted: 'This message is secure and must be encrypted'

```

## 摘要

本章提供的材料为您提供了几个重要的提示，但主要目的是让您思考您的应用程序和服务器面临的许多攻击媒介。请注意，本章中描述的主题只是整个安全性的一小部分。如果你是这个主题的新手，花些时间访问著名的安全相关网站。

不管您以前的经验如何，您都需要设计一个策略来跟上突发的安全新闻。从更流行的以安全为中心的网站以及产品开发人员那里订阅时事通讯可能是最好的方法。最重要的是，你要有一个策略并坚持下去，以免你的城堡被征服。