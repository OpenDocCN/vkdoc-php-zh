# 2.PHP 和对象

对象并不总是 PHP 项目的关键部分。事实上，它们曾经被 PHP 的设计者描述为事后的想法。

事后想来，这一次已经被证明非常有弹性。在这一章中，我通过总结 PHP 面向对象特性的发展来介绍这本书对对象的覆盖。

我们将了解以下内容:

*   *PHP/FI 2.0* : PHP，但不是我们所知道的。

*   *PHP 3* :对象第一次出现。

*   *PHP 4* :面向对象编程长大了。

*   PHP 5 :语言的核心对象。

*   *PHP 7* :缩小差距。

*   *PHP 8* :盘整继续。

## PHP 对象的意外成功

有了 PHP 广泛的对象支持和如此多的面向对象的 PHP 库和应用，PHP 中对象的兴起似乎是一个自然而不可避免的过程的顶点。事实上，没有什么比这更偏离事实了。

### 一开始:PHP/FI

正如我们今天所知，PHP 的起源在于拉斯马斯·勒德尔夫使用 Perl 开发的两个工具。PHP 代表个人主页工具。FI 代表形式解释器。它们共同组成了向数据库发送 SQL 语句、处理表单和流程控制的宏。

这些工具用 C 语言重写，并以 PHP/FI 2.0 的名字组合在一起。这一阶段的语言看起来与我们今天认识的语法不同，但并没有那么不同。它支持变量、关联数组和函数。然而，天体甚至不在地平线上。

### 语法糖:PHP 3

事实上，甚至在 PHP 3 处于计划阶段时，对象就已经不在议程上了。PHP 3 的主要设计师是 Zeev Suraski 和 Andi Gutmans。PHP 3 完全重写了 PHP/FI 2.0，但是对象并没有被认为是新语法的必要部分。

根据 Zeev Suraski 的说法，对类的支持几乎是后来才添加的(准确地说是在 1997 年 8 月 27 日)。类和对象实际上只是定义和访问关联数组的另一种方式。

当然，方法和继承的增加使得类不仅仅是美化了的关联数组，但是对于如何处理类仍然有严格的限制。特别是，您不能访问父类的覆盖方法(如果您还不知道这意味着什么，请不要担心；后面我会解释)。我将在下一节中讨论的另一个缺点是 PHP 脚本中传递对象的方式不够理想。

这些物品在当时是一个边缘问题，这一点由于它们在官方文件中缺乏显著性而更加突出。手册中有一句话和一个代码示例是关于对象的。这个例子没有说明继承或属性。

### PHP 4 和安静的革命

如果说 PHP 4 是这种语言的又一个突破性进展，那么大多数核心变化都发生在表面之下。Zend 引擎(它的名字来源于 *Ze* ev 和一个 *nd* i)是从零开始编写的，为语言提供动力。Zend 引擎是驱动 PHP 的主要组件之一。您可能想调用的任何 PHP 函数实际上都是高级扩展层的一部分。它们完成了它们被命名为的繁忙工作，比如与数据库 API 对话或为您处理字符串。在此之下，Zend 引擎管理内存，将控制权委托给其他组件，并将您每天使用的熟悉的 PHP 语法翻译成可运行的字节码。我们必须感谢 Zend 引擎提供了像类这样的核心语言特性。

从我们的 *object* ive 的角度来看，PHP 4 使得覆盖父方法并从子类访问它们成为可能的事实是一个主要的好处。

然而，一个主要的缺点仍然存在。将一个对象赋给一个变量，将它传递给一个函数，或者从一个方法返回它，都会产生一个副本。考虑这样一个任务:

```php
$my_obj = new  User('bob');
$other  = $my_obj;

```

这导致存在两个用户对象，而不是对同一个用户对象的两个引用。在大多数面向对象的语言中，你会期望通过引用而不是通过值来赋值。这意味着您将传递并分配指向对象的句柄，而不是复制对象本身。默认的传值行为导致了许多不为人知的错误，因为程序员无意中修改了脚本中某个部分的对象，期望通过其他地方的引用看到这些更改。在本书中，你会看到很多例子，在这些例子中，我维护了对同一个对象的多个引用。

幸运的是，有一种方法可以强制按引用传递，但这意味着要记住使用笨拙的构造。

下面是如何通过引用进行分配:

```php
$other =& $my_obj;
// $other and $my_obj point to same object

```

这将强制按引用传递:

```php
function setSchool(& $school)
{
    // $school is now a reference to not a copy of passed object
}

```

此处通过引用返回:

```php
function & getSchool()
{
    // returning a reference not a copy
    return  $this->school;
}

```

尽管这样做很好，但是很容易忘记添加&符号，这意味着 bug 很容易潜入面向对象的代码。这些特别难以追踪，因为它们很少导致任何报告的错误，只是看似合理但不完整的行为。

PHP 手册扩展了一般语法的覆盖范围，特别是对象，面向对象的编码开始成为主流。PHP 中的对象并不是没有争议的(毫无疑问，当时和现在一样)，类似“我需要对象吗？”是邮件列表中常见的诱饵。事实上，Zend 网站上有很多鼓励面向对象编程的文章，还有一些警告性的文章。尽管存在传递引用问题和争议，但许多编码人员还是在代码中加入了与号字符。面向对象的 PHP 越来越受欢迎。齐夫·苏拉斯基在一篇为 DevX.com([`www.devx.com/webdev/Article/10007/0/page/1`](http://www.devx.com/webdev/Article/10007/0/page/1))写的文章中写道:

> PHP 历史上最大的转折之一是，尽管功能非常有限，尽管有许多问题和限制，PHP 中的面向对象编程仍然蓬勃发展，并成为越来越多的现成 PHP 应用最流行的范例。这种趋势出乎意料，让 PHP 陷入了一种不太理想的境地。很明显，对象的行为不像其他面向对象语言中的对象，而是像[关联]数组。

正如前一章所提到的，在网站和在线文章中，对面向对象设计的兴趣变得很明显。PHP 的官方软件库 PEAR 本身就采用了面向对象编程。事后看来，很容易认为 PHP 采用面向对象的支持是对不可避免的力量的不情愿的投降。重要的是要记住，虽然面向对象编程从 20 世纪 60 年代就已经存在，但它真正普及是在 90 年代中期。Java，这个伟大的普及程序，直到 1995 年才发布。作为过程语言 C 的超集，C++从 1979 年就出现了。经过长期的发展，它可以说在 20 世纪 90 年代实现了飞跃。Perl 5 于 1994 年发布，这是以前的过程化语言中的又一次革命，它使用户能够用对象来思考(尽管有些人认为 Perl 的面向对象支持也像是一种事后的想法)。对于一种小型的过程语言来说，PHP 开发其对象支持非常快，显示了对用户需求的真正响应。

### 拥抱变化:PHP 5

PHP 5 代表了对对象和面向对象编程的明确认可。这并不是说对象是使用 PHP 的唯一方式(顺便说一下，这本书也没有这么说)。然而，对象被认为是开发企业系统的强大而重要的手段，PHP 在其核心设计中完全支持它们。

可以说，PHP 5 增强的一个显著效果是更大的互联网公司采用了这种语言。都是雅虎！例如，脸书开始在他们的平台上广泛使用 PHP。在版本 5 中，PHP 成为互联网上开发和企业的标准语言之一。

对象已经从事后思考变成了语言驱动。也许最重要的变化是新的明显的按引用传递行为，它取代了对象复制的弊端。然而，这仅仅是开始。在本书中，尤其是在这一部分，我们将会遇到更多的增强，包括私有和受保护的方法和属性、static 关键字、名称空间、类型提示(现在称为类型声明)和异常。PHP 5 已经存在了很长一段时间(大约 12 年)，重要的新特性也在不断发布。

Note

值得注意的是，严格来说 PHP 并没有随着 PHP 5 的引入而转向按引用传递，这一点也没有改变。相反，默认情况下，当一个对象被赋值、传递给一个方法或从一个方法返回时，该对象的标识符被复制。因此，除非您确定问题并使用&字符强制按引用传递，否则您仍然在执行复制操作。然而，实际上，这种复制和通过引用传递之间通常没有什么区别，因为您使用复制的标识符引用了与原始标识符相同的目标对象。

例如，PHP 5.3 引入了名称空间。这些允许您为类和函数创建一个命名的作用域，这样当您包含库和扩展系统时，就不太可能遇到重复的名称。它们还会将您从丑陋但必要的命名惯例中解救出来，例如:

```php
class megaquiz_util_Conf
{

}

```

诸如此类的类名是防止包之间冲突的一种方法，但是它们会导致代码变得复杂。

我们还看到了对闭包、生成器、特征和后期静态绑定的支持。

### PHP 7:缩小差距

程序员要求很高。对于许多设计模式的爱好者来说，PHP 仍然缺少两个关键特性。这些是标量类型声明和强制返回类型。在 PHP 5 中，可以强制传递给函数或方法的参数的类型，只要您只需要一个对象、一个数组或者后来的可调用代码。标量值(如整数、字符串和浮点数)根本无法实施。此外，如果你想声明一个方法或者一个函数的返回类型，你就完全没有运气了。

正如您将看到的，面向对象设计经常使用方法声明作为一种契约。该方法需要特定的输入，反过来，它承诺返回特定类型的数据。在许多情况下，PHP 5 程序员被迫依靠注释、约定和手工类型检查来维护这种契约。开发人员和评论员经常抱怨这一点。这是本书第四版中的一段引文:

> 仍然没有承诺提供对提示返回类型的支持。这将允许您在方法或函数的声明中声明它返回的对象类型。这将由 PHP 引擎强制执行。暗示的返回类型将进一步改善 PHP 对模式原则的支持(如“代码到接口，而不是实现”)。我希望有一天修订这本书，以涵盖这一特点！

我很高兴地告诉大家，这一天终于到来了！PHP 7 引入了标量类型声明(以前称为类型提示)和返回类型声明。更重要的是，PHP 7.4 通过引入类型化属性将类型安全性推进了一步。当然，所有这些都包含在这个版本中。

PHP 7 还提供了其他一些好处，包括匿名类和一些名称空间增强。

### PHP 8:整合仍在继续

PHP 一直是一只伟大的喜鹊，从其他语言中借用闪亮的成熟特性。PHP 8 引入了许多新特性，包括属性，在其他语言中通常被称为*注释*。这些方便的标签可以用来提供关于系统中的类、方法、属性和常量的附加上下文信息。此外，PHP 8 继续扩展对类型声明的支持。在这方面特别有趣的是联合类型声明。这允许您声明属性或参数的类型应被约束为几种指定类型中的一种。您可以在利用 PHP 的类型灵活性的同时锁定您的类型。拥有你的蛋糕并吃掉它的定义！

## 倡导和不可知论:对象辩论

对象和面向对象的设计似乎激起了热情分水岭两边的激情。许多优秀的程序员多年来在不使用对象的情况下编写了优秀的代码，PHP 仍然是过程化 web 编程的优秀平台。

这本书自始至终自然地展示了面向对象的偏见，这种偏见反映了我受对象感染的观点。因为这本书*是*对对象的颂扬，也是对面向对象设计的介绍，所以不可避免地强调面向对象。然而，本书并没有暗示对象是用 PHP 成功编码的唯一途径。

开发人员是否选择使用 PHP 作为面向对象语言曾经是一个偏好问题。在某种程度上，这仍然是正确的，人们可以使用函数和全局代码创建完全可以接受的工作系统。一些伟大的工具(比如 WordPress)在它们的底层架构中仍然是过程化的(尽管现在这些工具可能会大量使用对象)。然而，如果不使用和理解 PHP 对对象的支持，作为一名 PHP 程序员将变得越来越困难，尤其是因为您在项目中可能依赖的第三方库本身也可能是面向对象的。

尽管如此，当您阅读时，还是有必要记住著名的 Perl 格言，“有多种方法可以做到这一点。”对于较小的脚本来说尤其如此，在这种情况下，快速启动并运行一个工作示例比构建一个可以很好地扩展到更大系统的结构更重要(这种临时项目通常被称为“尖峰”)。

代码是一种灵活的媒介。诀窍是知道你的快速概念验证何时成为一个更大的开发的基础，并在你的代码的重量为你做出持久的设计决定之前停止。既然你已经决定在你的成长项目中采用面向设计的方法，我希望这本书能为你开始构建面向对象的架构提供帮助。

## 摘要

这个简短的章节将对象放在 PHP 语言的上下文中。PHP 的未来与面向对象设计紧密相关。在接下来的几章中，我将简要介绍 PHP 当前对对象特性的支持，并介绍一些设计问题。