# 八、模块化 Laravel

在前一章中，我提到我们在开发索赔处理应用示例时遇到了某种障碍，我们从本书开始就一直在慢慢定义这个示例。我们正在构建的应用有许多不同的有界上下文、一个通用子域和一堆不同的模块，这些模块封装了我们在应用中需要的各种特性和组件。如果我们在新的 Laravel 安装中使用现成的标准目录结构，我们很快就会发现，一旦我们在实现未来的功能请求时开始在应用中构建更复杂的内容，事情就会变得混乱、分散，并且几乎无法维护。

我们计划让我们的应用有较长的生命周期，这意味着它需要能够承受变化。在任何软件项目中，变化都有不同的形式。特性被添加或删除，初始版本中应该包含的内容的优先级也在不断变化。更不用说范围蔓延，这本身就是一个很难处理的问题，尤其是在结构化的团队环境中工作时。如果我们将应用的所有逻辑放在一个单一的名称空间/目录结构中，我们将没有强大的团队动力，也不知道在给定的时间里谁在处理应用的哪些部分。多个部门将花费更多的时间来解决开发过程中出现的问题，而这些时间将更好地用于完成工作。此外，应用的部署必须一次完成，这为错误创造了空间，并且当完全不同的部分被修改时，还会导致应用的其他不相关部分无缘无故地中断。这是无法预测的，会导致面向用户的站点第一次出现错误，因为整个应用必须部署来修复一个 bug。

这些都是合理的可能性，在现实世界中，发生的速度有时比你所能掌控的要快。为了防止这种事情发生，我建议花足够的时间来考虑这些特性对我们整个系统的影响，并适当地计划出满足这些需求的组件结构。通过适当地分离我们的代码，以符合从域模型派生的标准，我们正在为成功做准备，因为我们可以在域模型中定义的相应目录和名称空间中独立地构建应用的不同方面。因为模块和类是用通用语言中的术语命名的，所以不存在哪个模块做什么的问题。

在本章中，我们将花一些时间来看看 Laravel 附带的名称空间结构，这样在修改它之前，您可以很好地理解这个结构。这也将让我们知道需要为我们自己的项目需求修改什么。索赔项目将被分解成相应的部分，这将允许我们将核心域模型分离成它的各种组件，并形成一个目录和名称空间方案，它将满足项目定义的需求。这种最初的尝试并不完美，但它将为你获得一些关于如何改变 Laravel 默认行为的知识打下坚实的基础。它还将为您提供一些关于按照有界上下文分割项目和识别任何通用子域的指导方针。

在后面的章节中，随着我们对领域本身以及 Laravel 的内部工作方式和默认机制的更多了解，我们将细化我们的结构并重构名称空间和结构。

## Laravel 的默认结构

我曾经问过 Laravel 框架的创建者 Taylor Otwell，他是否在编写框架时考虑到了领域驱动设计的概念和实践。他回答说，他在构建框架时没有将 DDD 纳入其中，而是依靠自己的经验和专业知识来构建最终成为世界上最流行的基于 PHP 的 web 框架。

在看到 Laravel 开箱即用的目录结构后，答案并不难理解(你可以在图 [8-1](#Fig1) 中看到股票根目录)。对于简单的应用来说，这种结构没有任何问题，但是对于域驱动的应用来说，这是行不通的。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig1a_HTML.png](img/488324_1_En_8_Chapter/488324_1_En_8_Fig1a_HTML.png) ![img/488324_1_En_8_Chapter/488324_1_En_8_Fig1b_HTML.png](img/488324_1_En_8_Chapter/488324_1_En_8_Fig1b_HTML.png)

图 8-1

Laravel 的默认目录结构

如果我们打开相应名称空间结构中的文件，我们会发现它符合几乎所有现代 PHP 框架都使用的 PSR-4 自动加载标准。让我们分解 Laravel 的默认名称空间以及它们包含的内容。

### 默认结构

让我们来看一下 Laravel 用来查找文件的默认名称空间(如表 [8-1](#Tab1) 所示)。一旦我们对 Laravel 的工作方式有了更好的理解，我们就可以开始充实扩展 Laravel 所需的修改。总而言之，我们将更好地理解 Laravel 的结构，以及我们可以保留和修改它的哪些方面。

表 8-1

Laravel 中的名称空间及其在应用中的对应层

   
| 

目录

 | 

命名空间

 | 

描述

 |
| --- | --- | --- |
| `/app/Http/Controllers` | `App\Controllers\` | 框架中的所有控制器 |
| `/app/Http/Requests` | `App\Http\Requests\` | 应用中的所有请求 |
| `/app/Http/Middleware` | `App\Http\Middleware\` | 所有中间件 |
| `/app/Http/Jobs` | `App\Http\Jobs\` | 所有工作 |
| `/app/Policies` | `App\Policies\` | 授权策略(基于模型) |
| `/app/Providers` | `App\Providers\` | 应用中的所有服务提供商 |
| `/app/Events` | `App\Events\` | 生成的事件 |
| `/database` |   | 基础设施问题(数据库) |
| `/database/seeders` |   | 包含在每个表的基础上在数据库中创建虚拟记录的类 |
| `/database/factories` |   | 通过从一组标准中生成新的实例，为单元测试系统模型提供工厂 |
| `/database/migrations` |   | 一个重要的目录，包含数据库的所有变更和创建规范 |
| `/resources/views` |   | 存放刀片视图文件 |
| `/routes` |   | 申请途径 |
| `/tests` | `Tests\Unit` | 单元测试 |

现在很清楚，我们需要的是一个新的应用结构，一个满足所有先前指导方针的结构，一个专注于有效表达领域的结构。目录的名称表明，目录中的大部分代码很可能与应用层相关，这是有意义的，因为它是一个整体应用的应用框架，该应用不应该由一个以上的部门或几个程序员在给定时间内分发、共享或开发。对于领域驱动的设计，我们想要的是一个尽可能接近实际领域的目录和名称空间结构，这是我们不可能以系统的应用为中心，用目录的方式来完成的。对于我们在前一章中构建的索赔应用的用例来说，名称空间太普通了。

我们希望能够查看该结构，并很好地了解应用实际上做了什么，因为目录结构对应于底层的业务模型，而且目录是以无处不在的语言中定义的术语命名的。这一部分很关键，值得重复:

*   使模块、类、子域、域以及所有其他与域相关的组件的名称空间反映出在通用语言中达成一致的术语。

通过遵循这个简单的实践，项目的目录和名称空间结构将根据业务域的构造方式被真实地建模，因此，查看项目的根文件夹的任何公司成员都将容易理解。应用由*域关注点*分解。应用中的模块代表业务本身运行的相同格式，它们使用公司无处不在的语言中的术语进行分离和命名。

幸运的是，Laravel 足够灵活，能够支持我们可以处理的几乎任何目录结构，不管我们在工作的特定领域中可能遇到的复杂程度如何。我们可以利用 Laravel 强大的扩展特性来重新连接名称空间，使之更加领域驱动，这是一个很好的观点。

正如您将在本章后面发现的，尽管 Laravel 的构建不一定没有考虑 DDD 的概念和程序，但这并不意味着它没有使用最佳实践和可靠的标准。具体来说，这里展示的最佳实践是开放/封闭原则。开放/封闭原则基本上意味着一个应用、程序或框架应该对修改封闭，但对扩展开放。这相当于我们应该能够改变 it 的行为或结构，而不必修改构成应用内部设施的核心文件，相反，我们应该有一个预先确定的方法来扩展应用的行为，通常是通过使用附加类或修改高级服务类，甚至修改配置文件或常量。Laravel 可以让你做到这一点。

#### 服务提供商

Laravel 与目录和名称空间结构相关的配置可以在框架源代码的深处找到...不太适合直接修改它，因为它位于`vendor/`文件夹中。Laravel 使用称为*服务提供商*的设施来配置系统的各个方面。服务提供者是配置您的应用的中心位置，是注册各种服务、创建服务定义中所需的各种类的实例或配置服务容器的好地方，服务容器为 Laravel 中用于应用层和基础设施层的核心服务提供动力，它们也是我们将用来配置应用的域层的地方。

Note

有关服务提供商以及如何在 Laravel 中使用服务提供商的更多信息，请查看第 [4 章](04.html)，或参考位于 [`https://laravel.com/docs/6.0/providers`](https://laravel.com/docs/6.0/providers) 的 Laravel 文档。

一般来说，服务提供者用于定义服务容器内的各种注册、绑定、单件和别名，这些服务容器可用于创建复杂的、结构良好的和精心制作的服务定义，这些服务定义可在整个系统中使用。在我们开始这些修改的编码部分之前，让我们定义我们希望我们的结构如何寻找索赔项目。

### 索赔申请的结构

回到我们在前一章关注的索赔示例，我们需要一种方法来组织我们的领域层的结构，同时仍然记住其他层。

Note

尽管我们决定将“索赔估计”的概念作为一个单独的有界上下文，但是由于大量的补充信息，我们将不会在本书的后面部分重点关注该领域的建模，因为一次阅读这些信息太枯燥了。我们将在后面的章节中探讨应用的索赔评估特性的先决条件(例如 CPT 代码组合、支付代码表以及各个 CPT 代码应该如何分组)。现在，让我们关注索赔的提交和验证问题。

我们需要为我们的应用设计一个更好的结构，一个指示业务关注点的结构，它的类和模块是有意命名的，用无处不在的语言定义术语。

#### 构造名称空间和目录的准则

在 DDD 中描述了一套指导原则，这将有助于确保我们在定义应用目录及其名称空间的主干结构时使用最佳实践，该指导原则在 Eric Evan 的蓝皮书中首次正式介绍和强调。

*   对模块、类、有界上下文和名称空间使用通用语言中的名称。

*   不要根据特定的模式或构建块来命名任何东西(例如实体、工厂等)。);坚持使用通用语言中的术语。我的观点是，如果它们被包含在一个与无处不在的语言中的一个概念相关的文件夹中，作为一种在技术层面上分离功能的手段，那么它们将是很好的，但是只限于从自然语言的领域中定义的边界的范围内。

*   以这样一种方式创建名称空间，使得其他名称空间中的各种类或组件之间的耦合非常少。做到这一点的一个好方法是坚持关注点分离原则，使用领域中的术语。

*   随着对项目需求或领域知识的深入了解，重构名称空间和目录名以包含新的见解，就像我们重构代码本身一样。

*   避免使用商业产品名称作为名称空间，因为它们变化太频繁。

最重要的是，作为给定业务模型(及其自然结构)基础的概念和隔离应该驱动架构和领域模型的设计。无论您在哪个领域工作，适用于业务本身的有机模型和过程都应该指导关于应用结构的方向和决策，以及实体的选择和它们之间的界限。当领域的各个方面被适当地划分到构成应用所提供的全部功能的各种有界限的上下文和模块中时，并且当这些功能按照它们所代表的真实世界的业务对象进行建模时，我们会看到许多好处，如下所示:

*   代码是领域模型的清晰表示，这很可能涉及到开发人员和领域专家的共同努力。

*   领域的每个部分位于代码中的什么位置，在什么上下文中细粒度的部分对应于什么粗粒度的上下文，这是显而易见的。

*   在哪里放置额外的模块或类的问题更容易回答，因为系统有定义良好的模块，这些模块很容易通过无处不在的语言中的术语来识别。

*   它使我们有可能将我们的应用过渡到一个更加隔离、定义更加清晰的微服务或六边形架构。

*   我们可以彼此独立地开发每个有界上下文(甚至在模块级别)，这意味着它们可以使用不同的语言，并且可以由单独的小组或部门来处理。

*   尽管在部署时您仍然需要部署整个代码库，但是应用作为独立的组件将更容易管理，并且您将更接近于将其转换为完全分布式的架构(如微服务)。

#### 索赔属于哪一类？

我们将不得不修改这个结构，使其不那么通用，而更具体地针对我们的索赔处理示例。由于我们还没有设计到可以开始绘制构建块组件的状态，我们将需要用代码实现概念验证，我们将使用我们所知道的来勾画出一个粗略的目录和名称空间结构，记住我们可以总是并且应该总是重构模型及其实现，以反映该领域中获得的任何知识。

我们对这款应用了解多少？我们知道有界的上下文，我们知道子域，我们对我们需要的模块有一个粗略的了解。我们需要清楚明确地区分有界上下文，将它们彼此以及与应用的其他部分适当地分开。这种分离应该基于领域的轮廓，或者存在于业务领域中的概念或部门的自然分割。我们还想记住，我们使用的是分层架构，并且层本身也提供了足够的分离手段。让我们从我们的有界上下文开始(注意，现实中有更多，但是到目前为止，在本书中我们将集中于我们在第 [6](06.html) 章中描述的三个)。见图 [8-2](#Fig2) 。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig2_HTML.jpg](img/488324_1_En_8_Chapter/488324_1_En_8_Fig2_HTML.jpg)

图 8-2

我们索赔处理器的有界环境

简单回顾一下，流程如下:

1.  索赔通过提供商(或诊所)的办公室进入系统，仅允许由`Practice`和`Provider`用户类型输入。

2.  填写初始表单后，在实际提交给审核小组进行审核之前，会出现自动流程，以确保索赔符合所有有效标准，能够提交给审核人员，此时索赔已“提交”这些流程包括以下内容:
    *   验证患者/提供者注册

    *   确保所有必需的文件都附在索赔中

    *   验证患者资格

    *   查找 paycode 表并验证 CPT 代码组合(我们将在本书后面讨论)

3.  虽然在此模型中还没有表达出来，但审查流程是提交索赔后接下来要做的事情，此时，在将索赔的所有数据发送到 FQHC 进行付款报销之前，都要经过审查者的手动验证。

### 通用子域

authorization/authentication 上下文是一个通用子域，因为它跨越了所有其余的上下文，并深入到模块本身的核心。这些有时被称为*横切关注点*(也就是说，一个应用的特定部分足够通用，可以作为一个给定软件问题的事实上的标准解决方案，跨所有其他有界的上下文来实现)。虽然它们不是项目的主要焦点，但是它们在系统中扮演着一些重要的角色，这是系统正常运行所必需的。像这样的问题应该被隔离并封装到它们自己的名称空间目录中。

Note

一般情况下，通用子域使用第三方现成的解决方案来实现，在这些解决方案中，构建或维护它的成员被认为是通用子域所属领域的专家。这方面的一个很好的例子是 Laravel 决定将框架过去通过 Artisan `make:auth`命令提供的授权框架的 UI 部分 86 化，以支持使用专门做这件事的第三方供应商:管理用户的授权和认证、创建和管理组、创建和执行权限检查、创建用户角色，以及完成现代授权管理系统支持的任何其他功能。厂商是 Auth0 ( [`https://auth0.com/`](https://auth0.com/) )。

以下是一些跨领域问题的例子:

*   *日志*:错误可能发生在我们系统的任何一层。通常，某种形式的记录器有一个单独的实现，在整个应用的许多地方都可以使用，包括用于调试和信息目的的所有三个架构层。

*   *安全性*:认证(“登录”)本身是一个通用子域。封装在该关注点中的功能负责管理用户、权限和角色，因为它们被用作在系统中实施安全策略的标准方式。

*   *通知*:我们的应用必须为应用中的每个交付机制(API 端点、网页等)启用通知。)这样我们就可以在用户提出请求后，向用户传达(或不传达)应用的状态和状况/良好状态。

从现在开始，我们将把安全问题建模为一个独立的“通用子域”，如图 [8-3](#Fig3) 所示。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig3_HTML.jpg](img/488324_1_En_8_Chapter/488324_1_En_8_Fig3_HTML.jpg)

图 8-3

新形成的有界上下文(左)和它们对 Auth 的使用，Auth 是一个通用子域，也包含域为每个用户类型实现的用户类

#### 不要失去视线

既然我们已经尝试了在上下文层次上分离关注点，我们就有了一个粗略的草案，从各方面来看，这是系统可能的最高层次的视图，至少对于这次讨论来说是这样。然而，请记住，您创建领域驱动设计的最终目标，简而言之，等同于构建一个模型，在这个模型中，边界将各种组件分开，以便它们反映真实世界中对应组件的结构和上下文。总是试图让领域和领域的模型保持步调一致。我们希望设计一个应用，它能揭示意图，有意义，并与他们存在的要实施的策略和业务规则相关。我们希望能够在模型中捕获领域的所有古怪之处，最终，通过进行频繁的提交，一次狭隘地关注单个任务，遵循编码指南和最佳实践，并采用从持续迭代范例中借用的概念，努力改进模型以尽可能地符合真实世界的领域。

对于任何关于架构设计的粗略草案或松散规范，我们需要记住的是向后工作，看看给定的设计是否仍然满足该领域的条件和要求，并以简单、结构化和明确的方式恰当地表示它。让我们快速浏览一下这个领域，看看我们创建的有界上下文是否与我们到目前为止建立的模型一致。通过重新检查我们的工作并确保设计符合领域的需求，我们为成功做好了准备，特别是当我们的项目有一个完整的 CI/CD 管道设置为在每次提交时自动运行时。此外，自动运行的测试套件(通常与 CI/CD 管道放在一起)甚至可以进一步稳定软件项目。

## DDizing Laravel

在本章的持续时间里，我们将讨论一个潜在的解决方案来实现一个利用 Laravel 框架的能力的架构，同时保持 DDD 所建议的概念和对领域模型的关注。

### 通过分层架构

为了创建这个 DDD 友好的 Laravel 应用，我们必须包含一个新的名称空间和目录结构，因为默认的名称空间和目录结构不能满足我们的需要(过于单一)。对于我们的第一次尝试，我们将采用分层架构模式，并尝试将 monolith 划分为与我们现在应该习惯看到的三个架构层相对应的各种组件:域、应用和基础设施层。

定制 Laravel 以满足我们的需求(与 DDD 概念和实践相关)的第一步是运行当前的股票目录/名称空间，并将每个目录/名称空间分类到相应的层中。我们已经开始了这个过程(见表 [8-1](#Tab1) )。这是这样做的结果，但首先，快速回顾一下每一层包含的内容:

*   **应用层**
    *   负责编排、组织和封装域行为并控制数据访问

*   **基础设施层**
    *   通过实现领域层中定义的抽象接口(通过依赖倒置),处理持久性机制和日志记录等问题

*   **域层**
    *   任何 DDD 项目的核心和灵魂(也应该是每个 web 开发项目的核心和灵魂)，包含了使业务实际运行的核心和基础

表 [8-2](#Tab2) 列出了 Laravel 默认架构中的各层。

表 8-2

根据每个目录所属的层定义股票结构

   
| 

目录

 | 

建筑学的

层

 | 

描述

 |
| --- | --- | --- |
| `/app/Http/Controllers` | 应用 | 控制器接受进入系统的请求，并通过一个单一的、明确定义的结构(称为 API)响应不同的交付机制。控制器可以被认为是外部请求和内部域过程之间的仲裁者。 |
| `/app/Http/Requests` | 应用 | 封装请求，并将它们与交付机制和域/基础设施问题分开。 |
| `/app/Http/Middleware` | 应用 | 中间件在请求/响应周期中的特定时间运行，通常执行应用层中的操作。 |
| `/app/Jobs` | 领域 | 作业可以被认为是“命令”，或者是封装在单个`Job`类中的狭义任务。 |
| `/app/Policies` | 应用 | 系统的策略在请求级别控制对每个模型的访问；认证问题是应用层的问题。 |
| `/app/Providers` | 应用 | 我们将使用服务提供者来配置我们的自定义目录结构，并为第三方软件包提供一种配置方式。 |
| `/app/Events` | 领域 | 当领域层中发生了特定的事情时，事件将被触发，并将作为该动作的记录，该动作可能会触发其他动作。 |
| `/database` | 基础设施 | 数据库目录包含所有数据库问题和模式配置，它们在基础结构层中运行。 |
| `/database/seeders` | 基础设施 | 种子是数据库的测试记录。 |
| `/database/factories` | 基础设施 | 数据库测试工厂。 |
| `/database/migrations` | 基础设施 | 迁移包含一个详细的、每次更改的数据库模式更改记录。 |
| `/resources/views` | 应用 | 这也可以放入一个单独的层，称为“视图层”或“表示层”，通常只包含 UI 问题 |
| `/routes` | 应用 | 路由定义了可以进入的内容和 URI 的配置，最终导致控制台命令运行或网页显示 |
| `/tests` | * | 在一个构造良好的系统中，通常会找到覆盖应用中每一层的测试 |

在表 [8-2](#Tab2) 中需要注意的是，大多数目录都封装了应用问题(即属于应用层)。当您考虑到 Laravel 是一个“应用框架”这一事实时，这是有意义的换句话说，在典型的 web 开发项目中，它在整个系统中处理尽可能多的*应用级*关注点，因此，默认结构中的应用关注点构成了目录和名称空间的大部分是正确的。

事实上，从 Laravel 的文档中可以看出，它打算为您提供最实用的解决方案，以解决最常见的*应用*级别的问题，这样您就可以专注于对任何 DDD 应用来说最重要的事情:领域。它允许应用的“连接点”具有灵活性。我指的是将各种组件连接在一起的代码，比如服务提供者和依赖注入。

也就是说，我认为这里最好的方法是让 Laravel 做它擅长做的事情，即管理各种各样的应用问题。我们将重新构造名称空间的布局，在应用中分割出各种有界的上下文。我们将保留根应用文件夹，这是 Laravel 的默认项目文件夹，但只保留适用于整个应用并且不适合我们声明的有界上下文的文件和目录。这些包括服务提供者、策略、控制台内核和负责分配中间件组和中间件路由的`App\Http\Kernel`。

我们将按照以下步骤对其他所有内容进行分析:

1.  分析项目根目录中的组件、类或模块，并确定其所在的层。

2.  确定每个组件属于哪个有界的上下文(或者它们是否出现在所有上下文中)，或者它们是否应该留在通用的`app/`文件夹中，因为它们属于整个系统而不是单个上下文。

3.  将项目从它们在根项目目录中的默认位置移动到它们在一个或多个有界上下文中各自的位置(在某些情况下，我们将不得不复制应该包含在每个模块中的结构的一部分，作为属于它们相应上下文的独立构造*)。*

4.  一旦我们确定了一个稳定的结构，我们将对配置和服务提供者进行必要的修改，让 Laravel 知道在哪里可以找到与系统中各种端点相对应的代码。

5.  修改`composer.json`文件，以包含在上一步中创建的新名称空间结构*的自动加载，并创建必要的提供者，以将我们的项目代码与 Laravel 的内部机制挂钩。*

6.  不断重新审视核心需求，以确保我们的设计满足系统的需求和要求。

开始吧。

## 步骤 1:分析项目根目录结构

如果我们采用一个标准的 Laravel 安装，并仔细检查它的默认目录结构，我们很可能总是会发现结构的某些部分，要么是某个特定项目不需要的，要么是对于我们所需要的结构来说过于死板。Laravel 中的标准结构并不是模块化的，而是将其大部分“项目代码”塞在`/app`目录中。对于我们这些想要使用 DDD 实践来构建应用的人来说，这并不理想。

一个好的第一步是分析 Laravel 中默认的目录结构，并将其与您项目的需求进行比较。这可以让您了解如何修改名称空间结构以符合您的需求。例如，如果您正在构建一个五页的信息网站，只有一个联系表单，可能还有一些内嵌的图形，您很可能不需要 Laravel 提供的大量组件，也不需要(或想要)为这样一个琐碎的项目实现 DDD。另一方面，您可能会发现项目的范围相当复杂，最好用更正式的名称空间结构来表示，因此您可能倾向于将`app/`目录分成更易于管理的层(即应用、域、基础设施和接口层)。

## 步骤 2:确定每个有界上下文需要哪些组件

看起来我们实际上正在处理两个有界上下文以及一个通用子域，我们将遍历默认结构，并确定在每个有界上下文中需要哪些(声明提交、声明验证)以及哪些属于通用子域(授权/认证)。在表 [8-3](#Tab3) 中需要注意的是，我们在第二列中确定的有界上下文不一定反映给定的结构或名称空间。例如，索赔提交上下文(因此用户可以通过浏览器与应用交互)和 Auth 子域(因此用户可以登录、注销和注册)将需要 Views 组件。

表 8-3

在我们的索赔示例中，每个有界上下文中需要的组件

   
| 

拉勒韦尔分量

 | 

索赔上下文

 | 

说明

 |
| --- | --- | --- |
| → Http→控制器→请求→中间件 | 提交索赔索赔验证认证 | 所有的 web 应用都有相同的基本流程:接收请求，返回响应。这些组件驱动这一基本需求，因此我们需要它们用于所有的上下文。 |
| →工作 | 提交索赔索赔验证 | 作业将封装特定领域的知识，并提供执行特定的一次性操作的方法。 |
| →政策 | 认证 | 尽管策略围绕给定的模型，但一般来说，对身份验证的关注是对应用的关注，这是有意义的，因为应用层是域层的直接客户端。 |
| →供应商 | 通用(应用/)提交索赔索赔验证认证 | 应用的所有层都需要服务提供商，包括驻留在`/app`中的通用服务提供商。每个 BC 也有自己的，并且有一个内置的授权关注点:`AuthServiceProvider`。 |
| →事件 | 通用(应用/)提交索赔索赔验证认证 | 事件将发生在应用的所有层:领域事件、授权事件和系统范围的事件。 |
| → Artisan 命令 | 提交索赔索赔验证 | 对于各种一次性任务和定期维护，控制台命令非常方便。我们希望我们的两个 BC 都有一个`Console\Command`名称空间。 |
| →例外 | 通用(`app/`)提交索赔索赔验证认证 | 异常可能在应用的任何层随时发生，包括一般的系统问题和身份验证错误。 |
| →视图 | 提交索赔认证 | 我们最初需要输入数据的视图来创建索赔以及登录/注销 UI。验证组件不应该需要它，因为它的功能发生在后端。 |
| →路线 | 提交索赔索赔验证认证 | 为了允许从外部资源访问我们的应用，我们需要路由。我们还需要能够将事情路由到后端，所有的业务连续性，我们正在从应用中删除默认的通用路由文件。 |
| →测试 | 提交索赔 o 单位 o 功能索赔验证 o 单位通用/授权 | 所有 BC 都有某种形式的测试，或者是单元测试，或者是单元测试和功能测试。我们可能有也可能没有授权、认证或其他通用组件的测试。当我们这样做的时候，我们可以为他们腾出空间。 |

这并不表示在每个相应的上下文中都应该有一个`views/`文件夹。我们将在本章的后面详细介绍我们的应用的结构。

表 [8-3](#Tab3) 是一个目录，可以这么说，默认结构与我们试图实现的内容之间的关系，将很好地作为每个上下文需要哪些组件的通用指南，稍后将用于确定支持它的名称空间和目录结构。在*的大蓝皮书* (Eric Evans)中，他指出，通常，框架会强迫你进入一种特定的风格，或者把你限制在它们自己采用的结构中，这使得按照我们想要的方式实现事情变得更加困难...DDD 建议的方式。

然而，我的目的是在一个两者相辅相成而不是互相争斗的框架内展示 DDD 的一种可能的实现。Laravel 将主要用于其设施和主干特性，为应用层中的应用级问题提供答案。这将使我们能够集中精力实现 DDD 定义的模式和实践，而不必过多地担心应用问题或“夹缝”中的地方，这些地方经常是导致开发和维护失败和浪费时间的原因。

Tip

DRY 原则在编程界是一件大事。如果你还不知道 DRY 原则是什么，它是一个简单的缩写，意思是“不要重复自己”这是一条很好的建议，也是我们在开发软件时应该一直尝试采纳的建议。

## 步骤 3:重组项目目录

这本书的这一部分很难写，仅仅是因为有太多不同的方法去设计一个领域驱动的结构，没有一个答案是 100%确定的方法来创建系统的架构。所以，我认为最好用索赔的例子来记录我自己的经历。首先，我想简单介绍一下 claims 应用的背景，它启发了本文中使用的示例。

A Brief History of the Claim Application

我工作的应用由我们的团队继承，最初是作为一种管理与联邦监管的 Medi-Cal 计划相关的索赔提交流程的方法而开发的，从本质上增加了自有医疗机构可以支持的患者就诊次数，并允许医疗提供者更加专注于他们最擅长的事情:诊断和治疗患者。离岸团队利用了 Laravel 框架，但是离岸团队最初建立的整体架构结构设计得很差(如果它实际上是*设计的*在任何种类的战略规划的意义上)，并且实现是臃肿的。关注点分散在整个应用中，对代码或语法标准的采用没有任何一致性，等等。然而，尽管很糟糕，它还是起作用了。

在作为一个创收的企业对医疗提供商的 web 应用在市场上进行初步构建和概念验证后，所有者决定雇用一个内部开发团队来接管该项目，目标是实现长期可持续性，并能够快速高效地推出新的业务功能。因为该公司是一家初创公司，他们面临着大多数初创公司在开发软件时的典型需求:在整个应用开发过程中，需要随时添加或删除功能。虽然这一愿景最终成为了现实，但最初当第一个内部团队进入代码库时，他们的大部分时间都在灭火(例如，修复 bug)。

由于离岸团队缺乏经验以及其他问题，使得与十人开发团队进行远程工作成为一个更大的挑战(如语言交流障碍)，一些概念被误解，其他概念被歪曲或毁容。这经常会留下一堆代码，使存储库变得臃肿；“工作”代码几乎正常工作。修复 bug 通常意味着应用停止运行，我们会赔钱。放下一切，修复应用。当这种情况发生时，团队中的每个开发人员都跳上他们的计算机，在浏览了一连串的堆栈跟踪、异常转储和日志文件之后，开始相互交换想法，看问题可能是什么以及如何在尽可能少的时间内最好地修复它。

我想说的是，我工作了一年多的应用，作为这个例子的基础，绝不是以领域驱动的方式构建的，甚至也不像任何优秀的开发人员所认为的“最佳实践”在解决领域问题的代码的不同部分周围，边界通常是模糊的，因此我们的任务后来变成了将领域的各个部分重构为单独的新结构，这些新结构或多或少地被设置为好像它们是微服务(即，独立的、领域驱动的模块，在领域的每个部分周围有适当放置的屏障)，然后我们使用反腐败层模式在同一个整体应用中实现这些微服务，作为将新的自包含上下文集成到原始代码库的一种方式。原始客户端仍然用于相同的调用，只是这些调用都必须更改为指向在我们的反腐败层中建立的新上下文。

我将要向你们展示的将反映我自己的经历，将突出我所面临的考验和错误，并将展示我所决定的最终结构。这将最好地反映以特定领域的形式设计和建模软件的真实世界的经验，并显示在提出一个可行的解决方案方面期望什么，该解决方案将做的不仅仅是“工作”它最终将为在其上构建任何其他未来组件提供基础，并且它可以被分解为独立的微服务，这相当容易，因为它们是根据核心域的自然边界构建的，这些边界将一个域概念组与另一个域概念组隔离开来。那个项目的目标是最终达到一个分布式系统，这是一件困难的事情；然而，您在近期(例如发现缺失的空白或领域中未知的角落)和长期(例如独立部署各种组件并让不同的团队、部门或完全用不同的编程语言开发它们的能力)都获得了回报。

### 框架应用关注点

既然我们已经有了对每一层中的组件进行分类的明确方法，我们需要想出一个同样好的方法来根据它们各自的有界上下文来组织它们，我们将通过目录结构和名称空间选择来完成。

Tip

请记住，这不是最终的结构，而只是一个粗略的草案。稍后，我们将移动东西并重构这个结构，以便更好地组织。当我们在项目中引入六边形方法时，就会出现这种情况。

让我们看看项目结构在修改之后，但在安装我们自己的有界上下文和域层之前是什么样子，如图 [8-4](#Fig4) 所示。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig4a_HTML.png](img/488324_1_En_8_Chapter/488324_1_En_8_Fig4a_HTML.png) ![img/488324_1_En_8_Chapter/488324_1_En_8_Fig4b_HTML.png](img/488324_1_En_8_Chapter/488324_1_En_8_Fig4b_HTML.png)

图 8-4

索赔项目的新目录和名称空间结构

Note

关于剧透，请参见本书网站或 Apress.com 的该项目的知识库。

在图 [8-4](#Fig4) 中，我们基本上展示了相对于几页前我们在表 [8-2](#Tab2) 中定义的应用的修改结构。这里介绍的重新安排在架构上为我们做了一些事情。

*   我们有一个更加清晰的关注点分离，因为我们使用 Laravel 自带的设置，将所有应用于系统的应用范围的组件作为一个整体(而不是我们的有界上下文)保存在项目的根目录中...大多数情况下。

*   Laravel 解决应用问题的默认组件仍然在默认的`/app`文件夹中，并且对应于`App\`名称空间，这使得我们可以更容易地识别给定类的作用和位置。

*   所有的领域问题都被整齐地封装在`/src`文件夹中，我们需要在我们的`composer.json`文件中设置这个文件夹，这样它就能识别我们的领域层的新名称空间:`Claim`。

*   我们已经将 Laravel 附带的几个目录移到了我们的域层的边界内(比如`Jobs`、`Events`等)。).

然而，这种结构也有缺点，因为在软件开发中，几乎所有其他看起来完美的东西都有缺点。我想到的主要缺点是架构似乎有点分散。然而，这样做的原因可能是因为实现这一点的开发人员不习惯于 Laravel 风格的目录结构，并且一开始试图记住所有这些文件夹以及它们的作用可能会有点困难。我觉得多一点经验和对框架的使用将有助于减轻这一点。

我们设计的结构反映了 Laravel 的结构。除了添加了`src/`文件夹之外，它几乎包含了自框架安装以来就存在的所有其他组件。我们只是对项目根目录下的文件夹做了一些更改，这些文件夹通常存在于传统的 Laravel 应用中，并以 DDD 的名义重新使用。这个决定将帮助我们保持应用的秩序，并允许我们直接关注核心领域模型和领域层中存在的应用的各个方面，并在我们着手开发各种将拼图拼在一起的部件时为我们带来回报。因此，即使整体结构看起来有点忙，也有一个疯狂的方法，这将随着我们继续关注我们的领域而展开。

### 附加目录

我们需要更多的目录来实现系统的各个方面。我认为最好是在维护我们赖以构建架构的核心领域驱动焦点，同时仍然允许框架承担应用关注的重担之间找到一些中间地带，这是它做得最好的。我们将使用 Laravel 的标准目录和名称空间名称，尽管我们可能会将它们重新定位或复制到其他有界的上下文中。在不使初始结构过于僵硬的情况下，我们需要为这些组件腾出空间，如下面的列表所示:

*   控制台(命令):应用范围的 Artisan 命令。

*   异常:应用范围的异常。

*   Http。
    *   控制器。
        *   Auth。

    *   中间件:标准的 Laravel 中间件。

    *   请求:在应用范围的上下文中不需要。

    *   移动到域层。

*   事件:应用中的全局事件。

*   监听器:全局事件的全局监听器。

*   模型:目前唯一适用于应用的模型是`User`模型，我们可以稍后决定迁移它。

*   观察者:适用于整个系统的观察者。

*   策略:策略与域对象相关，并根据给定的模型命名。移动到域层。

*   提供者:在高层次上配置系统的 Laravel 标准提供者。

请注意，我们正在为应用于全局上下文(或系统/应用范围的上下文)的应用的移动部分蚀刻出一个全局上下文。我们将使用这个结构作为有界上下文的模板，但是请记住，我们不希望只是为了维护约定或遵守框架名称限制而添加文件夹。就软件开发而言，简单总是比复杂好，小总是比大好，这表明细粒度组件通常比粗粒度组件好。然而，真正重要的是对象和类的粒度级别是否反映了底层领域的粒度级别。如果我们构建一个简单的单页面应用，其中包含一个在提交时发送到后端的表单和另一个用于确认消息的页面，我们可能不需要几个小组件(包括代表提交的表单数据的`Form`模型，可能通过 IP 地址进行跟踪)。另一方面，如果我们从头开始构建一个电子商务平台，我们将需要一个非常复杂的模型阵列来容纳事情发生时发生的所有逻辑(用户查看产品并为该产品选择所需的属性和变化；用户将产品添加到购物车，然后进行结账；等等。).无论您决定创建的模型和组件有多粗糙或多精细，如果您将它们建模为现实生活中的业务规则和底层策略(从业务领域发展而来，并以无处不在的语言命名),就不会出错。

### 领域问题

让我们深入到`src/`文件夹，把我们最初的域结构放在一起。请记住，此时的最终目标是设计一个布局，让我们以领域为中心的组件能够独立生存和开发。我们将尽我们所能，利用我们目前能够获得的关于核心领域(声明)的知识。我们打算利用各种实践并保持高质量，同时依靠基本原则来做出决策。

### 目录结构:索赔提交上下文

对于领域模型中的每一层，每个有界上下文都有一个文件夹:`Application`、`Infrastructure`和`Domain`。因为我们在很大程度上保留了`/app`文件夹，因为它是在一个普通的 Laravel 安装中，所以我们现在基本上可以认为这个文件夹是框架所关注的。`/app`现在包含了 Laravel 特有的物品，这将使我们在以后需要时更容易添加更多的物品。这使得`src/`文件夹成为与域相关的系统的实际“模型层”。然而，在领域的保护伞下，作为一个整体，需要一个清晰的边界来围绕它的子层次架构问题，这就是为什么我选择为每一层包含一个目录(图 [8-5](#Fig5) )。这也将支持长期增长，因为任何特定的代码片段都应该立即存在于何处，这一点很清楚。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig5_HTML.png](img/488324_1_En_8_Chapter/488324_1_En_8_Fig5_HTML.png)

图 8-5

提交受限的上下文结构

关于我们构建系统布局的方式，需要注意的另一点是，我们利用了无处不在的语言中的术语，并且只为模式或“类型”(即工厂、控制器等)创建分离。)位于直接属于域(并从 UL 中提取)的父名称空间之下，并且实际上属于域模型中的给定上下文。

因此，我们在图 [8-5](#Fig5) 中所做的是将每一个标准关注点(用 Laravel 的术语来说)分解到有界上下文中的相应层。请记住，我们希望每个 BC 都独立于其他 BC(松散耦合),以便有一天我们可以将它们拆分成独立的微服务，这样它们甚至可以放置在不同的服务器上，或者由不同的部门或团队开发。这相当于有界上下文需要包含所有的标准组件，使其能够独立运行。当它们达到这一点时，它们被认为是松散耦合的、可重用的组件，甚至可以单独部署或用不同的语言编写。

以下是关于图 [8-5](#Fig5) 中结构的一些附加说明:

*   之前，我们将策略确定为一个应用问题；我们在提交上下文中包含索赔策略，因为我们希望我们的上下文尽可能独立，并且与应用的其余部分分离。我们希望将它们放在各自的上下文中，这与该策略适用的模型相同。例如，ClaimPolicy 将存在于提交上下文中，因为`Claim`域模型也存在于其中。

*   我考虑过创建一个`Database`文件夹，它位于有界上下文的基础设施层中，只存放该上下文的数据库问题(迁移、种子、测试工厂)，但是，现在，我决定保留标准的根`/database`文件夹的位置不变，并在其中存放所有数据库问题。我对此的理由是，迁移等是系统范围的过程，可能会跨越许多上下文，这将很难单独管理每个上下文自己的`database/`文件夹，试图分割域逻辑是徒劳的。这是应用的一个区域，不应该*在有限的上下文中*分割，而应该留在全局的、应用范围的上下文中。

*   索赔提交上下文中的*基础设施*包含了我们将在本书后面访问的许多模式。这个想法是，我们在我们的`Domain\Contracts`名称空间中定义接口(用于与持久性相关的存储库、工厂或类),然后在`Infrastructure\`名称空间中实现它们，这允许我们维护一个域驱动的方法，并保留“D”的实体(依赖倒置)。基础设施支持模型，处理持久的问题，并为域层的居民提供跨请求操作的方法(由于 HTTP 除了会话之外没有默认的状态感)。

*   在有界上下文的每一层中都有一个`Service`目录，以允许它们是自包含的，并且彼此适当地分开。有关不同层中不同服务的复习，请参阅第 [1 章](01.html)。以下是您可能会在每种情况下发现的一些示例:
    *   `Application\Service`
        *   `laimLoggingService`

        *   `ProviderNotificationService`

        *   `EmailNewsletterService`

    *   `Domain\Service`
        *   `ClaimSubmissionService`

        *   `ProviderRegistrationService`

        *   `PaycodeSheetVerificationService`

    *   `Infrastructure\Service`
        *   `FilterSpecificationService`

*   尽管我们根据目录包含的模式来命名目录，但是我们是在有限的上下文范围内这样做的。我们仍然保持着实现和底层业务领域之间的连续性，并且在将来会继续这样做，用无处不在的语言中表达的术语来命名事物。

#### 目录结构:声明验证上下文

索赔验证上下文将具有与索赔提交上下文相同的核心结构。一个明显的区别是，验证上下文根本不需要自己的一组刀片视图或表示层，因为它将用于自动验证，并且在索赔数据出现问题或违反索赔提交的前置和后置条件时，将简单地向提交上下文返回某种类型的特定`Exception`类，然后提交上下文将处理异常并通过其表示层通知用户。

## 步骤 4:更新配置

为了使我们之前设计的结构实际工作，我们需要让 Laravel 知道在我们的有界上下文中哪里可以找到各种组件，因为我们编写的大部分代码最终将存在于这两种上下文之一:声明提交或声明验证。

### app/Providers/routeserviceprovider . PHP

因为我们采用了新的目录来存储有界上下文的各种路由，所以我们需要告诉 Laravel 在哪里加载这些路由，以及我们希望如何为我们的域层构造路由。我们在`app/Providers/RouteServiceProvider.php`文件中做任何特殊的路由配置(清单 [8-1](#PC2) )。

```php
<?php
namespace App\Providers;
class RouteServiceProvider extends ServiceProvider
{
    /**
     * This namespace is applied to your controller routes.
     *
     * In addition, it is set as the URL generator's root namespace.
     *
     * @var string
     */
    protected $namespace = 'App\Http\Controllers';
    protected $submission_namespace = 'Claim\Submission\Application\Http\Controllers';
    protected $submission_dir = 'src/Claim/Submission/Application/Routes/’;

    /**
     * Define your route model bindings, pattern filters, etc.
     *
     * @return void
     */
    public function boot()
    {
        parent::boot();
    }

    /**
     * Define the routes for the application.
     *
     * @return void
     */
    public function map()
    {
       $this->mapApiRoutes();
       $this->mapWebRoutes();
    }
    /**
    * Define the "web" routes for the application.
    *
    * These routes all receive session state, CSRF protection, etc.
    *
    * @return void
    */
    protected function mapWebRoutes()
    {
        Route::middleware('web')
           ->namespace($this->namespace)
           ->group(base_path('routes/web.php'));

        Route::middleware('web')
           ->namespace($this->submission_namespace)
           ->prefix('submission')
           ->group(base_path($this->submission_dir . 'web.php'));
    }

    /**
     * Define the "api" routes for the application.
     *
     * These routes are typically stateless
     *
     * @return void
     */
    protected function mapApiRoutes()
   {
      Route::prefix('api')
             ->middleware('api')
             ->namespace($this->namespace)
             ->group(base_path('routes/api.php'));
      Route::prefix('submission/api')
             ->middleware('api')
             ->namespace($this->submission_namespace . '/Api')
             ->group(base_path($this->submission_dir . ‘api.php’));
    }
}

Listing 8-1Modified RouteServiceProvider, with Updates Shown in Bold:/ddl/app/Providers/RouteServiceProvider.php

```

Note

如果你一直跟随，你将需要通过 Laravel 命令`artisan route:clear`清除你的路线缓存，并且总是可以通过`artisan route:list.`验证你的路线是否被 Laravel 选取。如果运行 clear cache 命令给你一个你不认识的错误，请在本章末尾再次尝试运行它。

本质上，除了加载 Laravel(在`/routes`内)附带的标准路由之外，我们在这里所做的是添加对我们的域相关上下文的支持，并说明在哪里可以找到应用的定制路由。`mapWebRoutes()`方法通过`Route` facade 提供的`namespace()`函数给出一个定制的路由名称空间。路由名称空间定义了特定名称空间的位置，该名称空间将是属于该名称空间(和有界上下文)的控制器将位于其下的容器。在我们的例子中，我们正在配置提交上下文的路由，所以我们希望将这个名称空间设置指向我们为这个有界上下文定义的主`Controller`名称空间:`Claim\Submission\Application\Http\Controllers`。我们指定它位于目录`src/Claim/Submission/Application/Routes/`中。现在，当我们在一个路由文件中定义我们的路由时，就像前面提到的文件名为`web.php`的目录中的路由一样，我们可以指定这个语法来引用控制器，这样就可以很容易地配置我们的应用的路由结构:`SubmissionController@index`。

它指向类`Claim\Submission\Application\Http\Controllers\SubmissionController`并调用包含在`index()`方法中的逻辑，该方法被设置为位于文件`src/Claim/Submission/Application/Http/Controllers/SubmissionController.php`T3 中。

路由前缀只是应用主 URL 之后的 URI 的一部分。我们所做的是配置路由文件中定义的路由(web 路由的`web.php`和 API 路由的`api.php`),分别以进程`/submission`和`/submission/api`开始。然后，我们将路由前缀和我们通过路由外观使用其`group()`方法给它们的名称空间组合在一起，传递一组应该应用链式配置的有效路由作为其参数，这是我们在相应的路由文件`web.php`和`api.php`中定义的，如下所示:

```php
<?php
// configured to run SubmissionController::index() when the route
// "/submission" is hit with a GET HTTP request
Route::get('/', 'SubmissionController@index');

// configured to run SubmissionController::submit() when the route
// "/submission/submit" is hit with a POST HTTP request
Route::post(‘/submit’, ‘SubmissionController@submit’);

```

#### app/Providers/eventserviceprovider . PHP

Laravel 的事件系统使用 Symfony 的事件组件，并提供了一个额外的配置层，用于配置事件和侦听器的位置，以及关于应用中事件和侦听器的其他功能。我们想告诉 Laravel 这些事件的侦听器在哪里，我们可以通过将这个方法添加到`EventServiceProvider`类来做到这一点，这将覆盖它在父类中定义的默认方法(清单 [8-2](#PC4) )。

```php
/**
     * Get listener dirs that should be used to discover Events.
     *
     * @return array
     */
    protected function discoverEventsWithin()
    {
        return [
            $this->app->path('Listeners'),
            $this->app->path(base_path(
                 'src/Claim/Submission/Application/Listeners')),
            ];
    }

Listing 8-2Updates to the EventServiceProvider to Specify the Location of the Listeners

```

## 步骤 5:创建新的 ClaimSubmissionProvider

随着我们在整本书中继续这个例子，我们将需要一个地方来放置我们的更通用级别的配置和定制，这些配置和定制是特定于特定的有界上下文的。我已经决定在每个 BC 的`Application`目录中放置一个`Providers`名称空间，以便每个目录可以包含多个提供者，按照领域模型的既定业务需求进行分隔，并以无处不在的语言命名。

Note

因为我们使用了在`composer.json`中指定的完全分离的名称空间，Artisan 命令行工具的`make:*`命令集将无法正常工作，无法在域上下文的边界内创建组件。为了解决这个问题，您可以发出`make:*`命令而不指定生成文件的 FQDN，然后将它移动到您需要的位置并修改名称空间，或者简单地创建一个新文件并复制预先存在的提供者的内容并在需要的地方进行修改。为了简单起见，我选择了创建-粘贴-编辑方法，而不是后者。

在名称空间`Claim\Submission\Application\Providers\ClaimSubmissionProvider`中创建一个新的`.php`文件，并将清单 [8-3](#PC5) 中所示的代码放入其中。

```php
// ddl/src/Claim/Submission/Application/Providers/
     ClaimSubmissionProvider.php

<?php

namespace Claim\Submission\Application\Providers;

use Illuminate\Support\ServiceProvider;

class ClaimSubmissionProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        $this->loadMigrationsFrom(__DIR__ .
            '/../../Infrastructure/Database/migrations');
     //$this->loadTranslationsFrom(__DIR__.'/../resources/lang',
            'domain-driven-laravel');
     // $this->loadViewsFrom(__DIR__.'/../resources/views',
             'domain-driven-laravel');
     //$this->loadMigrationsFrom(
            __DIR__.'/../database/migrations');
     // $this->loadRoutesFrom(__DIR__.'/routes.php');
    }

    public function register()
    {
         $this->mergeConfigFrom(__DIR__.
            '/../config/claim_submission.php',
            'domain-driven-laravel');
    }
}

Listing 8-3The New ClaimSubmissionProvider Service Provider

Class

```

到目前为止，我们的服务提供商在其引导方法中只包含一个设置，这就是上下文迁移所在的位置。在这种情况下，我们将迁移保存在`Infrastructure`文件夹中，在`Database`名称空间内，并使用标准的 Laravel 命名约定，用于框架提供解决方案的标准数据库问题(其中之一是通过将数据库模式变更递增地记录到所谓的*数据库迁移*中来前滚和回滚数据库模式变更的能力)。

还要注意，我在这里加入了一些额外的方法，作为我们调整 Laravel 默认行为的其他方法的参考。它们被注释掉是因为我们还不太需要它们，但是例如，当我们想要将视图和翻译拆分到它们单独的上下文中，或者甚至拥有不同的语言文件来支持国际用户时，只需简单地改变服务提供商的引导方法就可以做到这一点。最后，在清单 [8-3](#PC5) 中，您会注意到 register 方法只是从`config/claim_submission.php`文件中加载任何已定义的配置值。有关配置的更多信息，请查阅第 [4 章](04.html)。

Utilizing Third-Party Packages, Frameworks, Tools

在当今这个时代，我们经常会看到各种不同的技术被独立开发出来，但最终都聚集在一起，提供一个完整的工作应用。公司通常只有精选的几个基础技术栈来作为公司软件架构的基础:Solaris、Linux/Unix、Windows 和其他一些技术。核心堆栈的选择应该基于系统的需求、基础设施的支持以及开发团队的经验。如果每个人都非常了解 PHP，并且该项目需要一个基于 web 的架构，该架构可以从一个框架中构建以节省时间和成本，那么开源是更好、更实用的方法。但是，如果您希望在技术体系中获得支持，包括客户支持和软件维护/更新/功能，并且您正在寻找易于使用的产品，那么基于 Windows 的技术体系可能是您的最佳选择。

创业公司倾向于采用开源开发，因为它广泛、廉价且有效。有开源解决方案适合几乎所有常见的开发和互联网需求。很多时候，一个架构的成功实现支持一个狭隘的基于利基的业务策略的特定需求，包括找到预构建的库、框架、工具或任何其他东西，这些东西在没有大量开销的情况下增加业务价值和/或加速开发过程并提高最终产品的质量。然后在实现业务逻辑时利用这些第三方库的功能，并将它们组合在一起以实现一些共同的目标或构建一组功能。

尽管这是以一种或另一种形式作为开发 web 应用软件的手段基本上跨越整个行业的循环，但我们必须小心不要混淆该领域的意图。与此同时，许多这样的包和框架，包括 Laravel，都是按照高质量标准和现代最佳实践构建的，因此利用它们并不一定是件坏事。归根结底，这些包的可扩展性如何，以及修改代码的库存分布以满足您的需求有多容易(这就是开源的伟大之处！).我选择 Laravel 作为我的标准 web 开发框架，因为除了其他原因之外，它简单明了，易于扩展和定制。

## 第六步:后退一步

在这一点上，我们已经勾画出了我们的 claims 示例项目的边界，并且很好地理解了如何划分领域以使其更易于管理。然而，这种架构远非完美。如果您已经注意到，每个有界上下文中的架构层之间的界限经常是模糊的，因为某些组件应该放在哪里并不总是显而易见的。这就好像我们在和拉勒维尔战斗，迫使它屈从于我们的意志。

向前发展，我们需要寻找我们可以架构系统的方法，以便领域仍然是最高优先级，但是使用我们的领域层可以扩展的 Laravel 组件、特征和接口。通过这种方式，我们保持了一种专注于领域的方法来制作应用，同时还能获得 Laravel 提供的最大好处。

问题在于分层架构的封装规则。它声明域不能依赖于它自己层之外的任何东西。本质上，这意味着，因为我们有一些 Laravel 类或接口想要在领域层的边界内扩展，我们将被迫从不同的层扩展到我们的领域模型中。事实上，当我们后退一步，看看我们正在处理的整个范围时，我们发现在我们迄今为止已经建立的架构中，确实没有合适的地方可以容纳任何存在于`/vendor`文件夹中的第三方代码或框架库(并且默认情况下没有包含在股票 Laravel 安装中)。但是，当我们试图在一个简单的 UML 图中对此建模时，我们可以看到，对于每一条指向错误方向(即“远离”域层)的线，确实存在一个依赖关系，这表明当依赖关系应该将*指向*域层时，域依赖于位于域层之外的代码和组件，因此域外的代码依赖于域模型中的类(图 [8-6](#Fig6) )。

![img/488324_1_En_8_Chapter/488324_1_En_8_Fig6_HTML.jpg](img/488324_1_En_8_Chapter/488324_1_En_8_Fig6_HTML.jpg)

图 8-6

依赖朝着错误的方向发展

### 打破规则？

为了给我们的应用形成一个更好的架构，我们将不得不打破一条纯粹主义者极力保护的规则。我来解释一下。

我们需要灵活地思考和理解应用的开发。Laravel 是一个框架。这本身就违背了 DDD 的一个基本观点，即框架在领域驱动的项目中使用起来过于严格。作为开发人员，我们需要理解软件和 web 开发的本质，我们很难真正“从零开始”构建任何东西我自己都不知道上一次我从一个空目录和一个空白 PHP 文件开始编写整个程序是什么时候，而不仅仅是一个脚本或一次性的。简单的事实是，纯粹主义者的心态只能存在于完美的世界中。鉴于这个世界远非完美，我们需要在思维过程和观点上更现实一点。

我们为应用创建新结构的第一次尝试在技术上是可行的，但这远不是一个优化的解决方案。使 Laravel 对我们有价值的组件需要一个地方，以便我们的代码可以利用和扩展它。显然，这个地方是`/vendor`文件夹，我们在`/vendor`文件夹中引用的项目都有一个结构化的名称空间，位于不同的包中。然而，当您考虑到，在分层的架构中，领域层(也称为业务规则和“低级”策略，对应于您正在使用的实现)应该是自封装的。领域层中的任何东西都不应该知道、使用或依赖于它自己的层之外的任何东西。然而，它可以依赖并使用*也*位于域层中的类或对象。那么，我们应该如何使用*任何*第三方包、库，甚至框架，而不让领域层内的项目利用其层外的任何代码呢？

有人可能会说，解决这个难题的一个可能的办法是，要么最小化(或者全部移除)任何第三方依赖，或者更荒谬的是，在你的项目中根本不依赖框架。这显然不是一个非常可行的解决方案。软件应该被扩展、构建，并且最好在其他项目中重用，以提供一些给定的功能集，从而避免为需要相同功能的每个项目重写逻辑。无论如何，这就是我们的想法，并且在完美的世界中也是如此，但是现实是，软件重用通常是一件具有挑战性的事情，而且更具挑战性的是，在尽可能利用外部代码的同时，以一种可扩展的、灵活的、与应用的其他部分松散耦合的方式来实现。

事实上，这是现代软件开发领域的驱动概念，被称为*快速应用开发*。快速开发的思想是使用尽可能多的第三方包、库和框架来实现您的特性、业务逻辑和您需要系统在功能上做的任何事情，从而释放您的时间和精力来关注更高层次的问题和对系统成功至关重要的重要的、必需的部分(这里指的是领域模型)。所有第三方代码都可供您用来构建许多其他应用共有的特性和功能。例如，在 GitHub 和开源包中有很多关于软件中常见问题的库，包括日志、ORM 问题或 CRUD 包。这些都是为了易于使用，并允许您依赖第三方库，这样您就不必为这些常见的问题重新发明轮子。

另一个可能的解决方案是反转依赖关系，就像依赖关系反转原理一样。这个原则的一般概念被分解成两个独立的规则。

*   抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。

*   高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。

因此，这对我们来说意味着我们可以使用接口(抽象)来使依赖指向另一个方向(向内指向域模型)。对于我们的使用来说，问题在于没有一种明确的方法来从领域模型中提取抽象；它们应该是自包含的，并且拥有与该层中的领域相关的所有知识。此外，因为我们希望在我们的领域模型中利用雄辩的框架，反转依赖关系仍然会给我们留下一个知道领域层之外的事情的领域模型。

#### 进化范式

在过去的二十年中，我们所见证的框架、库、包和工具的爆炸已经产生了足够的影响，完全改变了我们编写代码的方式；然而，自 20 世纪 80 年代和 90 年代以来，我们思考代码的方式并没有太大的改变。当然，我们更加意识到我们的代码所产生的影响，并因此更加小心地选择为使软件工作而创建的功能的最佳位置，并且我们已经学会了在成功项目中经常发生的决策中灵活地让领域专家和利益相关者参与进来。然而，我们思考软件的方式基本上和很久以前一样。自 20 世纪 60 年代以来，面向对象编程就一直存在，并且仍然是用于构建大多数现代软件和 web 应用的最流行的通用范例。四人帮于 1994 年发布的设计模式处女作仍然是所有这些最新和最伟大的框架和“不能没有”的包背后的驱动力，这些框架和包使我们的生活更容易，我们的成功潜力更大。

在我看来，过去几十年发生的事情只是 web 开发编程所经历的自然进化过程；我们只是在最近才采用了那些很久以前发现的标准，但这些标准在今天的 web 开发行业中仍然适用。最近，在前端 web 开发实践和语言的发展中可以看到另一个例子。Vue 之类的框架。JS、Angular 和 React 都源于 70 年前发现的编程范例。虽然看起来前端 web 开发已经呈现出一种新的形式，但实际上所有正在发生的事情与 2000 年左右一般 web 开发所发生的事情是一样的:它正在发展。编程语言的数量在过去 20 年左右也出现了爆炸式增长，其目的通常是成为工具，专门满足随着 web 开发需求而出现的新发现的业务需求。

围绕网络开发的思维过程也发生了类似的事情。纯粹主义者的心态有着良好的意图，并且决不是错误或坏的，但是在我看来，作为一个对任何特定技术、语言、过程或架构方向的“纯粹主义者”,在我们知道如何做某事的当前方式和完成同一件事的新的(通常是改进的)方式之间设置了一个精神障碍，尽管是潜意识的，导致我们作为开发人员的发展能力停滞不前。正如我们所知，我们对开发的理解(理论上)是基于我们不得不花费时间和精力去理解的最佳实践，甚至花费更多的时间和精力在我们的应用中有效地使用*。通常，我们努力实现的这种理解恰恰会阻碍我们利用行业的下一个进步。当然，这些进步采取了许多不同的形式，从长期受欢迎的语言的新版本(PHP 7.0、JavaScript ES6 和 HTML 5，仅举几个例子)到引入全新的开发过程思维方式(Angular 和 Vue)。JS)，但它们的最终结果最终都是一样的:一个工作软件、web 应用、API 接口，或者更高级的东西，比如以 Google RPC (gRPC)协议缓冲区为中心的微服务架构。您可以在 [`https://grpc.io`](https://grpc.io) 找到更多关于协议缓冲区的信息。*

 *现在，这并不是说设计模式、坚实的原则以及其他关于软件架构和 web 开发的标准和实践不会存在太久。相反，理解这些类型的通用概念对于成为一名优秀的开发人员至关重要，如果使用正确，它们将为创建一个长寿、高质量的软件铺平道路。但是，我们必须小心的是，在我们个人的 web 开发实践中，我们完全服从于单一的关注点或范式。很久以前，人们认为世界是平的。我敢打赌，如果你回到那个时代，提出地球是圆的，你会被嘲笑，因为你没有受过教育的论点而被嘲笑，甚至可能被杀。尽管地球确实是圆的，但当时的心态是它是平的。在古希腊人引入这一理念后，其他人花了相当长的时间(我可以想象)才赶上并接受这一理念。web 开发也是如此。这需要时间，许多实验，许多尝试和失败，才能让整个社区接受并采用一种新的不同的标准。

## 思想的转变

我们必须对我们的思维进行的最大改变涉及到依赖倒置原则和领域封装实践，这是领域驱动设计的核心。重要的是，我们将我们的领域模型封装在某种概念边界中，该边界将领域的关注点与处理领域层对象的应用或基础结构的关注点分开(无论是持久化它们、初始化它们、重新创建它们、记录它们，等等)。).

有各种方法来处理架构 web 应用。例如，在野外(或者每当开始一项新工作或者继承一个遗留代码库时)，往往会发生的情况是，项目的开发不是由最佳实践指导的，而是严格遵循著名的“让它工作就好！”范例。在创业公司中，经常会发生的情况是，无论他们建立了什么样的系统来为他们赚钱，或者为投资者提供概念证明，让他们将钱投入到业务中，这些系统都是用拼凑起来的代码构建的，这些代码很乱，很难维护，甚至更难教给其他人。快速应用开发范例与这一概念并行运行:从尽可能多的预构建内容开始开发过程，然后定制您需要的内容以创建所需的功能，拼凑(此时)“粗略的”业务策略和实践，这些策略和实践实际上仍在应用开始时定义和建立，将其推出到生产中，清洗并重复。

从技术或编程的角度来看，这种方法本身没有任何问题；毕竟，编程游戏的名字就是代码可重用性和抽象。当代码库增长时，问题通常会出现，并且在某一点上在其自身基础设施的压力下崩溃，从而使应用变得无用，或者随着业务需求变得越来越复杂，增加对应用进行修改和添加的时间。在这种情况下，拥有软件的公司通常会被迫做出一个关键的决定，要么整个重构系统，要么两害相权取其轻，从头开始创建整个系统。后一种选择已经在编码行业中被一次又一次地证明几乎总是失败，因为当你从头开始时，你必须用这个新的应用解决你用旧的应用解决的所有问题、争论和故障。

我们都应该更容易接受新的想法，不要让我们对事物如何运作的现有理解或我们对做某事的最佳方式的知识干扰新的和更好的思维过程、工具、概念和实践。我们的数字生态系统中不断发展的实践和标准使我们的行业不那么具有可塑性，当然，这个行业是一个不断重新定义和重塑自己以满足现代业务需求不断增长的行业。

回到我们手头的问题，我们可以做的是打破规则，让我们的领域实体扩展雄辩的 base `Model`类，理解我们只是使用它作为一种手段，允许领域层内的模型和事物通过扩展它们或通过特征包含它们来利用框架内的特性，而不是其他。如果我们坚持只依赖框架提供的外部类或特征，那么我们可以保持应用的整体结构完整，仍然清晰地将各种关注点划分到相应的层中，仍然在层之间建立边界，同时仍然利用 Laravel 的功能。

## 结论

在最坏的情况下，不符合当前标准和最佳实践的架构师和开发人员将“确定”整个系统是糟糕的，他们必须从头开始重写它——基本上是为了重写它。然后，尽管从逻辑上看，第二次实现可能会更快，但下一个版本注定会有与上一个版本相同的问题和缺点。原因可能各不相同。

*   难以建模的过于复杂的领域

*   缺乏设计满足所有项目要求的质量体系所需的适当经验的架构师

*   缺乏一般软件开发经验(低水平或高水平)的开发人员

*   缺乏领域经验的开发人员(尽管您显然不希望让新人负责整个系统或部分系统的架构设计)

*   阻碍进步的公司政治

*   “专家”是公司工程团队的一部分，他们阻止技术进步和新的、改进的流程和标准

*   其他团队成员不愿意改变他们自己的方式来学习新的、经常改进的开发实践

*   团队中的一些成员(甚至是一个成员)不愿意接受自动化过程，即使它可以节省时间、精力和金钱

*   思想狭隘

*   没有学习的能力或愿望

*   还有很多很多其他人…

这种软件开发方法效率不高；然而，它可能实际上看起来并没有那么糟糕，因为，在那个时候，找到足够的包和库在您的应用中使用，然后将它们粘合在一起，通常构建起来非常快(这就是为什么它被称为快速应用开发)。这在某种程度上是一种危险的误解，当企业因为前面列出的原因成长并成功时，这种误解会产生深远的后果。

减轻这种情况的一种方法是使用好的设计原则和设计模式以及抽象和接口，这实际上等同于好的架构。我们发现，当我们在构建系统时采用良好的原则和标准时，我们允许自己在某种意义上灵活地计划变化。通过使用接口和/或抽象类来定义应用中发生变化的各个部分，我们让代码对扩展开放，但对修改关闭。以这种方式，通过简单地扩展该接口并将其插入到应用中，其他代码可以在我们的应用中交互和使用。像这样的事情可能会变得复杂，但是正确使用和理解 Laravel 的服务容器，包括如何设置实现，以便在满足某些内部条件时自动加载和运行。服务容器功能强大，为我们提供了一定程度的灵活性，这对于管理依赖关系和创建基于上下文操作的定制依赖注入配置非常有用。有关服务容器的更多信息，请参见第 [4](04.html) 章。

在这一章中，我们给出了应用结构的一个起点。虽然各层之间的各种概念和界限在这一点上可能有点模糊，但我们可以利用我们所拥有的东西来共同打造必要的功能，以使我们的应用起步。这种结构远非完美，我们将在本书的其余部分进行修改，当它有意义时。只要它有助于阐明应用的意图，只要我们能够利用框架完成所有 web 应用中的常见任务，我们就会这样做。

但是我们不能忽视这个领域。虽然这一章是大量涉及 Laravel 相关的章节，但是我们应该始终保持领域是最重要的东西的观念，我们前进的最好方式是允许领域驱动应用的构造。通过允许我们的模型实现雄辩的基类，并通过实现诸如可调度事件、服务和 Laravel 作业之类的功能，我们可以访问 Laravel 的所有特性，而不会违反太多规则。我们将开始看到的是，我们在本书中介绍的分层架构只是构建应用(如用 DDL 创建的应用)的一种方式。有更好的方法来分离事物，我们将在后面探索。现在，我们有了一个可以工作的结构，这将为我们构建项目所需的初始功能提供基础。稍后，我们将开始开发一种更好的方法，通过利用用例和六边形架构来构建组件。*