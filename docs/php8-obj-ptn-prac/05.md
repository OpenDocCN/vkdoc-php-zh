# 5.对象工具

正如我们所见，PHP 通过类和方法等语言结构支持面向对象编程。该语言还通过旨在帮助您处理对象的函数和类提供了更广泛的支持。

在这一章中，我们将会看到一些可以用来组织、测试和操作对象和类的工具和技术。

本章将涵盖以下工具和技术:

*   名称空间(Namespaces):将你的代码组织成独立的类似包的部分

*   *包含路径*:为您的库代码设置中央可访问位置

*   *类和对象函数*:测试对象、类、属性和方法的函数

*   反射 API:一套强大的内置类，在运行时提供对类信息前所未有的访问

*   *属性* : PHP 对*注释*的实现——一种机制，通过这种机制，类、方法、属性和参数可以使用源代码中的标签用丰富的信息来增强

## PHP 和包

包是一组相关的类和函数，通常以某种方式组合在一起。包可以用来将系统的各个部分相互分离。一些编程语言正式识别包，并为它们提供不同的名称空间。PHP 本身没有包的概念，但是从 PHP 5.3 开始，它引入了名称空间。我将在下一节讨论这个特性。我还将看看将类组织成类似包的结构的老方法。

### PHP 包和名称空间

尽管 PHP 本质上并不支持包的概念，但开发人员传统上使用命名方案和文件系统将他们的代码组织成类似包的结构。

直到 PHP 5.3，开发人员被迫在共享的上下文中命名他们的文件。换句话说，如果您命名了一个类`ShoppingBasket`，它将立即在您的系统中可用。这导致了两个主要问题。首先，也是最具破坏性的，是命名冲突的可能性。你可能认为这不太可能。毕竟，你所要做的就是记住给所有的类起一个唯一的名字，对吗？问题是，我们越来越依赖库代码。这当然是件好事，因为它促进了代码重用。但是假设您的项目是这样的:

```php
// listing 05.01
require_once __DIR__ . "/../useful/Outputter.php";

class Outputter
{
    // output data
}

```

现在假设您在`useful/Outputter.php`合并了包含的文件:

```php
// listing 05.02
class Outputter
{
    //
}

```

你能猜到会发生什么，对吗？出现这种情况:

```php
PHP Fatal error: Cannot declare class Outputter because the name is
already in use in /var/popp/src/ch05/batch01/useful/Outputter.php on
line 4

```

在引入名称空间之前，有一个解决这个问题的传统方法。答案是在类名前面加上包名，这样就保证了类名的唯一性:

```php
// listing 05.03

// my/Outputer.php

require_once __DIR __ . "/../useful/Outputter.php";

class my_Outputter
{
    // output data
}

```

```php
// listing 05.04

// useful/Outputter.php

class useful_Outputter
{
    //
}

```

这里的问题是，随着项目越来越复杂，类名变得越来越长。这不是一个很大的问题，但是它导致了代码可读性的问题，并且使得在工作时更难记住类名。许多累积的编码时间都浪费在了打字错误上。

如果您维护的是遗留代码，您可能仍然会看到遵循这种约定的代码。因此，在本章的后面，我将简单地回到处理包的老方法。

#### 名称空间拯救世界

PHP 5.3 引入了名称空间。本质上，名称空间是一个桶，您可以在其中放置您的类、函数和变量。在命名空间中，您可以无限制地访问这些项。从外部，您必须导入或引用该命名空间，以便访问它包含的项。

迷茫？举个例子应该会有帮助。在这里，我使用名称空间重写了前面的示例:

```php
// listing 05.05
namespace my;

require_once __DIR__ . "/../useful/Outputter.php";

class Outputter
{
    // output data
}

```

```php
// listing 05.06

namespace useful;

class Outputter
{
    //
}

```

注意关键字`namespace`。如您所料，这个关键字建立了一个名称空间。如果使用这个特性，那么命名空间声明必须是其文件中的第一条语句。我创建了两个名称空间:`my`和`useful`。不过，通常情况下，您会希望有更深的名称空间。您将从一个组织或项目标识符开始。然后，您需要通过产品包来进一步验证这一点。PHP 允许您声明嵌套的名称空间。为此，您只需使用反斜杠字符来划分每个级别:

```php
// listing 05.07
namespace popp\ch05\batch04\util;

class Debug
{
    public static function helloWorld(): void
    {
        print "hello from Debug\n";
    }
}

```

您通常会使用与产品或组织相关的名称来定义存储库。我可能会使用我的一个域:`getinstance.com`，例如。因为域名对其所有者来说是唯一的，所以这是 Java 开发人员通常用于他们的包名的一个技巧。它们颠倒域名，从最普通的到最特殊的。或者，我可以使用我为本书中的代码示例选择的名称空间:`popp`，作为书名。一旦我确定了我的存储库，我可能会继续定义包。在这种情况下，我使用的是章节，然后是编号的批次。这允许我将示例组组织到离散的桶中。所以在这一章的这一点上，我在`popp\ch05\batch04`。最后，我可以进一步按类别组织代码。我和`util`一起去了。

那么我该如何调用这个方法呢？事实上，这取决于你从哪里打电话。如果从命名空间内调用方法，可以直接调用方法:

```php
// listing 05.08
Debug::helloWorld();

```

这就是所谓的非限定名。因为我已经在`popp\ch05\batch04\util`名称空间中，所以我不需要在类名前添加任何类型的路径。如果我从命名空间上下文之外访问该类，我可以这样做:

```php
// listing 05.09
\popp\ch05\batch04\Debug::helloworld();

```

我会从下面的代码中得到什么输出？

```php
// listing 05.10
namespace main;

    popp\ch05\batch04\Debug::helloworld();

```

那是一个棘手的问题。事实上，这是我的输出:

```php
PHP Fatal error: Class 'popp\ch05\batch04\Debug' not found in...

```

这是因为我在这里使用了相对名称空间。PHP 在名称空间`main`下寻找`popp\ ch05\batch04\util`，但没有找到。正如您可以通过使用分隔符创建绝对 URL 和文件路径一样，您也可以创建名称空间。此版本的示例修复了以前的错误:

```php
// listing 05.11
namespace main;

    \popp\ch05\batch04\Debug::helloworld();

```

这个反斜杠告诉 PHP 从根开始搜索，而不是从当前名称空间开始。

但是名称空间不是应该帮助您减少输入吗？当然,`Debug`类声明更短，但是这些调用就像旧的命名约定一样冗长。您可以使用`use`关键字来解决这个问题。这允许您在当前名称空间内为其他名称空间起别名。这里有一个例子:

```php
// listing 05.12
namespace main;

use popp\ch05\batch04\util;

    util\Debug::helloWorld();

```

`popp\ch05\batch04\util`名称空间被导入并隐式别名化为`util`。请注意，我没有以反斜杠字符开头。`use`的参数是从根空间搜索的，而不是从当前的名称空间。如果我根本不想引用名称空间，我可以导入`Debug`类本身:

```php
// listing 05.13
namespace main;

use popp\ch05\batch04\util\Debug;

    Debug::helloWorld();

```

这是最常用的约定。但是，如果在调用名称空间中已经有了一个`Debug`类，会发生什么呢？这里有这样一个类:

```php
// listing 05.14
namespace popp\ch05\batch04;

class Debug
{
    public static function helloWorld(): void
    {
        print "hello from popp\\ch05\\batch04\\Debug\n";
    }
}

```

这里有一些来自`popp\ch05\batch04`名称空间的调用代码，它引用了两个`Debug`类:

```php
// listing 05.15
namespace popp\ch05\batch04;

use popp\ch05\batch04\util\Debug;
use popp\ch05\batch04\Debug;

Debug::helloWorld();

```

如您所料，这会导致致命错误:

```php
PHP Fatal error: Cannot use popp\ch05\batch04\Debug as Debug because the name is already in use in...

```

因此，我似乎又回到了原点，回到了类名冲突。幸运的是，这个问题有一个答案。我可以明确我的别名:

```php
// listing 05.16
namespace popp\ch05\batch04;

use popp\ch05\batch04\util\Debug;
use popp\ch05\batch04\Debug as CoreDebug;

CoreDebug::helloWorld();

```

通过将`as`子句用于`use`，我能够将`Debug`别名改为`coreDebug`。

如果你在一个命名空间中编写代码，并且你想访问一个驻留在根(非命名空间)空间中的类、特征或接口(例如，PHP 的核心类，如`Exception`、`Error`、`Closure`)，你可以简单地在名字前面加一个反斜杠。这里有一个在根空间中声明的类:

```php
// listing 05.17
class TreeLister
{
    public static function helloWorld(): void
    {
        print "hello from root namespace\n";
    }
}

```

这里有一些命名空间代码:

```php
// listing 05.18
namespace popp\ch05\batch04\util;

class TreeLister
{
    public static function helloWorld(): void
    {
        print "hello from " . __NAMESPACE__ . "\n";
    }
}

```

```php
// listing 05.19
namespace popp\ch05\batch04;

use popp\ch05\batch04\util\TreeLister;

        TreeLister::helloWorld();  // access local
        \TreeLister::helloWorld(); // access from root

```

命名空间代码声明了它自己的`TreeLister`类。客户端代码使用本地版本，用一个`use`语句指定完整路径。用单个反斜杠限定的名称访问根名称空间中类似命名的类。

这是上一个片段的输出:

```php
hello from popp\ch05\batch04\util
hello from root namespace

```

这个输出值得展示，因为它演示了`__NAMESPACE__`常量的操作。这将输出当前的名称空间，这在调试中很有用。

您可以使用已经看到的语法在同一个文件中声明多个名称空间。您还可以使用一种将大括号与 namespace 关键字结合使用的替代语法:

```php
// listing 05.20
namespace com\getinstance\util {

    class Debug
    {
        public static function helloWorld(): void
        {
            print "hello from Debug\n";
        }
    }
}

namespace other {

    \com\getinstance\util\Debug::helloWorld();
}

```

如果您必须在同一个文件中组合多个名称空间，那么这是推荐的做法。然而，通常认为在每个文件的基础上定义名称空间是最佳实践。

Note

不能在同一个文件中同时使用大括号和 line 命名空间语法。你必须选择一个并坚持到底。

#### 使用文件系统模拟包

无论您使用哪个版本的 PHP，您都应该使用文件系统来组织类，文件系统提供了一种包结构。例如，您可以创建`util`和`business`目录，并包含带有`require_once()`语句的类文件，如下所示:

```php
// listing 05.21
require_once('business/Customer.php');
require_once('util/WebTools.php');

```

你也可以使用`include_once()`达到同样的效果。`include()`和`require()`语句之间的唯一区别在于它们对错误的处理。当您遇到错误时，使用`require()`调用的文件将使您的整个过程停止。通过调用`include()`遇到的同样的错误只会产生一个警告并结束包含文件的执行，让调用代码继续。这使得`require()`和`require_once()`成为包含库文件的安全选择，而`include()`和`include_once()`对于模板化之类的操作非常有用。

Note

`require()`和`require_once()`其实是语句，不是函数。这意味着您可以在使用括号时省略它们。就我个人而言，我更喜欢使用括号，但如果你也这样做，请做好被急于解释你的错误的学究们烦透的准备。

图 [5-1](#Fig1) 从 Nautilus 文件管理器的角度显示了`util`和`business`包。

![../images/314621_6_En_5_Chapter/314621_6_En_5_Fig1_HTML.jpg](../images/314621_6_En_5_Chapter/314621_6_En_5_Fig1_HTML.jpg)

图 5-1

使用文件系统组织的 PHP 包

Note

`require_once()`接受文件的路径，并将其包含在当前脚本中。只有在目标尚未包含在其他地方的情况下，该语句才会包含目标。这种一次性方法在访问库代码时特别有用，因为它可以防止意外重定义类和函数。当使用像`require()`或`include()`这样的语句，同一个文件被脚本的不同部分包含在一个进程中时，就会发生这种情况。

习惯上优先使用`require()`和`require_once()`而不是类似的`include()`和`include_once()`功能。这是因为在使用`require()`函数访问的文件中遇到致命错误会导致整个脚本停止运行。在使用`include()`函数访问的文件中遇到的相同错误将导致包含文件的执行停止，但只会在调用脚本中生成一个警告。前者，更激烈的行为，更安全。

与`require()`相比，使用`require_once()`会产生开销。如果你需要从你的系统中挤出最后一毫秒，你可以考虑使用`require()`来代替。通常情况下，这是效率和便利之间的权衡。

就 PHP 而言，这种结构并没有什么特别之处。您只是将库脚本放在不同的目录中。它确实有助于组织的整洁，并且可以与名称空间或命名约定并行使用。

#### 命名梨的方式

在引入名称空间之前，开发人员被迫求助于约定来避免类名冲突。正如我们所看到的，其中最常见的是 PEAR 开发人员维护的假命名空间。

Note

PEAR 代表 PHP 扩展和应用程序库。它是官方维护的增加 PHP 功能的包和工具的档案。核心 PEAR 包包含在 PHP 发行版中，其他包可以使用简单的命令行工具添加。您可以在 [`http://pear.php.net`浏览梨包。](http://pear.php.net/)

PEAR 使用文件系统来定义它的包，正如我所描述的。在引入名称空间之前，每个类都是根据其包路径命名的，每个目录名用下划线字符分隔。

例如，PEAR 包含一个名为 XML 的包，其中有一个 RPC 子包。RPC 包包含一个名为`Server.php`的文件。如你所料，`Server.php`中定义的类并不叫做`Server`。如果没有名称空间，迟早会与 PEAR 项目或用户代码中的另一个`Server`类发生冲突。相反，这个类被命名为`XML_RPC_Server`。这种方法产生了不吸引人的类名。然而，它确实使代码易于阅读，因为类名总是描述它自己的上下文。

#### 包括路径

当你组织你的组件时，有两个观点你应该记住。我已经介绍了第一种，文件和目录放在文件系统中。但是您也应该考虑组件相互访问的方式。到目前为止，我在本节中已经谈到了包含路径的问题。

当包含一个文件时，可以使用当前工作目录的相对路径或文件系统上的绝对路径来引用它。

Note

尽管理解包含路径的工作方式和要求文件所涉及的问题很重要，但是记住许多现代系统不再依赖类级别的 require 语句也很重要。相反，它们使用自动加载和名称空间的组合。稍后我将介绍自动加载，然后在第 [15](15.html) 和 [16](16.html) 章中更详细地查看实用的自动加载建议和工具。

到目前为止，您所看到的示例偶尔会指定需求文件和必需文件之间的固定关系:

```php
// listing 05.22
require_once __DIR__ . "/../useful/Outputter.php";

```

这工作得很好，除了它硬编码了文件之间的关系。在调用类的包含目录旁边必须总是有一个`useful`目录。

也许最糟糕的方法是曲折的相对路径:

```php
// listing 05.23
require_once('../../projectlib/business/User.php');

```

这是有问题的，因为这里指定的路径不是相对于包含这个`require_once`语句的文件，而是相对于配置的调用上下文(通常，但不总是，当前工作目录)。像这样的路径会导致混乱(根据我的经验，这几乎总是一个迹象，表明一个系统在其他方面也需要相当大的改进)。

当然，您可以使用绝对路径:

```php
// listing 05.24
require_once('/home/john/projectlib/business/User.php');

```

这将适用于单个实例——但它很脆弱。通过如此详细地指定路径，可以将库文件冻结在特定的上下文中。每当你在一个新的服务器上安装项目时，所有的`require`语句都需要改变以适应一个新的文件路径。这使得库很难重新定位，如果不制作副本，在项目间共享库也不切实际。在这两种情况下，您都失去了在所有附加目录中打包的想法。是`business`套餐，还是`projectlib/business`套餐？

如果您必须在代码中手动包含文件，最简洁的方法是将调用代码从库中分离出来。您已经看到了这样的结构:

```php
// listing 05.25
require_once('business/User.php');

```

在前面使用这种路径的例子中，我们隐含地假设了一个相对路径。换句话说，`business/User.php`在功能上与`./business/User.php`相同。但是，如果前面的 require 语句可以在系统上的任何目录下工作，那会怎么样呢？您可以使用包含路径来实现这一点。这是 PHP 在试图获取文件时搜索的目录列表。你可以通过修改`include_path`指令来增加这个列表。`include_path`通常在 PHP 的中央配置文件`php.ini`中设置。它定义了一个目录列表，在类 Unix 系统中用冒号分隔，在 Windows 系统中用分号分隔:

```php
include_path = ".:/usr/local/lib/php-libraries"

```

如果您正在使用 Apache，您也可以在服务器应用程序的配置文件(通常称为`httpd.conf`)或每个目录的 Apache 配置文件(通常称为`.htaccess`)中设置`include_path`，语法如下:

```php
php_value include_path value .:/usr/local/lib/php-libraries

```

Note

文件在一些托管公司提供的网络空间中特别有用，这些公司提供非常有限的对服务器环境的访问。

当您使用一个文件系统函数，如`fopen()`或`require()`时，其非绝对路径相对于当前工作目录不存在，包含路径中的目录会自动搜索，从列表中的第一个目录开始(对于`fopen()`，您必须在其参数列表中包含一个标志来启用该特性)。当遇到目标文件时，搜索结束，文件函数完成它的任务。

因此，通过将包目录放在包含目录中，您只需要在您的`require()`语句中引用包和文件。

您可能需要向`include_path`添加一个目录，这样您就可以维护自己的库目录。要做到这一点，您可以编辑`php.ini`文件(记住，对于 PHP 服务器模块，您需要重启服务器以使更改生效)。

如果您没有使用`php.ini`文件所需的权限，您可以使用`set_include_path()`函数在脚本中设置包含路径。`set_include_path()`接受一个包含路径(正如它将出现在`php.ini`中)并仅改变当前进程的`include_path`设置。`php.ini`文件可能已经为`include_path`定义了一个有用的值，所以与其覆盖它，不如使用`get_include_path()`函数访问它，并添加您自己的目录。以下是将目录添加到当前包含路径的方法:

```php
set_include_path(get_include_path() . PATH_SEPARATOR . "/home/john/phplib/");

```

`PATH_SEPARATOR`常量将在 Unix 系统上解析为冒号，在 Windows 平台上解析为分号。因此，出于可移植性的原因，使用它被认为是最佳实践。

### 自动加载

尽管将`require_once`与 include 路径结合使用很简洁，但是许多开发人员在高级别上完全摒弃了 require 语句，转而依赖于 autoload。

Note

本书以前的版本讨论了一个名为`__autoload()`的内置函数，它提供了本节讨论的功能的一个更粗糙的版本。从 PHP 7.2.0 开始，这个函数被弃用，并在 PHP 8 中被删除。

为此，您应该组织您的类，使每个类都位于自己的文件中。每个类文件应该与它包含的类名有固定的关系，所以您可以在名为`ShopProduct.php`的文件中定义一个`ShopProduct`类，其目录对应于该类的名称空间的元素。

PHP 5 引入了自动加载功能来帮助自动包含类文件。默认支持非常基本，但仍然有用。可以通过不带参数调用名为`spl_autoload_register()`的函数来启用它。然后，如果以这种方式激活了自动加载功能，当您试图实例化一个未知的类时，PHP 将调用一个名为`spl_autoload()`的内置函数。这将使用提供的类名(转换成小写)在您的包含路径中搜索名为`<classname>.php`或`<classname>.inc`(其中`<classname>`是未知类名)的文件。

这里有一个简单的例子:

```php
// listing 05.26
spl_autoload_register();
$writer = new Writer();

```

假设我还没有包含一个包含`Writer`对象的文件，这个实例化看起来注定会失败。然而，因为我已经设置了自动加载，PHP 将试图包含一个名为`writer.php`或`writer.inc`的文件，然后将再次尝试实例化。如果这些文件中的一个存在，并且包含一个名为`Writer`的类，那么一切都会好的。

此默认行为支持名称空间，用目录名替换每个包:

```php
// listing 05.27
spl_autoload_register();
$writer = new util\Writer();

```

前面的代码将在名为`util`的目录中找到名为`writer.php`(注意小写名称)的文件。

如果我碰巧根据大小写来命名我的类文件怎么办？也就是说，如果我保留大写字母来命名它们呢？如果我将`Writer`类放在一个名为`Writer.php`的文件中，那么默认实现将无法找到它。

幸运的是，我可以注册自己的自定义函数来处理不同的约定集。为了利用这一点，我必须将一个自定义函数的引用传递给`spl_autoload_register()`。我的自动加载函数需要一个参数。然后，如果 PHP 引擎试图实例化一个未知的类，它将调用这个函数，将未知的类名作为字符串传递给它。由 autoload 函数定义一个策略来定位并包含丢失的类文件。一旦调用了 autoload 函数，PHP 将再次尝试实例化该类。

下面是一个简单的自动加载函数，以及一个要加载的类:

```php
// listing 05.28
class Blah
{
    public function wave(): void
    {
        print "saying hi from root";
    }
}

```

```php
// listing 05.29
$basic = function (string $classname) {
    $file = __DIR__ . "/" . "{$classname}.php";
    if (file_exists($file)) {
        require_once($file);
    }
};

\spl_autoload_register($basic);

$blah = new Blah();
$blah->wave();

```

最初未能实例化`Blah`，PHP 引擎将看到我已经用`spl_autoload_register()`函数注册了一个自动加载函数，并向它传递字符串`"Blah"`。我的实现只是试图包含文件`Blah.php`。当然，只有当文件与声明 autoload 函数的文件在同一个目录中时，这才会起作用。在现实世界的例子中，我必须将包含路径配置与我的自动加载逻辑结合起来(这正是 Composer 的自动加载实现所做的)。

如果我想提供老学校的支持，我可能会自动化 PEAR 包包括:

```php
// listing 05.30

class util_Blah
{
    public function wave(): void
    {
        print "saying hi from underscore file";
    }
}

```

```php
// listing 05.31

$underscores = function (string $classname) {
    $path = str_replace('_', DIRECTORY_SEPARATOR, $classname);
    $path = __DIR__ . "/$path";
    if (file_exists("{$path}.php")) {
        require_once("{$path}.php");
    }
};

\spl_autoload_register($underscores);

$blah = new util_Blah();
$blah->wave();

```

如您所见，autoload 函数匹配所提供的`$classname`中的下划线，并用`DIRECTORY_SEPARATOR`字符(Unix 系统上的`/`)替换每一个下划线。我试图包含类文件(`util/Blah.php`)。如果类文件存在，并且它包含的类已被正确命名，则对象应该被实例化而不会出现错误。当然，这确实需要程序员遵守一个命名约定，禁止在类名中使用下划线字符，除非是在它分割包的地方。

名称空间呢？我们已经看到默认的自动加载功能支持名称空间。但是如果我们覆盖默认设置，那么就由我们来提供名称空间支持。这只是匹配和替换反斜杠字符的问题:

```php
// listing 05.32
namespace util;

class LocalPath
{

    public function wave(): void
    {
        print "hello from " . get_class();
    }
}

```

```php
// listing 05.33
$namespaces = function (string $path) {
    if (preg_match('/\\\\/', $path)) {
        $path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
    }
    if (file_exists("{$path}.php")) {
        require_once("{$path}.php");
    }
};

\spl_autoload_register($namespaces);
$obj = new util\LocalPath();
$obj->wave();

```

传递给 autoload 函数的值总是被规范化为完全限定的名称，没有前导反斜杠，因此在实例化时不需要担心别名或相对名称空间。

请注意，这个解决方案绝不是完美的。`file_exists()`函数没有考虑包含路径，所以它不能准确反映`require_once`运行良好的所有情况。对此有各种解决方案。您可以使用自己的路径感知版本的`file_exists()`，或者尝试在 try 子句中要求该文件(在本例中捕捉`Error`，而不是`Exception`)。然而幸运的是，PHP 提供了`stream_resolve_include_path()`函数。这将返回一个表示给定路径的绝对文件名的字符串，或者，对于我们的目的很重要的是，如果在包含路径中找不到该文件，则返回`false`。

```php
// listing 05.34
$namespaces = function (string $path) {
    if (preg_match('/\\\\/', $path)) {
        $path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
    }

    if (\stream_resolve_include_path("{$path}.php") !== false) {
        require_once("{$path}.php");
    }
};

\spl_autoload_register($namespaces);
$obj = new util\LocalPath();
$obj->wave();

```

如果我想同时支持梨形类名*和*名称空间*该怎么办？我可以将我的自动加载实现合并到一个单独的自定义函数中。或者，我可以利用`spl_autoload_register()`堆栈其自动加载函数的事实:*

```php
// listing 05.35
$underscores = function (string $classname) {
    $path = str_replace('_', DIRECTORY_SEPARATOR, $classname);
    $path = __DIR__ . "/$path";
    if (\stream_resolve_include_path("{$path}.php") !== false) {
        require_once("{$path}.php");
    }
};

$namespaces = function (string $path) {
    if (preg_match('/\\\\/',  $path)) {
        $path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
    }
    if (\stream_resolve_include_path("{$path}.php") !== false) {
        require_once("{$path}.php");
    }
};

\spl_autoload_register($namespaces);
\spl_autoload_register($underscores);

$blah = new util_Blah();
$blah->wave();

$obj = new util\LocalPath();
$obj->wave();

```

当遇到未知的类时，PHP 引擎将依次调用 autoload 函数(根据它们注册的顺序)，当可以实例化或所有选项都用尽时停止。

这种堆叠显然是有开销的，那么 PHP 为什么支持它呢？在实际项目中，您可能会将名称空间和下划线策略组合成一个函数。但是，大型系统和第三方库中的组件可能需要注册自己的自动加载机制。堆叠允许系统的多个部分独立注册自动加载策略，而不会相互覆盖。事实上，一个只需要一个自动加载机制的库可以将它的自定义自动加载函数(或者任何类型的可调用函数，比如匿名函数)的名称传递给`spl_autoload_unregister()`来清理它自己！

## 类和对象函数

PHP 为测试类和对象提供了一组强大的函数。这为什么有用？毕竟，您可能编写了脚本中使用的大多数类。

事实上，您在运行时并不总是知道您正在使用的类。例如，您可能已经设计了一个透明地使用第三方附加类的系统。在这种情况下，通常会实例化一个只有类名的对象。PHP 允许你使用字符串动态地引用类，就像这样:

```php
// listing 05.36
namespace tasks;

class Task
{
    public function doSpeak()
    {
        print "hello\n";
    }
}

```

```php
// listing 05.37
$classname = "Task";
require_once("tasks/{$classname}.php");
$classname = "tasks\\$classname";
$myObj = new $classname();
$myObj->doSpeak();

```

这个脚本可能从一个配置文件或者通过比较一个 web 请求和一个目录的内容来获取我分配给`$classname`的字符串。然后，可以使用该字符串加载一个类文件并实例化一个对象。注意，我在这个片段中构造了一个名称空间限定。

通常，当您希望系统能够运行用户创建的插件时，您会这样做。在实际项目中做任何有风险的事情之前，您必须检查该类是否存在，它是否有您期望的方法，等等。

Note

即使采取了安全措施，您也应该对动态安装第三方插件代码保持高度警惕。永远不要自动运行用户上传的代码。这样安装的任何插件通常会以与您的核心代码相同的权限执行，因此恶意插件作者可能会对您的系统造成严重破坏。

这并不是说插件不是一个好主意。允许第三方开发者增强核心系统可以提供很大的灵活性。为了确保更高的安全性，您可以支持插件目录，但是要求代码文件由系统管理员直接安装，或者从受密码保护的管理环境中安装。管理员要么在安装前亲自检查插件代码，要么从一个声誉良好的存储库中寻找插件。这是流行的博客平台 WordPress 处理插件的方式。

一些类函数已经被更强大的反射 API 所取代，我将在这一章的后面讨论。然而，它们的简单性和易用性使它们成为某些情况下的首选。

### 寻找课程

`class_exists()`函数接受一个表示要检查的类的字符串，如果该类存在，则返回一个布尔值`true`，否则返回`false`。

使用这个函数，我可以使前面的片段更安全一点:

```php
// listing 05.38
$base = __DIR__;
$classname = "Task";
$path = "{$base}/tasks/{$classname}.php";
if (! file_exists($path)) {
    throw new \Exception("No such file as {$path}");
}
require_once($path);
$qclassname = "tasks\\$classname";
if (! class_exists($qclassname)) {
    throw new Exception("No such class as $qclassname");
}
$myObj = new $qclassname();
$myObj->doSpeak();

```

当然，你不能确定这个类不需要构造函数参数。为了达到这种安全水平，你必须求助于反射 API，这将在本章后面介绍。然而，`class_exists()`确实允许您在使用它之前检查该类是否存在。

Note

请记住，如前所述，您应该始终警惕外部来源提供的任何数据。在以任何方式使用它之前对它进行测试和处理。对于文件路径，您应该转义或删除点和目录分隔符，以防止不道德的用户更改目录和包含意外的文件。然而，当我描述构建易于扩展的系统的方法时，这些技术通常涵盖部署的所有者(具有隐含的写权限)，而不是她的外部用户。

您还可以使用`get_declared_classes()`函数获得脚本进程中定义的所有类的数组:

```php
// listing 05.39
print_r(get_declared_classes());

```

这将列出用户定义的和内置的类。记住，它只返回函数调用时声明的类。您可以稍后运行`require()`或`require_once()`，从而增加脚本中的类数量。

### 了解一个对象或类

如您所知，您可以使用类类型提示来约束方法参数的对象类型。即使有了这个工具，你也不能总是确定一个对象的类型。

有许多基本工具可以用来检查对象的类型。首先可以用`get_class()`函数检查一个对象的类。它接受任何对象作为参数，并以字符串形式返回其类名:

```php
// listing 05.40
$product = self::getProduct();
if (get_class($product) === 'popp\ch05\batch05\CdProduct') {
    print "\$product is a CdProduct object\n";
}

```

在这个片段中，我从`getProduct()`函数中获取了*某个东西*。为了绝对确定它是一个`CdProduct`对象，我使用了`get_class()`方法。

Note

我在第三章[中讲述了`CdProduct`和`BookProduct`类。](03.html)

下面是`getProduct()`函数:

```php
// listing 05.41
public static function getProduct()
{
    return new CdProduct(
        "Exile on Coldharbour Lane",
        "The",
        "Alabama 3",
        10.99,
        60.33
    );
}

```

`getProduct()`只是实例化并返回一个`CdProduct`对象。我将在本节中充分利用这个功能。

`get_class()`函数是一个非常特殊的工具。你经常想要一个类类型的更一般的确认。您可能想知道一个对象属于`ShopProduct`家族，但是您并不关心它的实际类是`BookProduct`还是`CdProduct`。为此，PHP 提供了`instanceof`运算符。

Note

PHP 4 不支持`instanceof`。相反，它提供了`is_a()`函数，该函数在 PHP 5.0 中被弃用，但在 PHP 5.3 中被恢复了。

`instanceof`操作符使用两个操作数，要测试的对象在关键字的左边，类或接口名在右边。如果对象是给定类型的实例，则解析为`true`:

```php
// listing 05.42
$product = self::getProduct();
if ($product instanceof \popp\ch05\batch05\CdProduct) {
    print "\$product is an instance of CdProduct\n";
}

```

### 获取对类的完全限定字符串引用

名称空间已经清除了面向对象 PHP 的许多丑陋之处。我们不再需要忍受长得离谱的类名，或者冒着命名冲突的风险(遗留代码除外)。另一方面，对于别名和相对名称空间引用，解析一些类路径以使它们是完全限定的可能是一件麻烦的事情。

以下是一些难以解析的类名示例:

```php
// listing 05.43
namespace mypackage;

use util as u;
use util\db\Querier as q;

class Local
{
}

// Resolve these:

// Aliased namespace
//  u\Writer;

// Aliased class
//  q;

// Class referenced in local context
//  Local

```

弄清楚这些类引用是如何解析的并不太难，但是编写代码来捕捉每一种可能性会很痛苦。例如，给定`u\Writer`，自动解析器需要知道`u`是`util`的别名，它本身不是一个名称空间。有益的是，PHP 5.5 引入了`ClassName::class`语法。换句话说，给定一个类引用，您可以附加一个范围解析操作符和`class`关键字来获得完全限定的类名:

```php
// listing 05.44
print u\Writer::class . "\n";
print q::class . "\n";
print Local::class . "\n";

```

前面的代码片段输出如下:

```php
util\Writer
util\db\Querier
mypackage\Local

```

从 PHP 8 开始，你也可以在一个对象上调用`::class`。例如，给定一个`ShopProduct`的实例，我可以得到完整的类名，如下所示:

```php
// listing 05.45
$bookp = new BookProduct(
    "Catch 22",
    "Joseph",
    "Heller",
    11.99,
    300
);
print $bookp::class;

```

运行此输出

```php
popp\ch04\batch02\BookProduct

```

请注意，这种方便的语法并没有提供新的功能——您已经遇到了实现相同结果的`get_class()`函数。

### 学习方法

您可以使用`get_class_methods()`函数获得一个类中所有方法的列表。这需要一个类名，并返回一个包含该类中所有方法名称的数组:

```php
// listing 05.46
print_r(get_class_methods('\\popp\\ch04\\batch02\\BookProduct'));

```

假设`BookProduct`类存在，您可能会看到如下内容:

```php
Array
(
    [0] => __construct
    [1] => getNumberOfPages
    [2] => getSummaryLine
    [3] => getPrice
    [4] => setID
    [5] => getProducerFirstName
    [6] => getProducerMainName
    [7] => setDiscount
    [8] => getDiscount
    [9] => getTitle
    [10] => getProducer
    [11] => getInstance
)

```

在示例中，我将包含类名的字符串传递给`get_class_methods()`，并用`print_r()`函数转储返回的数组。我也可以将一个*对象*传递给`get_class_methods()`，得到同样的结果。只有公共方法的名称才会包含在返回的列表中。

如您所见，您可以将方法名存储在字符串变量中，并与对象一起动态调用它，如下所示:

```php
// listing 05.47
$product = self::getProduct();
$method = "getTitle";   // define a method name
print $product->$method(); // invoke the method

```

当然，这可能是危险的。如果方法不存在会怎么样？正如您所料，您的脚本将会失败并出现错误。您已经遇到了一种测试方法是否存在的方式:

```php
// listing 05.48
if (in_array($method, get_class_methods($product))) {
    print $product->$method(); // invoke the method
}

```

在调用之前，我检查方法名是否存在于由`get_class_methods()`返回的数组中。

PHP 为此提供了更专门的工具。您可以用两个函数在一定程度上检查方法名:`is_callable()`和`method_exists()`。`is_callable()`是两种功能中较为复杂的一种。它接受一个表示函数名的字符串变量作为它的第一个参数，如果该函数存在并且可以被调用，则返回`true`。要对一个方法应用相同的测试，您应该向它传递一个数组来代替函数名。数组必须包含一个对象或类名作为其第一个元素，要检查的方法名作为其第二个元素。如果该方法存在于类中，该函数将返回 true:

```php
// listing 05.49
if (is_callable([$product, $method])) {
    print $product->$method(); // invoke the method
}

```

可选地接受第二个参数，一个布尔值。如果将此设置为`true`，函数将只检查给定方法或函数名的语法，而不检查其实际存在。它还接受可选的第三个参数，该参数应该是一个变量。如果提供，这将用您提供的可调用函数的字符串表示形式填充。

这里，我用可选第三个参数调用`is_callable()`，然后输出:

```php
// listing 05.50
if (is_callable([$product, $method], false, $callableName)) {
    print $callableName;
}

```

这是我的输出:

```php
popp\ch05\batch05\CdProduct::getTitle

```

这种功能对于文档或日志记录来说可能很方便。

`method_exists()`函数需要一个对象(或类名)和一个方法名，如果给定的方法存在于对象的类中，则返回`true`:

```php
// listing 05.51
if (method_exists($product, $method)) {
    print $product->$method(); // invoke the method
}

```

Caution

记住，一个方法的存在并不意味着它是可调用的。`method_exists()`为`private`和`protected`方法以及`public`方法返回`true`。

### 了解属性

正如您可以查询类的方法一样，您也可以查询它的字段。`get_class_vars()`函数需要一个类名，并返回一个关联数组。返回的数组包含字段名作为其键，包含字段值作为其值。让我们对`CdProduct`对象进行测试。为了便于说明，我们向类添加了一个公共属性，`CdProduct::$coverUrl`:

```php
// listing 05.52
print_r(get_class_vars('\\popp\\ch05\\batch05\\CdProduct'));

```

仅显示公共属性:

```php
Array (
    [coverUrl] => cover url
)

```

### 了解继承

类函数也允许我们绘制继承关系。我们可以找到一个类的父类，比如用`get_parent_class()`。这个函数需要一个对象或类名，如果有超类的话，它返回超类的名称。如果不存在这样的类——也就是说，如果我们测试的类没有父类——那么函数返回`false`。

```php
// listing 05.53
print  get_parent_class('\\popp\\ch04\\batch02\\BookProduct');

```

如您所料，这会产生父类:`ShopProduct`。

我们还可以使用`is_subclass_of()`函数测试一个类是否是另一个类的后代。这需要一个子对象(或类名)和父类名。如果第二个参数是第一个参数的超类，函数返回`true`:

```php
// listing 05.54
$product = self::getBookProduct(); // acquire an object

if (is_subclass_of($product, '\\popp\\ch04\\batch02\\ShopProduct')) {
    print "BookProduct is a subclass of ShopProduct\n";
}

```

将只告诉你类继承关系。它不会告诉你一个类实现了一个接口。为此，您应该使用`instanceof`操作符。或者，您可以使用 SPL(标准 PHP 库)的一部分函数。`class_implements()`接受类名或对象引用，并返回接口名数组:

```php
// listing 05.55
if (in_array('someInterface', class_implements($product))) {
    print "BookProduct is an interface of someInterface\n";
}

```

### 方法调用

您已经遇到了一个例子，在这个例子中，我使用了一个字符串来动态调用一个方法:

```php
// listing 05.56
$product = self::getProduct();
$method = "getTitle";   // define a method name
print $product->$method(); // invoke the method

```

PHP 也提供了`call_user_func()`方法来达到同样的目的。`call_user_func()`可以调用任何种类的可调用函数(如函数名或匿名函数)。在这里，我通过传递字符串中的函数名来调用函数:

```php
$returnVal = call_user_func("myFunction");

```

为了调用一个方法，我可以传递一个数组。此的第一个元素应该是对象，第二个元素应该是要调用的方法的名称:

```php
$returnVal = call_user_func([$myObj, "methodName"]);

```

传递给`call_user_func()`的任何进一步的参数将被视为目标函数或方法的参数，并以相同的顺序传递，如下所示:

```php
// listing 05.57
$product = self::getBookProduct(); // Acquire a BookProduct object
call_user_func([$product, 'setDiscount'], 20);

```

当然，这个动态调用相当于:

```php
$product->setDiscount(20);

```

`call_user_func()`方法不会极大地改变你的生活，因为你同样可以直接用一个字符串代替方法名，就像这样:

```php
// listing 05.58
$method = "setDiscount";
$product->$method(20);

```

然而，更令人印象深刻的是相关的`call_user_func_array()`函数。就选择目标方法或功能而言，其操作方式与`call_user_func()`相同。不过，最重要的是，它接受目标方法所需的任何参数作为数组。

Note

注意——使用`call_user_func()`传递给函数或方法的参数不是通过引用传递的。

那么这为什么有用呢？有时，您会得到数组形式的参数。除非你事先知道你要处理的论点的数量，否则很难把它们传递下去。在第 4 章中，我看到了可以用来创建委托类的拦截器方法。下面是一个简单的`__call()`方法的例子:

```php
// listing 05.59
public function __call(string $method, array $args): mixed
{
    if (method_exists($this->thirdpartyShop, $method)) {
        return $this->thirdpartyShop->$method();
    }
}

```

如您所见，当客户端代码调用未定义的方法时，会调用`__call()`方法。在这个例子中，我在一个名为`$thirdpartyShop`的属性中维护一个对象。如果我在存储对象中找到一个与`$method`参数匹配的方法，我就调用它。我愉快地假设目标方法不需要任何参数，这就是我的问题的开始。当我编写`__call()`方法时，我无法判断每次调用时`$args`数组会有多大。如果我将`$args`直接传递给委托方法，我将传递一个数组参数，而不是它可能期望的单独参数。`call_user_func_array()`完美解决问题:

```php
// listing 05.60
public function __call(string $method, array $args): mixed
{
    if (method_exists($this->thirdpartyShop, $method)) {
        return call_user_func_array(
            [
                $this->thirdpartyShop,
                $method
            ],
            $args
        );
    }
}

```

## 反射 API

PHP 的反射 API 对于 PHP 就像`java.lang.reflect`包对于 Java 一样。它由用于分析属性、方法和类的内置类组成。它在某些方面类似于现有的对象函数，比如`get_class_vars()`，但是更加灵活，并且提供了更多的细节。它还被设计成能与 PHP 的面向对象特性(如访问控制、接口和抽象类)一起工作，而更老、更有限的类函数则不能。

### 入门指南

反射 API 不仅仅可以用来检查类。例如，`ReflectionFunction`类提供了关于给定函数的信息，而`ReflectionExtension`提供了关于编译到语言中的扩展的信息。表 [5-1](#Tab1) 列出了 API 中的一些类。

表 5-1。

反射 API 中的关键类

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

班级

 | 

描述

 |
| --- | --- |
| `Reflection` | 提供一个静态的`export()`方法来总结类信息 |
| `ReflectionAttribute` | 关于类、属性、常数或参数的上下文信息 |
| `ReflectionClass` | 课程信息和工具 |
| `ReflectionClassConstant` | 关于常数的信息 |
| `ReflectionException` | 错误类 |
| `ReflectionExtension` | PHP 扩展信息 |
| `ReflectionFunction` | 功能信息和工具 |
| `ReflectionGenerator` | 关于发电机的信息 |
| `ReflectionMethod` | 类方法信息和工具 |
| `ReflectionNamedType` | 关于函数或方法的返回类型的信息(联合返回类型用`ReflectionUnionType`描述) |
| `ReflectionObject` | 对象信息和工具(继承自`ReflectionClass` |
| `ReflectionParameter` | 方法参数信息 |
| `ReflectionProperty` | 类别属性信息 |
| `ReflectionType` | 关于函数或方法的返回类型的信息 |
| `ReflectionUnionType` | 联合类型声明的`ReflectionType`对象集合 |
| `ReflectionZendExtension` | PHP Zend 扩展信息 |

在它们之间，反射 API 中的类提供了对脚本中对象、函数和扩展信息的前所未有的运行时访问。

反射 API 的强大功能意味着你应该优先使用它而不是类和对象函数。你很快就会发现它作为测试类的工具是不可或缺的。例如，您可能想要生成类图或文档，或者您可能想要将对象信息保存到数据库，检查对象的访问器(getter 和 setter)方法以提取字段名。根据命名方案构建一个调用模块类中的方法的框架是反射的另一种用途。

### 是时候卷起袖子了

您已经遇到了一些用于检查类属性的函数。这些是有用的，但往往是有限的。这里有一个*能够胜任这项工作的工具。`ReflectionClass`提供揭示给定类的每个方面的信息的方法，无论它是用户定义的还是内部的。`ReflectionClass`的构造函数接受一个类或接口名(或一个对象实例)作为它唯一的参数:*

```php
// listing 05.61
$prodclass = new \ReflectionClass(CdProduct::class);
print $prodclass;

```

一旦创建了一个`ReflectionClass`对象，您就可以立即转储关于该类的各种信息，只需在字符串上下文中访问它。下面是我为`ShopProduct`打印我的`ReflectionClass`实例时生成的输出的节略摘录:

```php
Class [ <user> class popp\ch04\batch02\CdProduct extends popp\ch04\batch02\
ShopProduct ] {
  @@ /var/popp/src/ch04/batch02/CdProduct.php 6-37

  - Constants [2] {
    Constant [ public int AVAILABLE ] { 0 }
    Constant [ public int OUT_OF_STOCK ] { 1 }
}

  - Static properties [0] {
}

  - Static methods [1] {
    Method [ <user, inherits popp\ch04\batch02\ShopProduct> static public method getInstance ] {
      @@ /var/popp/src/ch04/batch02/ShopProduct.php 93 - 130

      - Parameters [2] {
        Parameter #0 [ <required> int $id ]
        Parameter #1 [ <required> PDO $pdo ]
      }
      - Return [ popp\ch04\batch02\ShopProduct ]
    }
  }

  - Properties [3] {
    Property [ private $playLength = 0 ]
    Property [ public $status = NULL ]
    Property [ protected int|float $price ]
  }
...

```

Note

实用方法`Reflection::export()`曾经是转储`ReflectionClass`信息的标准方式。这在 PHP 7.4 中被否决，在 PHP 8.0 中被完全删除

如您所见，`ReflectionClass`提供了对一个类信息的卓越访问。字符串输出提供了关于`CdProduct`几乎每个方面的概要信息，包括属性和方法的访问控制状态、每个方法所需的参数以及每个方法在脚本文档中的位置。与更成熟的调试功能相比。`var_dump()`函数是一个用于汇总数据的通用工具。在提取摘要之前，您必须实例化一个对象，即使这样，它也不能提供类似于`ReflectionClass`所提供的细节:

```php
// listing 05.62
$cd = new CdProduct("cd1", "bob", "bobbleson", 4, 50);
var_dump($cd);

```

以下是输出结果:

```php
object(popp\ch04\batch02\CdProduct)#15 (8) {
  ["playLength":"popp\ch04\batch02\CdProduct":private]=>
  int(50)
  ["status"]=>
  NULL
  ["title":"popp\ch04\batch02\ShopProduct":private]=>
  string(3) "cd1"
  ["producerMainName":"popp\ch04\batch02\ShopProduct":private]=>
  string(9) "bobbleson"
  ["producerFirstName":"popp\ch04\batch02\ShopProduct":private]=>
  string(3) "bob"
  ["price":protected]=>
  float(4)
  ["discount":"popp\ch04\batch02\ShopProduct":private]=>
  int(0)
  ["id":"popp\ch04\batch02\ShopProduct":private]=>
  int(0)
}

```

`var_dump()`和它的表亲`print_r()`是在脚本中公开数据的非常方便的工具。对于类和函数，反射 API 将事情带到了一个全新的水平。

### 检查一节课

一个`ReflectionClass`实例的原始转储可以为调试提供大量有用的信息，但是我们可以以更专业的方式使用 API。让我们直接使用`Reflection`类。

您已经看到了如何实例化一个`ReflectionClass`对象:

```php
// listing 05.63
$prodclass = new \ReflectionClass(CdProduct::class);

```

接下来，我将使用`ReflectionClass`对象来研究脚本中的`CdProduct`。是什么样的课？可以创建实例吗？这里有一个函数来回答这些问题:

```php
// listing 05.64
// class ClassInfo

public static function getData(\ReflectionClass $class): string
{
    $details = "";
    $name = $class->getName();

    $details .= ($class->isUserDefined())  ? "$name is user defined\n"     : "" ;
    $details .= ($class->isInternal())     ? "$name is built-in\n"         : "" ;
    $details .= ($class->isInterface())    ? "$name is interface\n"        : "" ;
    $details  .=  ($class->isAbstract())   ? "$name is an abstract class\n" : "" ;
    $details .= ($class->isFinal())        ? "$name is a final class\n"     : "" ;
    $details .= ($class->isInstantiable()) ? "$name can be instantiated\n"  : "$name can not be instantiated\n" ;
    $details .= ($class->isCloneable())    ? "$name can be cloned\n"        : "$name can not be cloned\n" ;
   return $details;
}

```

```php
// listing 05.65
$prodclass = new \ReflectionClass(CdProduct::class);
print ClassInfo::getData($prodclass);

```

我创建了一个`ReflectionClass`对象，通过将`CdProduct`类名传递给`ReflectionClass`的构造函数，将它赋给一个名为`$prodclass`的变量。然后将`$prodclass`传递给一个名为`ClassInfo::classData()`的方法，该方法演示了一些可用于查询类的方法。

这些方法应该是不言自明的，但下面是对其中一些方法的简要描述:

*   `ReflectionClass::getName()`返回被检查的类的名称。

*   如果该类已经在 PHP 代码中声明，则`ReflectionClass::isUserDefined()`方法返回`true`，如果该类是内置的，则`ReflectionClass::isInternal()`返回`true`。

*   你可以用`ReflectionClass::isAbstract()`测试一个类是否抽象，用`ReflectionClass::isInterface()`测试它是否是一个接口。

*   如果你想得到一个类的实例，你可以用`ReflectionClass::isInstantiable()`来测试它的可行性。

*   您可以用`ReflectionClass::isCloneable() method`来检查一个类是否是可克隆的。

*   您甚至可以检查用户定义的类的源代码。`ReflectionClass`对象提供对其类的文件名以及文件中该类的开始和结束行的访问。

这里有一个快速的方法，它使用`ReflectionClass`来访问类的源代码:

```php
// listing 05.66
class ReflectionUtil
{
    public static function getClassSource(\ReflectionClass $class): string
    {
        $path  = $class->getFileName();
        $lines = @file($path);
        $from  = $class->getStartLine();
        $to    = $class->getEndLine();
        $len   = $to - $from + 1;
        return implode(array_slice($lines, $from - 1, $len));
    }
}

```

```php
// listing 05.67
print ReflectionUtil::getClassSource(
    new \ReflectionClass(CdProduct::class)
);

```

`ReflectionUtil`是一个简单的类，只有一个静态方法`ReflectionUtil::getClassSource()`。该方法将一个`ReflectionClass`对象作为唯一的参数，并返回被引用类的源代码。`ReflectionClass::getFileName()`提供类文件的路径作为绝对路径，所以代码应该能够直接打开它。`file()`获取文件中所有行的数组。`ReflectionClass::getStartLine()`提供该类的起始行；`ReflectionClass::getEndLine()`找到最后一行。从那以后，只需使用`array_slice()`提取感兴趣的行。

为了保持简洁，这段代码省略了错误处理(通过在对`file()`的调用前放置字符`@`)。在现实世界的应用程序中，您需要检查参数和结果代码。

### 检查方法

正如`ReflectionClass`用于检查类一样，`ReflectionMethod`对象检查方法。

你可以从`ReflectionClass::getMethods()`中得到一个`ReflectionMethod`对象的数组。或者，如果您需要使用一个特定的方法，`ReflectionClass::getMethod()`接受一个方法名并返回相关的`ReflectionMethod`对象。

您也可以直接实例化`ReflectionMethod`，传递给它一个类/方法字符串、类名和方法名，或者一个对象和方法名。

这些变化看起来可能是这样的:

```php
// listing 05.68
$cd = new CdProduct("cd1", "bob", "bobbleson", 4, 50);
$classname = CdProduct::class;

$rmethod1 = new \ReflectionMethod("{$classname}:: construct");// class/method string
$rmethod2 = new \ReflectionMethod($classname, " construct");// class name and method name
$rmethod3 = new \ReflectionMethod($cd, " construct");// object and method name

```

这里，我们使用`ReflectionClass::getMethods()`来测试`ReflectionMethod`类:

```php
// listing 05.69
$prodclass = new \ReflectionClass(CdProduct::class);
$methods = $prodclass->getMethods();

foreach ($methods as $method) {
    print ClassInfo::methodData($method);
    print "\n----\n";
}

```

```php
// listing 05.70

// class ClassInfo

public static function methodData(\ReflectionMethod $method): string
{
    $details = "";
    $name = $method->getName();

    $details .= ($method->isUserDefined())    ? "$name is user defined\n"      : ""  ;
    $details .= ($method->isInternal())       ? "$name is built-in\n" : "" ;
    $details .= ($method->isAbstract())       ? "$name is an abstract class\n"      : "" ;
    $details .= ($method->isPublic())         ? "$name is public\n" : "" ;
    $details .= ($method->isProtected())      ? "$name is protected\n"      : "" ;
    $details .= ($method->isPrivate())        ? "$name is private\n" : "" ;
    $details .= ($method->isStatic())         ? "$name is static\n"  : "" ;
    $details .= ($method->isFinal())          ? "$name is final\n"   : "" ;
    $details .= ($method->isConstructor())    ? "$name is the constructor\n"      : "" ;
    $details .= ($method->returnsReference()) ? "$name returns a reference (as opposed to a value)\n"      : "" ;

    return $details;
}

```

代码使用`ReflectionClass::getMethods()`来获得一个由`ReflectionMethod`对象组成的数组，然后遍历该数组，将每个对象传递给`methodData()`。

`methodData()`中使用的方法名称反映了它们的意图:代码检查方法是用户定义的、内置的、抽象的、公共的、受保护的、静态的还是最终的。您还可以检查该方法是否是其类的构造函数，以及它是否返回引用。

有一个警告:如果被测试的方法只是返回一个对象，那么`ReflectionMethod::returnsReference()`不会返回`true`，即使在 PHP 5 中对象是通过引用传递和赋值的。相反，`ReflectionMethod::returnsReference()`仅在所讨论的方法被显式声明为返回引用时才返回 true(通过在方法名前面放置一个&字符)。

如您所料，您可以使用类似于之前使用`ReflectionClass`的技术来访问方法的源代码:

```php
// listing 05.71

// class ReflectionUtil
public static function getMethodSource(\ReflectionMethod $method): string
{
    $path  = $method->getFileName();
    $lines = @file($path);
    $from  = $method->getStartLine();
    $to    = $method->getEndLine();
    $len   = $to - $from + 1;
    return implode(array_slice($lines, $from - 1, $len));
}

```

```php
// listing 05.72
$class = new \ReflectionClass(CdProduct::class);
$method = $class->getMethod('getSummaryLine');
print ReflectionUtil::getMethodSource($method);

```

因为`ReflectionMethod`为我们提供了`getFileName()`、`getStartLine()`和`getEndLine()`方法，所以提取方法的源代码很简单。

### 检查方法参数

既然方法签名可以约束对象参数的类型，那么检查方法签名中声明的参数的能力就变得非常有用。反射 API 提供了`ReflectionParameter`类就是为了这个目的。要得到一个`ReflectionParameter`对象，你需要一个`ReflectionMethod`对象的帮助。`ReflectionMethod::getParameters()`方法返回一个`ReflectionParameter`对象的数组。

也可以用通常的方法直接实例化一个`ReflectionParameter`对象。ReflectionParameter 的构造函数需要一个`callable`参数和一个表示参数编号的整数(索引为零)或一个表示参数名称的字符串。

所以，这四个实例化是等价的。每个都为`CdProduct`类的构造函数的第二个参数建立了一个`ReflectionParameter`对象。

```php
// listing 05.73
$classname = CdProduct::class;

$rparam1 = new \ReflectionParameter([$classname, "__construct"], 1);
$rparam2 = new \ReflectionParameter([$classname, "__construct"], "firstName");

$cd = new CdProduct("cd1", "bob", "bobbleson", 4, 50);
$rparam3 = new \ReflectionParameter([$cd, "__construct"], 1);
$rparam4 = new \ReflectionParameter([$cd, "__construct"], "firstName");

```

`ReflectionParameter`可以告诉您参数的名称以及变量是否通过引用传递(即，在方法声明中前面有一个&符号)。它还可以告诉您参数提示所需的类，以及该方法是否接受参数的空值。

下面是一些`ReflectionParameter`的方法:

```php
// listing 05.74
$class = new \ReflectionClass(CdProduct::class);

$method = $class->getMethod("__construct");
$params = $method->getParameters();

foreach ($params as $param) {
    print ClassInfo::argData($param) . "\n";
}

```

```php
// listing 05.75

// class ClassInfo
public static function argData(\ReflectionParameter $arg): string
{
    $details = "";
    $declaringclass = $arg->getDeclaringClass();
    $name = $arg->getName();

    $position = $arg->getPosition();
    $details .= "\$$name has position $position\n";
    if ($arg->hasType()) {
        $type = $arg->getType();
        $typenames = [];
        if ($type instanceof \ReflectionUnionType) {
            $types = $type->getTypes();
            foreach ($types as $utype) {
                     $typenames[] = $utype->getName();
            }
        } else {
            $typenames[] = $type->getName();
        }
        $typename = implode("|",  $typenames);
        $details .= "\$$name should be type {$typename}\n";
    }

    if ($arg->isPassedByReference()) {
        $details .= "\${$name} is passed by reference\n";
    }

    if ($arg->isDefaultValueAvailable()) {
        $def = $arg->getDefaultValue();
        $details .= "\${$name} has default: $def\n";
    }
    if ($arg->allowsNull()) {
        $details .= "\${$name} can be null\n";
    }

    return $details;
}

```

使用`ReflectionClass::getMethod()`方法，代码获得一个`ReflectionMethod`对象。然后它使用`ReflectionMethod::getParameters()`来获得一个`ReflectionParameter`对象的数组。`argData()`函数使用传递给它的`ReflectionParameter`对象来获取关于参数的信息。

首先，它用`ReflectionParameter::getName()`获取参数的变量名。如果指定了类型，则`ReflectionParameter::getType()`方法返回一个`ReflectionType`对象，如果指定的类型是联合类型，则返回一个`ReflectionUnionType`类。无论从哪一个返回，都将构造一个表示所需类型的字符串。然后，代码检查参数是否是对`isPassedByReference();`的引用，最后，它查找默认值的可用性，然后将其添加到返回字符串中。

### 使用反射 API

有了反射 API 的基础知识，现在就可以让 API 工作了。

假设您正在创建一个动态调用`Module`对象的类。也就是说，它可以接受由第三方编写的插件，这些插件可以嵌入到应用程序中，而不需要任何硬编码。为了实现这一点，您可以在`Module`接口或抽象基类中定义一个`execute()`方法，强制所有子类定义一个实现。您可以允许系统用户在外部 XML 配置文件中列出`Module`类。在对每个对象调用`execute()`之前，您的系统可以使用这些信息来聚集一些`Module`对象。

然而，如果每个`Module`需要*不同的*信息来完成它的工作，会发生什么呢？在这种情况下，XML 文件可以为每个`Module`提供属性键和值，每个`Module`的创建者可以为每个属性名提供 setter 方法。有了这个基础，就要靠代码来确保为正确的属性名调用正确的 setter 方法。

这里有一些关于`Module`接口和几个实现类的基础:

```php
// listing 05.76
class Person
{
    public $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }
}

```

```php
// listing 05.77
interface Module
{
    public function execute(): void;
}

```

```php
// listing 05.78
class FtpModule implements Module
{
    public function setHost(string $host): void
    {
        print "FtpModule::setHost(): $host\n";
    }

    public function setUser(string|int $user): void
    {
        print "FtpModule::setUser(): $user\n";
    }

    public function execute(): void
    {
        // do things
    }
}

```

```php
// listing 05.79
class PersonModule implements Module
{
    public function setPerson(Person $person): void
    {
        print "PersonModule::setPerson(): {$person->name}\n";
    }

    public function execute(): void
    {
        // do things
    }
}

```

这里，`PersonModule`和`FtpModule`都提供了`execute()`方法的空实现。每个类还实现 setter 方法，这些方法除了报告它们被调用之外什么也不做。系统规定了所有 setter 方法必须有一个参数的约定:或者是一个字符串，或者是一个可以用一个字符串参数实例化的对象。`PersonModule::setPerson()`方法需要一个`Person`对象，所以我在例子中包含了一个`Person`类。

为了使用`PersonModule`和`FtpModule`，下一步是创建一个`ModuleRunner`类。它将使用由模块名索引的多维数组来表示 XML 文件中提供的配置信息。下面是代码:

```php
// listing 05.80
class ModuleRunner

{
    private array $configData = [
        PersonModule::class => ['person' => 'bob'],
        FtpModule::class    => [
            'host' => 'example.com',
            'user' => 'anon'
        ]
    ];

    private array $modules = [];

    // ...
}

```

`ModuleRunner::$configData`属性包含对两个`Module`类的引用。对于每个模块元素，代码维护一个包含一组属性的子数组。`ModuleRunner`的`init()`方法负责创建正确的`Module`对象，如下所示:

```php
// listing 05.81

// class ModuleRunner
public function init(): void
{
    $interface = new \ReflectionClass(Module::class);
    foreach ($this->configData as $modulename => $params) {
        $module_class = new \ReflectionClass($modulename);
        if (! $module_class->isSubclassOf($interface)) {
            throw new Exception("unknown module type: $modulename");
        }
        $module = $module_class->newInstance();
        foreach ($module_class->getMethods() as $method) {
            $this->handleMethod($module, $method, $params);
            // we cover handleMethod() in a future listing!
        }
        array_push($this->modules, $module);
    }
}

```

```php
// listing 05.82
$test = new ModuleRunner();
$test->init();

```

`init()`方法遍历`ModuleRunner::$configData`数组，对于每个模块元素，它试图创建一个`ReflectionClass`对象。当用一个不存在的类名调用`ReflectionClass`的构造函数时会产生一个异常，所以在现实环境中，我会在这里包含更多的错误处理。我使用`ReflectionClass::isSubclassOf()`方法来确保模块类属于`Module`类型。

在调用每个`Module`的`execute()`方法之前，必须创建一个实例。这就是`ReflectionClass::newInstance()`的目的。该方法接受任意数量的参数，并将其传递给相关类的构造函数方法。如果一切正常，它将返回该类的一个实例(对于生产代码，一定要谨慎编码:在创建实例之前，检查每个`Module`对象的构造函数方法是否不需要参数)。

`ReflectionClass::getMethods()`返回该类可用的所有`ReflectionMethod`对象的数组。对于数组中的每个元素，代码都会调用`ModuleRunner::handleMethod()`方法。然后传递给它一个`Module`实例、`ReflectionMethod`对象和一个与`Module`关联的属性数组。`handleMethod()`验证并调用`Module`对象的 setter 方法:

```php
// listing 05.83

// class ModuleRunner
public function handleMethod(Module $module, \ReflectionMethod $method, array $params):
bool
{
    $name = $method->getName();
    $args = $method->getParameters();

    if (count($args) != 1 || substr($name, 0, 3) != "set") {
        return  false;
    }

    $property = strtolower(substr($name, 3));

    if (! isset($params[$property])) {
        return false;
    }

    if (! $args[0]->hasType()) {
        $method->invoke($module, $params[$property]);
        return true;
    }

    $arg_type = $args[0]->getType();

    if (! ($arg_type instanceof \ReflectionUnionType) && class_exists($arg_type->getName())) {
        $method->invoke(
            $module,
            (new \ReflectionClass($arg_type->getName()))->newInstance($params[$property])
        );
    } else {
        $method->invoke($module, $params[$property]);
    }
    return true;
}

```

`handleMethod()`首先检查该方法是否是有效的 setter。在代码中，一个有效的 setter 方法必须被命名为`setXXXX()`，并且必须声明一个——并且只能声明一个——参数。

假设参数检查通过，然后代码从方法名中提取一个属性名，方法是从方法名的开头删除`set`，并将结果子串转换成小写字符。该字符串用于测试`$params`数组参数。该数组包含用户提供的属性，这些属性将与`Module`对象相关联。如果`$params`数组不包含属性，代码放弃并返回`false`。

如果从模块方法中提取的属性名与`$params`数组中的一个元素匹配，我可以继续调用正确的 setter 方法。为此，代码必须检查 setter 方法的第一个(也是唯一一个)必需参数的类型。如果参数有一个类型声明(`ReflectionParameter::hasType()`)，并且指定的类型解析为一个类，那么我们知道该方法需要一个对象。否则，我们假设它需要一个原语。

为了调用 setter 方法，我需要新的反射 API 方法。`ReflectionMethod::invoke()`需要一个对象(或静态方法的`null`)和任意数量的方法参数来传递给它所代表的方法。`ReflectionMethod::invoke()`如果提供的对象与其方法不匹配，抛出异常。我以两种方式之一调用这个方法。如果 setter 方法不需要对象参数，我用用户提供的属性字符串调用`ReflectionMethod::invoke()`。如果这个方法需要一个对象(我可以通过使用类型名的`class_exists`来测试)，我使用属性字符串来实例化一个正确类型的对象。然后将它传递给 setter。

该示例假定所需的对象可以用其构造函数的单个字符串参数进行实例化。当然，最好在调用`ReflectionClass::newInstance()`之前检查一下这个。

当`ModuleRunner::init()`方法完成它的过程时，对象已经有了一个`Module`对象的存储库，所有的都以数据为基础。现在可以给这个类一个方法来遍历`Module`对象，对每个对象调用`execute()`。

## 属性

许多语言都提供了一种机制，通过这种机制，代码可以使用源文件中的特殊标记。这些通常被称为*注释*。尽管在 PHP 8 之前，PHP 包中已经有了一些 userland 实现(特别是，例如，Doctrine 数据库库和 Symfony 路由组件),但是在语言层面上还没有对这个特性的支持。随着*属性*的引入，这种情况有所改变。

本质上，属性是一个特殊的标记，它允许您向类、方法、属性、参数或常数添加附加信息。通过反射，系统可以获得这些信息。

那么你能用注释做什么呢？通常，一个方法可能会提供更多关于其预期使用方式的信息。例如，客户端代码可能会扫描一个类来发现应该自动运行的方法。随着我们的进展，我将提到其他用例。

让我们声明并访问一个注释:

```php
// listing 05.84
namespace popp\ch05\batch09;

#[info]
class Person
{
}

```

因此，用一个由`#[`和`]`包围的字符串标记来声明一个注释。在这种情况下，我选择了`#[info]`。在许多代码示例中，我排除了名称空间声明，因为代码在声明的名称空间或`main`中同样运行良好。不过，在这种情况下，值得注意的是名称空间。我将回到这一点。

现在要访问注释:

```php
// listing 05.85
$rpers = new \ReflectionClass(Person::class);
$attrs = $rpers->getAttributes();
foreach ($attrs as $attr) {
    print $attr->getName() . "\n";
}

```

我实例化了一个`ReflectionClass`对象，这样我就可以检查`Person`。然后我调用了`getAttributes()`方法。这将返回一个由`ReflectionAttribute`对象组成的数组。`ReflectionAttribute::getName()`返回我声明的属性的名称。

以下是输出:

```php
popp\ch05\batch09\info

```

因此，在我的输出中，注释是命名空间的。名称的`popp\ch05\batch09`部分是隐含的。我可以根据引用类的规则和别名来引用注释。因此在`popp\ch05\batch09`名称空间中声明`[#info]`等同于在其他地方声明`[#\popp\ch05\batch09\info]`。事实上，正如您将看到的，您甚至可以声明一个可以为您引用的任何属性实例化的类。

注释可以应用于 PHP 的各个方面。表 [5-2](#Tab2) 列出了可以注释的特性以及相应的反射类。

表 5-2。

适合注释的 PHP 特性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

特征

 | 

获得物ˌ获得

 |
| --- | --- |
| 班级 | `ReflectionClass::getAttributes()` |
| 财产 | `ReflectionProperty::getAttributes()` |
| 功能/方法 | `ReflectionFunction::getAttributes()` |
| 常数 | `ReflectionConstant::getAttributes()` |

下面是一个应用于方法的属性示例:

```php
// listing 05.86
#[moreinfo]
public function setName(string $name): void
{
    $this->name = $name;
}

```

现在访问它。您应该会发现这个过程非常熟悉:

```php
// listing 05.87
$rpers = new \ReflectionClass(Person::class);
$rmeth = $rpers->getMethod("setName");
$attrs = $rmeth->getAttributes();
foreach ($attrs as $attr) {
    print $attr->getName() . "\n";
}

```

输出现在应该也很熟悉了。我们显示了到`moreinfo`的完全命名空间路径。

```php
popp\ch05\batch09\moreinfo

```

到目前为止，您已经看到了一些有用的东西。我们可以包含一个属性作为某种标志。例如，`Debug`属性可以与只在开发过程中调用的方法相关联。然而，属性还有更多。我们可以定义一个类型，并通过参数提供进一步的信息。这开启了新的可能性。在路由库中，我可能会断言一个方法应该映射到的 URL 端点。在事件系统中，属性可能表示一个类或方法应该与一个特定的事件相关联。

在这个例子中，我定义了一个包含两个参数的属性:

```php
// listing 05.88
#[ApiInfo("The 3 digit company identifier", "A five character department tag")]
public function setInfo(int $companyid, string $department): void
{
    $this->companyid = $companyid;
    $this->department = $department;
}

```

一旦我获得了一个`ReflectionAttribute`对象，我就可以使用`getArguments()`方法访问参数。

```php
// listing 05.89
$rpers = new \ReflectionClass(Person::class);
$rmeth = $rpers->getMethod("setInfo");
$attrs = $rmeth->getAttributes();
foreach ($attrs as $attr) {
    print $attr->getName() . "\n";
    foreach ($attr->getArguments() as $arg) {
        print "  - $arg\n";
    }
}

```

以下是输出:

```php
popp\ch05\batch09\ApiInfo
  - The 3 digit company identifier
  - A five character department tag

```

正如我提到的，您可以显式地将一个属性映射到一个类。下面是一个简单的`ApiInfo`类:

```php
// listing 05.90
namespace popp\ch05\batch09;

use Attribute;
#[Attribute]

class ApiInfo
{
    public function __construct(public string $compinfo, public string $depinfo)
    {
    }
}

```

为了正确地在属性和我的类之间建立关联，我必须记住`use Attribute`并将内置的`[#Attribute]`应用于类。

在实例化时，关联属性的任何参数都会自动传递给相应类的构造函数。在这种情况下，我只是将数据分配给相应的属性。在现实世界的应用程序中，我可能会执行一些额外的处理或提供相关的功能来证明类的声明是正确的。

理解属性类不会自动调用是很重要的。我们必须通过`ReflectionAttribute::newInstance()`做到这一点。在这里，我修改了我的客户机代码，使之适用于新的类:

```php
// listing 05.91
$rpers = new \ReflectionClass(Person::class);
$rmeth = $rpers->getMethod("setInfo");
$attrs = $rmeth->getAttributes();
foreach ($attrs  as  $attr)  {
    print $attr->getName() . "\n";
    $attrobj = $attr->newInstance();
    print "  - " . $attrobj->compinfo . "\n";
    print "  - " . $attrobj->depinfo . "\n";
}

```

虽然我是通过`ApiInfo`对象访问属性数据，但是这里的效果是一样的。我调用`ReflectionAttribute::newInstance()`，然后访问填充的属性。

等等，虽然！最后一个例子有一个深刻的、潜在的致命缺陷。一个方法可以添加多个属性。因此，我们不能确定分配给`setInfo()`方法的每个属性都是`ApiInfo`的实例。那些对`ApiInfo::$compinfo`和`ApiInfo::$depinfo`的属性访问对于任何不属于`ApiInfo`类型的属性必定会失败。

幸运的是，我们可以对`getAttributes()`应用过滤器:

```php
// listing 05.92
$rpers = new \ReflectionClass(Person::class);
$rmeth = $rpers->getMethod("setInfo");
$attrs = $rmeth->getAttributes(ApiInfo::class);

```

现在，将只返回与`ApiInfo::class`完全匹配的内容——使得代码的其余部分变得安全。我们可以像这样进一步放松一下:

```php
// listing 05.93
$rpers = new \ReflectionClass(Person::class);
$rmeth = $rpers->getMethod("setInfo");
$attrs = $rmeth->getAttributes(ApiInfo::class, \ReflectionAttribute::IS_INSTANCEOF);

```

通过将第二个参数`ReflectionAttribute::IS_INSTANCEOF`传递给`ReflectionAttribute::getAttributes()`，我放松了过滤器以匹配指定的类以及任何扩展或实现的子类或接口。

表 [5-3](#Tab3) 列出了我们遇到的 ReflectionAttribute 的方法。

表 5-3。

一些反射属性方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

描述

 |
| --- | --- |
| `getName()` | 返回属性的完整命名空间类型 |
| `getArguments()` | 返回与被引用属性相关联的所有参数的数组 |
| `newInstance()` | 实例化并返回属性类的实例，将任何参数传递给构造函数 |

Note

在第 9 章中，我通过一个更加复杂的属性用法的例子来工作。

## 摘要

在这一章中，我介绍了一些你可以用来管理你的库和类的技术和工具。我研究了 PHP 的名称空间特性。您已经看到，我们可以将包含路径、名称空间、自动加载和文件系统结合起来，为类提供灵活的组织。

我们还研究了 PHP 的对象和类函数，然后用强大的反射 API 将事情推进到下一个级别。我们使用`Reflection`类构建了一个简单的例子，展示了`Reflection`必须提供的一个潜在用途。最后，我们将`Reflection`类与属性结合起来:这是 PHP 8 的一个主要新特性。