# 6.构建索赔处理系统

本书中有两个核心概念，它们是使用 Laravel 作为主干框架成功设计和实现模型驱动、架构良好的 web 应用程序的关键。这本书的结构有时可能看起来有点奇怪，但我试图在您需要的所有先决知识与您将使用这些知识创建的实际实现之间取得平衡，同时兼顾这两个重要主题。坦率地说，有很多东西需要学习，这取决于你开始阅读这本书时的专业水平。我深入研究了 DDD 中涉及的各种概念以及与 Laravel 相关的潜在对应代码，我认为在您的实际应用中实现这些想法和概念时，这种方式对您最为有益。我将通过为您提供这些概念将成为良好用例的情况，让您对这些概念有一个坚实的理解，这样您就可以使用 Laravel 框架作为实现领域驱动设计的一种方式来尝试自己的实现，无论是在您自己的项目中还是在您公司的项目中。以下是选择 DDD 中涉及的各种模式的良好用例，以便我们可以充分探索它们为我们的开发工作带来的价值:

*   掌握每个模式的核心用途，以及使用每个模式的利弊(无论该模式是来自 DDD 的技术、灵活性还是战略支柱)

*   帮助解决你在野外可能会遇到的问题(我也遇到过)

*   让您对应用程序的内部工作原理有一个清晰的认识，并帮助您使用 DDD 模式定义应用程序的高级结构，以细化各种领域层组件的特性

*   当使用 DDD 的技术模式作为实现核心组件的一种方式来构建核心组件时，要考虑架构问题，同时也要记住，它们只是简单的可能性，而不是具体的解决方案

此外，请记住，在没有适当考虑其对系统其余部分的潜在影响的情况下，不应该放弃任何想法，这是基于用业务中无处不在的语言描述的核心业务规则。几乎总是有不止一种方法来做某事，这些潜在的解决方案通常不会在没有几个小时的讨论、计划、原型、意识到你在这个过程中搞砸了一些事情，然后在你获得了对该领域更细粒度部分的额外洞察力之后纠正错误的情况下出现。这是一个不小的壮举，并且将(大部分时间)需要大量的先决学习、提问、记录和重构，以真正获得对领域模型的有价值的洞察力。

也就是说，可能有(而且很可能是)比我在书中概述的方法更好的方法，我向你发出挑战，让你成为提出这种方法的人。我用在 DDD 发现的信息、最佳实践和技术模式的知识武装你，你可以在你的工作项目或你自己的项目中使用它们来创建一个结构良好的应用程序，它具有一个丰富的模型，充分地捕获业务所表达的逻辑和规则，以做它所做的来赚钱。我发现的最好的方法是给你一些好的例子，以及用来得出潜在解决方案的思考过程——所有这些都清晰地展示出来，这样你就可以看到我为达到最终目标所采取的步骤。如果您能够理解技术考虑(DDD 结构的一个支柱)并使用模型和架构设计技术(DDD 的另一个支柱)作为使用这些技术模式的手段，那么您可以使用这些模式作为您的工具来构建新的需求或特性(第三个支柱)，这是用于在 DDD 中表达领域模型的技术方面和结构。

也就是说，这一章像胶水一样把我建议用来构建 web 应用软件的两个中心概念粘在一起(提示:它们在这本书的标题里)。我将向你介绍一些我自己有幸解决的现实生活中的问题。我们将扩展我在前一章给你的医疗索赔例子，讨论我们将使用 DDD 构建块设计的各种主题(即，那些与领域驱动设计的技术模式相关的主题)，我们将使用 Laravel 实现构建块模式作为实现的手段。我们将以 API 优先、测试驱动的方式来全面建立核心业务对象和在这些对象上运行的流程，并且我们将小心遵循我们所知的最佳实践和标准来编写任何高质量、可维护的代码。

我们将把 DDD 的教导作为一种将质量融入软件的手段。具体来说，我们将重点关注以下内容:

*   开发一个干净的、语言无关的 API，它将清楚地描述我们正在构建的系统的一部分，给企业一个有用的领域模型

*   为涉及的业务术语、操作和领域对象开发一个精炼的、良好的定义(无处不在的语言)

*   简要定义 DDD 的核心概念(工具)
    *   仓库

    *   服务

    *   域事件

    *   总计

*   描述什么是有界上下文，以及如何使用它们在我们的业务逻辑中划分域和子域，然后利用这些上下文创建一个上下文图，最终创建一组模型，作为我们的应用程序的域和名称空间结构的主干

*   请记住，我们可以使用敏捷方法、迭代开发、持续建模和持续集成等过程来构建高质量的企业级 web 应用程序，这些应用程序易于测试、具有内聚性和松散耦合性，并且能够准确、完整地代表构建应用程序的领域

*   重构代码，使之与业务领域模型更加一致，这对于创建可维护的软件非常重要，这些软件可以扩展以解决未来新功能需求带来的问题

那我们开始吧！

## 医疗索赔提交

我们将在前一章的基础上扩展我们的医疗索赔讨论，并更深入地讨论我们将在本章其余部分使用的所需背景信息。

我们公司是怎么赚钱的？通常，医疗计费系统中涉及的索赔提交过程往往很困难，因为它涉及多个步骤和一个精确的检查和平衡系统，政府必须遵守这些步骤和系统才能为服务提供者开出支票。我们公司开发了一个应用程序，有助于缓解手动提交索赔过程中的棘手问题。但是，要做到这一点，应用程序必须跟踪和执行各种州管理任务，以验证索赔 100%准确，并准备好提交给联邦合格健康中心(FQHC)。

我们将通过建立索赔的不同状态来实现这一点，它还会跟踪通过我们系统的每个索赔。例如，必须对索赔进行审查，以确保其准确性，这样 FQHC 就不会以`CORRECTION_NEEDED`状态拒绝索赔，从而延迟对提供商的付款。

基本上，可以将我们公司提供的服务看作是索赔的交换所，这样索赔在第一次提交给 FQHC 时就会被接受，提供商也会得到报酬。这一点之所以重要，是因为当提供商直接向 FQHC 提交索赔时，会发生大量的退回索赔(和延迟付款)。接待员在选择对每个病人进行的程序时会犯太多的错误；这就是所谓的*痛点*。

我们的公司在市场上找到了一个利基市场，并用一个漂亮的新应用程序填充了这个市场，该应用程序使提供商(医生)的办公室能够使用我们根据联邦索赔审查流程设计的工具和流程提交整个索赔。该流程验证所有必需的数据是否存在，并将索赔排队等待审查。审查团队在审查过程中负责核实索赔，确保所有患者数据、医疗状况、接受护理的描述、代表对患者进行的各种程序的 CPT 代码以及大量其他医生/保险提供商信息都在手边，并且在将索赔标记为“审查者批准”之前都是 100%正确的

此时，索赔已准备好提交给 FQHC 进行计费，以验证金额，然后处理付款并向提供商开出支票。我们拦截支票，拿走我们的收入，然后在扣除费用和开支后，把剩余的钱付给供应商。然而，为了让联邦实体批准对提供者的支出补偿，必须保证索赔是正确的。索赔是分批提交和支付的，每批大约有 100 至 1000 份单独的索赔。

与我们新的索赔提交系统相比，通过纸质表格、传真机和影印文件提交索赔的“传统方式”大约需要五到十倍的时间。这个过程过去是 100%手工完成的，当时没有计算机检查来确保索赔表上的数据在实际提交给联邦政府之前是有效的。没有任何措施来确保程序代码组合(又称 CPT 代码组合)代表提供者为患者完成的实际付费工作。官方报销申请提交流程还有许多其他(相当严格的)要求，如果不满足这些要求，将强制要求将报销申请退回给提供商，要求他们在尝试再次提交报销申请之前进行必要的更正。

### 医疗程序代码

索赔根据预先确定的成本结构进行支付，该成本结构基于一种叫做*工资代码表*的东西。FQHC 确定向提供商支付多少费用的方式取决于提供商注册时的成本结构类型。这两种结构如下:

*   *每次就诊付费*:这种成本结构规定，无论患者接受了何种常规、服务或程序，提供者每次从享有医疗福利的注册患者处接受就诊时，都要为其服务支付预定的固定金额。他们每次就诊都获得相同的固定金额。金额由提供商和 FQHC 商定，但我们公司实际上向提供商签发支票。通常，每次访问的付费金额从 100 美元到 150 美元不等。请注意，虽然他们不确定支付给提供者的金额，但每次就诊付费计划仍然要求使用程序代码(也称为 CPT 代码)跟踪每个相关程序。

*   *按程序付费*:这就是事情变得复杂的地方。处于按程序付费结构下的医生根据他们为患者提供的程序获得报酬。通过分析一组给定的单个程序(称为 CTP 代码)来确定数量。每个 CPT 代码代表一个在病人身上完成的医疗程序(x 光检查，使用石膏来修复断臂等)。).确定索赔金额的方法是分析列出的各组 CPT 代码，并在一个名为 paycode sheet 的东西中查找 CPT 代码组合。

### CPT 代码组

让事情变得更加复杂的是，FQHC 根据这些 CPT 代码组确定付款，称为 *CPT 代码组合*。这里的大问题是，这些组合非常具体，其中大多数都有包含在索赔中的要求。一些 CPT 组合组可能包含多个相同的 CPT 代码，或者可能具有一个 CPT 代码，该代码要求只有在另一个特定的 CPT 代码存在于同一组中时才被视为有效。

还存在其他要求。每个 CPT 代码组合对应于一个或多个 CPT 代码，这些代码可能具有先决条件要求，可能仅包含在另一组 CPT 代码中，或者可能用于特定的步骤序列中，每个步骤又具有自己的 CPT 特定要求。医生可能对患者执行的所有可用程序都被建模为一系列 CPT 代码组合。这就是 FQHC 如何确定这些程序的确切支付金额。所有可能的组合及其预定的费用金额(支付给提供商)都存储在特定的支付代码表中。

工资代码表跟踪所有这些 CPT 组合，这些组合代表在每个患者身上完成的各种程序，并以不可读的预设格式建模和表达。这要求提供者的办公室手动查找他们想要使用的每个 CPT 代码，然后确保他们与索赔一起提交的 CPT 组合与特定 paycode 表中的有效条目相对应。

例如，以下是一个(伪造的)CPT 代码列表，这些代码对应于因呼吸问题接受治疗的患者:

*   胸部 x 光检查完成(代码 3892)

*   已订购血液工作(代码 3332)

*   通过喷雾器向患者施用硫酸沙丁胺醇(代码 4523)

这三个代码都出现在一个索赔中，因为它们都发生在同一次访问中。FQHC 有一项严格的政策，规定任何患者每天只能就诊一次，因此在某一天为该患者进行的每项手术都必须包括在相应的报销申请中，他们不会接受每位患者每天超过一次的报销申请。

这些代码可以在给定的支付代码表中找到，该支付代码表包含提供者从治疗患者中获得的指定金额。表 [6-1](#Tab1) 显示了支付代码表中的示例记录，该记录规定了支付给具有前三个 CPT 代码的索赔的金额。

表 6-1

对应于一组 CPT 代码的薪资代码表中的记录

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

CPT 代码 id

 | 

CPT 代码

 | 

数量

 |
| --- | --- | --- |
| 3; 38; 420; | 3392, 3332, 4523 | $150 |

作为系统提供者(应用程序的主要用户和我们销售团队关注的中心客户)的一项功能，应用程序应该以某种方式保存支付代码表数据以及在内部关系数据库中与索赔一起提交的数据，解析出提交的索赔的代码组合，在相关的支付代码表中查找该组合，并将索赔的估计金额附加到索赔的元数据中。

图 [6-1](#Fig1) 分解 CPT 编码系统。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig1_HTML.jpg](img/488324_1_En_6_Chapter/488324_1_En_6_Fig1_HTML.jpg)

图 6-1

医疗索赔提交流程中涉及的工作流程

在图 [6-1](#Fig1) 中，我们从左上角开始，提供者(或提供者办公室或诊所的接待员)登录到我们的应用程序，并转到创建新索赔页面。在这个页面上有各种表格输入，用于成功处理索赔所需的各种信息。完成并提交表单需要以下数据:

*   服务日期(DOS)，即在患者身上完成手术的日期

*   相关的医生日志/患者治疗史，称为*进展记录*

*   在患者身上完成的程序，通过 CPT 代码组合进行跟踪，根据与给定支付代码表中定义的 CPT 代码组合相对应的金额，CPT 代码组合必须有效

*   提供商信息
    1.  NPI 号(国家提供商识别号)

    2.  提供商的名称、位置、执照/医学学位

    3.  提供者从事的相关业务

*   基本患者信息
    1.  名，中间名，姓

    2.  出生日期，性别

    3.  头发颜色，眼睛颜色，体重

    4.  社会保险号

    5.  当前街道地址

    6.  紧急联系人

*   病人的文件必须存档。这包括以下内容:
    1.  患者身份证或身份证复印件

    2.  患者医疗福利卡的复印件

    3.  接受护理的合同副本(或电子存储)

此外，当用户提交索赔时，会出现许多自动验证任务，包括检查索赔是否符合所有以前的要求，验证 DOS 是否在去年内，以及通过查找提供商办公室提供的上传文档来验证患者资格。

在没有人工参与的情况下，应用程序尽可能地验证了索赔的所有数据后，索赔被物理地提交给系统，并以状态`PENDING_REVIEW`保存。一旦索赔被正式提交，在后端，我们有几个额外的流程在它到达审查员之前运行。首先，我们希望自动化患者资格要求，以便应用程序实际上可以在线访问 Medi-Cal 页面，通过操作 DOM 提交患者信息，抓取返回的响应，然后将该响应附加到索赔中。我们将在本章的后面处理这个问题。

提交时运行的另一个任务是验证索赔中的患者实际上已在该提供者处注册。如果注册没有完成，应用程序应该不允许用户继续进行声明，并返回到更正声明。索赔上的提供者链接到一个支付代码表，该表确定每个程序代码分组将向提供者支付多少。在审查索赔之前，需要做的最后一件事是估计索赔的金额。这是通过在工资代码表中查找 CPT 组合并在索赔中附上“估计金额”来完成的。如果无法从薪资代码表中解析出金额，则表明该薪资代码表中不存在 CPT 代码组合，必须在将索赔发送到 FQHC 之前添加该组合。

在自动化流程全部运行之后，索赔在发出之前会提交给审查小组进行审查。审查者再次检查索赔上的所有文档，并手动验证索赔上提交的所有内容(以及应用程序创建并附加到索赔的字段)；审查者要么批准它，要么认为它需要更正，在这种情况下，索赔被发送回提供者进行更正(索赔状态表明这一点:`CORRECTION_NEEDED`)。在评论页面上还有一个注释部分，评论者可以用来输入关于索赔的具体注释或评论，这些注释附在索赔上；然后，提交索赔的提供者会收到一个通知，告知索赔需要关注。他们可以更正并再次发送，重新开始这个过程。

如果索赔准备就绪，审查者将其标记为`REVIEWER_APPROVED`，并将索赔发送到 FQHC 进行计费审查。在 FQHC 工作的计费用户调出与索赔相关联的数据，并根据估计金额进行最终检查，确保该金额对应于该提供商各自的支付代码表中列出的有效 CPT 组合。完成后，记账人将索赔标记为`BILLER_APPROVED`，三周后，我们公司将代表提供商收到一份薪水支票。然后我们把钱分发给他们。否则，记账方将该索赔标记为`BILLER_CORRECTION_NEEDED`，然后再次将其发送回提供方进行更正(此时提交流程重新开始)。总的来说，这个过程非常简单，但是有很多验证和确认进入索赔，以确保它将被接受和支付。

## 我们在建造什么？

现在您已经对索赔提交流程有了一些了解，我们可以开始合理化我们希望如何实现这个例子的特性。然而，首先，界定我们在建设什么是至关重要的。我将带您在这个应用程序中设置项目的上下文图并定义有界的上下文。

请记住，该应用程序被视为“企业应用程序”，因为它管理多种用户类型，提供身份验证和授权管理，并且存在于各种环境中。在我们根据边界、域、上下文和子域(我们稍后会谈到所有这些)设计出应用程序后，我们将重点设计和实现系统的几个不同方面，具体如下:

*   索赔提交流程，包括所有必需的检查和平衡以及状态代码更改。

*   角色系统，定义系统中各种用户类型的角色，以及在执行系统任务(即授权)时它们各自的检查。

*   根据输入的 CPT 代码组合及其在给定提供商的薪资代码表中的相应行确定索赔金额的过程。

*   刮除器将刮除 Medi-Cal 部位并返回检查结果的图像，以确定患者是否有资格获得福利。该流程在索赔创建时自动运行。

*   验证索赔的所有数据点并核实其准确性，以及提交索赔所需的文件。

### 识别域、子域和有界上下文

那么，我们从哪里开始？我们识别系统需求中涉及的域、子域和有界上下文；然后我们开始构建我们天真的原型；最后，我们提炼概念，直到我们有一个有效的、工作的领域模型。

表 [6-2](#Tab2) 更好地代表了上一节中的列表，同时也指定了未知项(当我们检查它们时，您可以回来填充空白)。

表 6-2

索赔示例要求

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
| 

要求

 | 

描述

 | 

领域

 | 

子整环

 | 

公元前

 |
| --- | --- | --- | --- | --- |
| 提交索赔 | 索赔提交流程模型 | 提交索赔 | - | - |
| 索赔核实 | 核实提交的索赔 | 提交索赔 | - | - |
| 索赔估计 | 确定索赔的预期金额 | 提交索赔 | - | - |
| 资格刮刀 | 用于 Medi-Cal 患者资格验证的刮刀 | 提交索赔 | - | - |
| 角色系统 | 基于每个用户的用户授权 | 作家（author 的简写） | - | - |

在表 [6-1](#Tab1) 中，我已经简单地包含了上述列表的需求，并给出了它们的核心领域。以下是 Eric Evan 对核心领域的评论，摘自他的书，*《领域驱动设计参考》*(狗耳出版社，2014):

> *《把模型简化。定义一个核心领域，并提供一种方法来轻松地将其与大量支持模型和代码区分开来。突出最有价值和最专业的概念。把核心做小。”*
> 
> —埃里克·埃文斯

基于我们对核心域应该是什么的理解，我似乎在表 [6-1](#Tab1) 中把域说得太宽泛了。Evans 指出，核心域应该很小，并且应该很容易与支持或促进核心域中的模型的其他模型区分开来。最初，我只为每个主请求包含了两个核心域:CLAIM SUBMIT 和 AUTH。如果我们再仔细考虑一下，我们会发现提交索赔的过程应该不同于验证索赔的过程。然而，这两个概念是密切相关的(也就是说，如果一开始就没有索赔提交，就根本无法进行索赔验证)。我们甚至可以得出这样的结论:索赔确认是索赔提交过程整体的一部分。我们需要能够以这样一种方式分割领域，即应用程序的结构由更小的部分编织在一起，每个部分都可能有自己的上下文、无处不在的语言，甚至是负责维护和发布周期的独立团队。

DDD 提供了一些有价值的工具，给你一些在核心域、子域和有界上下文之间画边界的想法。一般来说，系统中每一个有界上下文通常有一个子域，多个子域/有界上下文共同生活在同一个核心域中。一旦这样做了，我们就开始了解封装了系统的各种关注点的模块是如何工作的，并且可以看到不同领域协同工作以在系统内实现一个单一的、明确定义的目标的完整视角。

有了这些知识，让我们重温一下表 [6-1](#Tab1) 。起初，我们可能认为索赔提交应用程序的概念应该有不同的核心域，例如，一个处理提交过程本身，另一个验证提交的索赔。在意识到它们是不同的关注点，但是彼此又如此相关，以至于一个(即索赔验证)离不开另一个(即索赔提交)之后，我们得出结论，这两个应该在同一个核心域中是有意义的。

现在，让我们回顾一下索赔评估需求。索赔的估计金额是一个计算值，它依赖于一个流程，该流程确定每个索赔的特定 CPT 组合，并在给定的支付代码表中为该组合确定一个金额。对我来说，这意味着评估索赔的过程不能在没有 CPT 组合和`provider_id`的情况下发生，而这两件事只是在索赔的意义和上下文中一起发生。然而，当从高层次上看这件事时，我想到的一个细节是，索赔评估发生在成功提交索赔之后。我们应该将它建模为一个不同的核心领域吗？我不这么认为，原因如下:提交索赔并验证索赔是否准确以及是否包含所有必需的数据和文档的行为发生在提交过程的同时，但它实际上发生在索赔被视为“已提交”之前

只有在这种情况发生后，才能计算出索赔支出的估计金额。总的来说，这些事实让我(我希望你也是)认识到它们是同一个整体过程的不同背景。索赔提交由提供商完成，我们的应用程序会在正式“提交”之前自动验证其准确性，然后根据与 CPT 代码组合和支付代码表相关的不同流程将估计金额附加到索赔中。现在，我们将估计索赔金额逻辑建模为同一个核心域 CLAIM SUBMIT 中的另一个有界上下文。此列表中与索赔本身相关的唯一其他项目是通过抓取 Medi-Cal 资格页面并向其提供患者信息(包括其 Medi-Cal 编号)以及提供护理的提供者来验证患者资格并获取结果的流程。在技术上“提交”索赔后，也会触发此流程尽管如此，我们有许多不同的方法可以选择来拆分应用程序。

1.  我们可以让它保持原样(也就是说，让两个核心域声明 SUBMIT 和 AUTH ),只给每个域中的元素分配不同的子域。

2.  We could make the core domains a little more granular, which may look something like Figure [6-2](#Fig2).

    ![img/488324_1_En_6_Chapter/488324_1_En_6_Fig2_HTML.png](img/488324_1_En_6_Chapter/488324_1_En_6_Fig2_HTML.png)

    图 6-2

    对构成我们应用程序核心领域的概念的初步深入研究

3.  We can choose to create each core domain in light of the various models existing within the system. In this regard, the AUTH bounded context would basically be absorbed by the surrounding contexts (Figure [6-3](#Fig3)).

    ![img/488324_1_En_6_Chapter/488324_1_En_6_Fig3_HTML.png](img/488324_1_En_6_Chapter/488324_1_En_6_Fig3_HTML.png)

    图 6-3

    按用户类型细分的概念

    以这种方式分离应用程序的主要缺点是，我们现在必须将缺失的 AUTH 上下文作为一个独立的、不统一的概念来处理，它在不同的用户类型中有不同的实现。基本上，这样做不是最好的，因为我们会将授权关注点的单独实现混合到定义它们的每个特定用户类型中，导致公然违反关注点分离和 DRY 原则(代表“不要重复自己”)，因为我们必须定义每个特定用户在每个上下文中可以做什么，如果我们有一个 AUTH 服务或类似东西的单一实现，这并不是很糟糕，但这里不是这样。不理想。让我们找到一个更好的结构，它更有意义，更容易适应领域模型。

4.  We can combine the idea presented in option 1 of this list with that in option 2 and have the core domains separated by the two primary concerns living within the core domain that revolves around a claim, while making the variations between each concern explicit and obvious by specifying the subdomains each of them target and then creating a bounded context for each one of these subdomains. Figure [6-4](#Fig4) shows what that might look like.

    ![img/488324_1_En_6_Chapter/488324_1_En_6_Fig4_HTML.png](img/488324_1_En_6_Chapter/488324_1_En_6_Fig4_HTML.png)

    图 6-4

    将概念分成三个中心力量(如果你愿意的话),它们在领域模型的核心工作

5.  We could also split up the domain in terms of the central model existing in our feature requirements: the claim. In this case, the claim would be the center of attention, and different contexts can be created in regard to its association to a claim, particularly the contexts that a claim is in initially and after it’s submitted (Figure [6-5](#Fig5)).

    ![img/488324_1_En_6_Chapter/488324_1_En_6_Fig5_HTML.png](img/488324_1_En_6_Chapter/488324_1_En_6_Fig5_HTML.png)

    图 6-5

    根据系统中的中心实体存在的域:声明

    Note

    关于前面的可能性列表中的选项 5，AUTH 域有两个相似的探测上下文，但是有一个重要的区别。*认证*是一个与确保用户是他们所声称的那个人有关的概念，如果是的话，就进行认证。*另一方面，授权*直接处理验证被认证的用户是否被允许做某事，通常基于用户在系统中的角色(这属于权限范畴)。

除了选项 3 之外，最有可能为前面列表中的所有项目创建一个有效的用例。根据 Eric Evans 的说法，我们应该寻找将核心域从支持核心域的域中分离出来的方法。在我们的例子中，对于这个例子，核心域是索赔本身，围绕索赔的各种关注点，即验证、资格审查、用户授权检查，以及索赔提交过程中发生的任何其他操作。当面临一个将影响应用程序中定义的结构和模块的重要决策时，很难决定实现最佳结果的最佳方案。在这种情况下，我通常会求助于我认为正确的东西，比如 DDD 哲学中的定义和抽象。对于这个场景，我想到的是 Evan 对抽象核心的定义，如下所示:

> *即使是核心领域模型通常也有如此多的细节，以至于很难传达全局...因此:确定模型中最基本的不同概念，并将它们分解到不同的类、抽象类或接口中。设计这个抽象模型，使其表达重要组件之间的大部分交互。将这个抽象的整体模型放在它自己的模块中，而专门的、详细的实现类留在它们自己的由子域定义的模块中。*
> 
> —埃里克·埃文斯

那么，为了我们的目的，在我们的医疗索赔领域模型中，什么会被认为是“最与众不同的概念”？

*   提交索赔

*   验证索赔
    *   提交前验证
        *   检查适当的文件

        *   验证 CPT 代码+ CPT 组合

        *   验证表单提交的数据

    *   提交后验证
        *   患者资格刮刀

*   估算索赔金额

*   授权和认证问题

我认为我们应该将索赔作为这个项目的核心领域，子领域是提交、验证和索赔金额估计过程。在不同的上下文中，我们有应用程序的身份验证/授权部分。这最好定义为*通用子域*(业务中的一个概念，其存在是为了促进关键的业务关注，但不是业务关注本身)。这些子域是“通用的”,因为它们是可重用的、解耦的组件，在整个代码库中的许多地方都会被调用。图 [6-6](#Fig6) 显示了我们将使用的最终结构。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig6_HTML.png](img/488324_1_En_6_Chapter/488324_1_En_6_Fig6_HTML.png)

图 6-6

我们应用程序关注点的最终分离

此时，我们已经将应用程序分成了更易于管理的部分，并定义了各种子域，这些子域是核心域不可或缺的一部分，有助于将系统中的声明转换为提供者的工资。

### 模块

在 DDD，有一个*模块*的概念，它是一组特定类的边界，这些类基于领域中的概念逻辑地分组在一起，并以无处不在的语言命名。模块直接对应于领域中的项目，既作为构造应用程序领域层的手段，又作为表达通用语言结构的手段。模块应该与其他模块松散耦合，但是模块中的类本身应该与同一模块中的其他类紧密结合。

模块如何与有界上下文相关联？图 [6-7](#Fig7) 显示了 DDD 战略设计的层级。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig7_HTML.jpg](img/488324_1_En_6_Chapter/488324_1_En_6_Fig7_HTML.jpg)

图 6-7

DDD 组织和结构的战略分解

我们可以看到，核心域是顶级关注点，核心域由各种子域表示，每个子域都有对应的有界上下文。有界的上下文本身再次被分解，并被分成各种模块，这些模块一起表示构成子域中所表达的思想的逻辑。在我们的例子中，图 [6-8](#Fig8) 显示了模块结构的可能配置。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig8_HTML.jpg](img/488324_1_En_6_Chapter/488324_1_En_6_Fig8_HTML.jpg)

图 6-8

在我们的 claims 示例项目中，模块、有界上下文、子域和核心域的结构

Note

这本书没有详尽、完整地列出构建这个示例项目的每一行代码，而是给出了用 Laravel 翻译应用程序各个部分的可能方法。关于这个项目的完整代码清单和书中所有其他的源代码，请访问 Apress 网站。

现在我们已经介绍了一些架构设计解决方案，并且有了一个适合应用程序和领域模型需求的解决方案，我们可以开始使用 Laravel 构建组件本身，并开始看到我们的应用程序成形。

## 创建 Laravel 组件

让我们看看是否可以将它分解成类，我们将在不同的模块中使用这些类来完成我们需要做的事情。要做到这一点，我们需要对领域有一个清晰的概念，这样我们最终创建的模型才能用文字的方式表达它。如果您已经定义了模块的一般结构，并且知道它们所处的有界上下文，那么在定义更细粒度的结构(类)时，最好的起点是确定每个上下文中需要的模型，并在模块的范围内定义它们，注意使类名与无处不在的语言中的术语一致。由于它将在应用程序中的任何地方使用，以确定对域中给定资源的授权，我们将从关注通用子域开始，在本例中，是用户和角色。

### 用户

现在，我们知道会有不同的用户在不同的时间使用系统，这些用户中的每一个都必须有一个登录名和一个定义好的角色，这样我们的系统就知道如何识别每一个用户，以及他们能做什么和不能做什么以及能看到什么。Laravel 附带了一个标准的`User`类，它扩展了另一个`User`类，而后者又从雄辩的基础`model`扩展来定义管理用户的各种设施。父类`User`使用各种特征来访问 Laravel 的认证和授权特性。

关于如何继续的第一个想法可能是创建额外的`User`类，它们也从基类(别名为`Authenticatable),`扩展而来，然后为每种类型的`User`类提供它们自己的可用方法和属性的子集。它看起来有点像图 [6-9](#Fig9) 。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig9_HTML.jpg](img/488324_1_En_6_Chapter/488324_1_En_6_Fig9_HTML.jpg)

图 6-9

应用程序中所需的各种用户类的初始设计

这种设计有许多问题，列举如下:

*   有一个额外的`User`类，它似乎对我们的应用程序或领域没有明确的目的。这是相当尴尬的，并留下了误解的空间。

*   事实上，我们违反了关注点分离和 Demeter 定律，因为我们混淆了系统中用户的概念和系统中权限的概念，而它们显然是不同的。

*   我们将认证和授权问题与`User`定义混在一起，并创建了两个额外的类，它们也扩展了同一个父类。问题是“角色”的明确概念已经丢失。我们应该认为用户有一个或多个角色，而不是用户是这些角色中的一个(这意味着它确实属于内联的`User`定义)。

*   当执行身份验证或权限检查时，我们将不断地在三个`User`类之间周旋，而不是只有一个`User`类可以传递和管理。对我来说那听起来像是一个巨大的痛苦！

*   这种设计根本不可扩展。如果我们需要添加额外的用户类型(或者更准确地说，用户角色)，那么我们就不得不在系统中创建额外的类和对象，每个类和对象都有自己的实现，并在系统的其余部分进行有效性检查。

这种设计的最大问题可以在列表的第三和第五项中找到。用户和角色的概念应该在同一个模块中分开，而不是在同一个类中。我们应该将这些问题相互分离，并明确这两组类。

话虽如此，图 [6-10](#Fig10) 显示了之前设计的一个更好的版本，考虑到了我们将用户和角色模型分开的决定(没有双关的意思)。

![img/488324_1_En_6_Chapter/488324_1_En_6_Fig10_HTML.jpg](img/488324_1_En_6_Chapter/488324_1_En_6_Fig10_HTML.jpg)

图 6-10

设计用户及其相应角色的更好方法

正如你在图 [6-10](#Fig10) 中看到的，我们现在已经将“用户角色”的概念封装在它自己的类中，并且我们已经定义了几个常量来反映系统中使用的各种角色。这种设计非常灵活，因为我们可以将任何我们想要的角色附加到一个特定的`User`对象上。它也是可伸缩的，因为我们可以在不添加类的情况下向系统添加角色。我们能够满足系统当前和未来的需求，同时将系统中的类的总数保持在尽可能低的水平。我们在正确的轨道上！然而，还有一个问题:我们不希望角色的概念泄露到`User`对象中，也不希望用户的概念泄露到`Role`对象中。我们如何完成这样的事情？我现在不会给你所有的细节，但是我会给你一个提示:我们可以使用一个数据透视表作为角色表和`users`表之间的中介，实际上被称为`user_role`表(或`role_user`)。

The Cost of Bad Design

优秀的程序员既是艺术家也是科学家。我们将需求钉在一门科学上，并使用我们的画图构造这些问题的各种解决方案(在这种情况下，它将是 DDL 或 PHP，取决于您如何看待它)。当我们认识到设计或模型逻辑的清晰性时，就像我们在这里所看到的用户和角色的分离，我们应该总是试图在我们的应用程序的画布中捕捉知识:设计。好的设计在努力；更差的设计更难。想想看:一个好的设计几乎没有开销，因为你不必改变一堆东西来补偿应用程序不同部分的另一个变化，因为程序员遵循适当的标准和最佳实践来设计他们的软件，其中之一就是严格遵守关注点的分离。在一个设计糟糕、没有经过深思熟虑或规划不当的系统中，你不可能获得这些很酷的好处。修复和维护一堆垃圾(有人称之为真正的 web 应用程序，只是碰巧被黑客攻击到足以使其在技术上“工作”的程度)的成本远远超过了您要处理的成本、挫折、头痛、架构更改和维护水平，直到最后有一天您不得不(或者更确切地说，不得不)从头重写它，或者采用更高级的解决方案，如反腐败层，来解决糟糕的设计留下的问题。无论糟糕的设计的原因是否与范围蔓延、对领域的误解、对被误解的领域的错误陈述有关，或者完全缺乏关于管理领域的较低级业务规则和政策的经验和知识，一个设计糟糕的系统都要复杂得多、困难得多、昂贵得多，对于像我们这样聪明的开发人员来说根本不是一个选择。

我花时间为你精心创作了一首诙谐的诗，它将帮助你记住设计的主要焦点应该是领域，以及如何最好地将其建模为软件(尽管，正如伏尔泰曾经说过的，“诙谐的说法证明不了什么……”).

*抓紧时间，*

*敲定设计，*

*但是不要浪费时间，*

*关于你发现的问题，*

*如果他们不在域中，*

现在，把它们留在身后。

我试图说明的另一点是，基础设施和应用层的问题不应该影响领域层；领域层应该影响基础设施和应用程序层。

## 设计建模

为了继续建模过程，我们需要解决一个由 Laravel 的默认名称空间和目录结构引起的问题。问题是，它们并不是面向一个干净的、分离的架构，这个架构完全表达了我们的领域模型的意图。这是我们将在下一章研究的内容，下一章将着重于创建一个标准组件来映射我们的应用程序中需要的许多用户角色。我们的应用程序被认为是一个企业 web 应用程序，这意味着我们必须正确地跟踪、管理和检查所有试图访问受保护的服务(例如搜索病人)或受保护的实体(及其相应的字段)的用户，以确保他们被允许调用特定的服务或选择、修改或删除给定的实体(在 API 的上下文中称为*资源*)。这方面的一个例子是制定一项政策，只允许搜索属于给定诊所或提供商的患者，他们在医疗系统中注册为患者的主治医生。

## 结论

在本章中，我们看了一下本章和后续章节中使用的示例声明应用程序的各个领域级方面。我们讨论了医疗服务提供者目前面临的一个实际问题，即以“旧方式”完成索赔提交，以获得对合格患者服务的补偿。由于对来自系统的索赔进行了严格的审查，许多索赔由于一些错误(或缺少信息)而被延迟支付。唯一的验证工作是用肉眼手工完成的。

我们的应用程序解决了所有这些问题，并为进入系统的所有索赔提供了各种检查和平衡的解决方案，因此返回的提交数量要少得多，其中 99%在第一次尝试时就被接受。该应用程序作为企业级应用程序存在，需要用户角色和服务等组件，例如以细粒度方式进行身份验证和授权，以便通过登录和凭据支持系统中的所有用户。提交过程本身由各种规模较小的过程组成，这些过程相互协作以产生预期的结果。我们尝试了一种可能的组件(模块)结构，使用了一些通用的最佳实践，最重要的是，使用领域中的核心概念，按照领域驱动的设计来制作一个粗略的模型结构。我们看了一些概念，如有界上下文、核心域和一般子域。