# 二十二、对象、模式、实践

从对象基础到设计模式原则，再到工具和技术，这本书只关注一个目标:成功的 PHP 项目。

在这一章中，我回顾了我在整本书中涉及的一些主题和观点:

*   PHP 和 objects:PHP 如何继续增加对面向对象编程的支持，以及如何利用这些特性

*   *对象和设计*:总结一些面向对象的设计原则

*   模式:是什么让他们变得酷

*   模式原则(Pattern principles):概述了许多模式背后的面向对象的指导原则

*   工作所需的工具:重温我描述过的工具，并检查一些我没有用过的工具

## 目标

正如你在第二章中看到的，在很长一段时间里，对象在 PHP 世界里是一种事后的想法。至少可以说，在 PHP 3 中，支持是初级的，对象只不过是穿了漂亮衣服的关联数组。尽管对于 PHP 4 的对象爱好者来说，事情有了根本性的改善，但是仍然存在一些严重的问题。最重要的是，默认情况下，对象是通过引用来分配和传递的。

PHP 5 的引入最终将对象拖到了舞台中央。你仍然可以不用声明一个类就用 PHP 编程，但是这种语言最终为面向对象的设计进行了优化。PHP 7 完善了这一点，引入了期待已久的特性，如标量和返回类型声明。可能出于向后兼容的原因，一些流行的框架本质上仍然是过程化的(特别是 WordPress)；然而，总的来说，今天大多数新的 PHP 项目都是面向对象的。

在第 3 、 4 和 5 章中，我详细考察了 PHP 的面向对象支持。以下是 PHP 自版本 5 以来引入的一些新特性:反射、异常、私有和受保护的方法和属性、`__toString()`方法、`static`修饰符、抽象类和方法、最终方法和属性、接口、迭代器、拦截器方法、类型声明、`const`修饰符、通过引用传递、`__clone()`、`__construct()`方法、后期静态绑定、名称空间和匿名类。这个不完整列表的长度揭示了 PHP 的未来与面向对象编程的紧密程度。

Zend Engine 2 和 PHP 5 使面向对象设计成为 PHP 项目的核心，向一批新的开发人员开放了这种语言，并为现有的爱好者开辟了新的可能性。

在第六章中，我看到了对象可以给你的项目设计带来的好处。因为对象和设计是本书的中心主题之一，所以有必要详细概括一些结论。

### 选择

没有法律规定你必须只用类和对象来开发。设计良好的面向对象代码提供了一个清晰的接口，可以从任何客户端代码访问，无论是面向过程的还是面向对象的。即使您对编写对象不感兴趣(如果您仍在阅读这本书，这种可能性不大)，您也可能会发现自己在使用它们，即使只是作为 Composer 软件包的客户。

### 封装和委托

对象们关心自己的事情，关起门来继续完成分配给他们的任务。它们提供了一个接口，通过这个接口可以传递请求和结果。任何不需要暴露的数据，以及实现的肮脏细节，都隐藏在这种正面的背后。

这给了面向对象和过程化项目不同的形状。面向对象项目中的控制器通常出人意料地稀少，由少数几个获取对象的实例化和从一个集合中调用数据并将其传递给另一个集合的调用组成。

另一方面，程序性项目更倾向于干涉主义。控制逻辑在更大程度上下降到实现，引用变量，测量返回值，并根据情况沿着不同的操作路径轮流进行。

### 退耦

解耦就是消除组件之间的相互依赖，这样对一个组件进行更改就不需要对其他组件进行更改。设计良好的对象是自我封闭的。也就是说，他们不需要参考自身之外的东西来回忆他们在之前的调用中学习到的细节。

通过维护状态的内部表示，对象减少了对全局变量的需求——这是紧耦合的一个众所周知的原因。在使用全局变量时，你将系统的一部分绑定到另一部分。如果一个组件(无论是函数、类还是代码块)引用了一个全局变量，那么另一个组件可能会意外地使用相同的变量名，并用它的值替换第一个变量。第三个组件可能会依赖于第一个组件设置的变量中的值。改变第一个组件的工作方式，可能会导致第三个组件停止工作。面向对象设计的目标是减少这种相互依赖，使每个组件尽可能自给自足。

紧密耦合的另一个原因是代码重复。当您必须在项目的不同部分重复一个算法时，您会发现紧密耦合。你来改算法会怎么样？显然，您必须记住在它出现的任何地方进行更改。忘记这样做，你的系统就有麻烦了。

代码重复的一个常见原因是并行条件。如果您的项目需要根据特定的环境以一种方式做事(例如，在 Linux 上运行)，而根据另一种环境以另一种方式做事(例如，在 Windows 上运行)，您会经常发现相同的`if` / `else`子句出现在系统的不同部分。如果你添加了一个新的环境和处理它的策略(MacOS)，你必须确保所有的条件都被更新。

面向对象编程提供了处理这个问题的技术。可以用*多态*代替条件句。多态性，也称为*类切换*，是根据情况透明地使用不同的子类。因为每个子类都支持与公共超类相同的接口，所以客户端代码既不知道也不关心它使用的是哪个特定的实现。

条件代码没有从面向对象的系统中消失；它只是被最小化和集中化。必须使用某种条件代码来确定将向客户端提供哪些特定的子类型。不过，这种测试通常只在一个地方进行一次，从而减少了耦合。

### 复用性

封装促进了解耦，从而促进了重用。自给自足且仅通过公共接口与更广泛的系统进行通信的组件通常可以从一个系统转移到另一个系统中使用，而无需更改。

事实上，这比你想象的要罕见。即使是完美的正交码也可能是特定于项目的。例如，当创建一组用于管理特定网站内容的类时，值得在规划阶段花一些时间来查看那些特定于您的客户的功能，以及那些可能形成以内容管理为核心的未来项目的基础的功能。

重用的另一个技巧是:集中那些可能在多个项目中使用的类。换句话说，不要将一个非常好的可重用类复制到一个新项目中。这将导致宏观上的紧密耦合，因为您将不可避免地在一个项目中改变类，而在另一个项目中忘记这样做。在一个可以被项目共享的中央存储库中管理公共类会更好。

### 美学

这不会说服任何还没有被说服的人，但是对我来说，面向对象的代码在美学上是令人愉悦的。实现的混乱被隐藏在干净的接口后面，使得对象对其客户来说是一件明显简单的事情。

我喜欢多态性的整洁和优雅，因此 API 允许您操作非常不同的对象，但仍然可以互换和透明地执行——对象可以像儿童积木一样整齐地堆叠或插入另一个对象。

当然，有人认为反之亦然。面向对象的代码可以表现为类的爆炸式增长，这些类彼此之间是如此的解耦，以至于拼凑它们之间的关系是一件令人头疼的事情。这本身就是一种代码味道。建立生产工厂的工厂，生产工厂的工厂，这通常是很诱人的，直到你的代码看起来像一个镜子大厅。有时候，做最简单的工作，然后为了测试和灵活性而进行足够优雅的重构是有意义的。让问题空间决定您的解决方案，而不是最佳实践列表。

Note

严格应用所谓的最佳实践也经常是项目管理中的一个问题。每当一项技术或一个过程的使用开始变得像仪式一样，被自动地、不灵活地应用，就值得花一点时间来研究你当前方法背后的推理。有可能你正从工具领域转向货物崇拜领域。

同样值得一提的是，一个漂亮的解决方案并不总是最好或最有效的。使用成熟的面向对象解决方案是很诱人的，在这种情况下，一个快速脚本或几个系统调用就可以完成工作。

## 模式

最近，一个 Java 程序员申请了一份工作，这家公司和我有一些关系。在他的求职信中，他为几年来只使用模式而道歉。设计模式是最近的发现——一个变革性的进步——这一假设证明了它们所带来的兴奋。事实上，这位经验丰富的程序员使用模式的时间可能比他想象的要长。

模式描述了常见的问题和经过测试的解决方案。模式命名、编纂和组织真实世界的最佳实践。它们不是发明的组成部分，也不是教义中的条款。如果一个模式没有描述孵化时已经很普遍的实践，那么它将是无效的。

记住，模式语言的概念起源于建筑领域。在模式被提出作为描述空间和功能问题的解决方案之前，人们建造庭院和拱门已经有几千年了。

话虽如此，设计模式确实经常会激起与宗教或政治争议相关的情绪。信徒们在走廊里漫步，眼里闪着福音的光芒，胳膊下夹着一本《四人帮》的书。他们搭讪门外汉，像信仰文章一样一口气说出模式名称。难怪一些批评家认为设计模式是炒作。

在 Perl 和 PHP 等语言中，模式也是有争议的，因为它们与面向对象编程有着紧密的联系。在对象是设计决策而不是给定的情况下，将自己与设计模式联系起来相当于偏好声明，尤其是因为模式产生更多的模式，而对象产生更多的对象。

### 什么样的模式买给我们

我在第七章中介绍了模式。让我们重申一下模式可以给我们带来的一些好处。

#### 屡试不爽

首先，正如我所提到的，模式是特定问题的成熟解决方案。在模式和配方之间进行类比是危险的:配方可以被盲目地遵循，而模式本质上是“半生不熟的”(马丁·福勒)，需要更深思熟虑的处理。尽管如此，食谱和图案都有一个重要的特点:它们在铭刻之前都经过了彻底的试验和测试。

#### 模式暗示了其他模式

图案有相互吻合的凹槽和曲线。某些模式会随着令人满意的咔哒声一起出现。使用模式解决问题将不可避免地产生后果。这些后果可能成为暗示互补模式的条件。当然，当您选择相关模式时，一定要注意解决实际的需求和问题，而不仅仅是构建优雅但无用的互锁代码塔。构建相当于建筑上愚蠢的编程是很有诱惑力的。

#### 常用词汇

模式是开发描述问题和解决方案的通用词汇的一种方式。命名很重要——它代表描述，因此能让我们很快覆盖很多领域。当然，命名也模糊了那些还没有共享词汇的人的意思，这也是为什么模式有时会如此令人愤怒的原因之一。

#### 模式促进设计

正如下一节所讨论的，如果使用得当，模式可以鼓励好的设计。当然，有一个重要的警告。模式不是仙尘。

### 设计的模式和原则

设计模式本质上与良好的设计有关。如果使用得当，它们可以帮助您构建松散耦合且灵活的代码。然而，当模式批评家说模式可能被新感染者过度使用时，他们说得有道理。因为模式实现形成了漂亮优雅的结构，所以很容易忘记好的设计总是在于符合目的。记住模式的存在是为了解决问题。

当我第一次开始使用模式时，我发现自己在代码中创建了抽象工厂。我需要生成对象，抽象工厂无疑帮助了我。

但事实上，我在懒散地思考，给自己做不必要的工作。我需要产生的对象集确实是相关的，但是它们还没有替代的实现。经典的抽象工厂模式非常适合根据环境生成不同的对象集的情况。要使抽象工厂工作，您需要为每种类型的对象创建工厂类，并创建一个类来提供工厂类。光是描述过程就让人精疲力尽。

如果我创建了一个基本的工厂类，我的代码会干净得多，如果我发现自己需要生成一组并行的对象，只需要重构来实现抽象工厂。

使用模式的事实并不能保证好的设计。在开发时，最好记住同一原则的两种表达方式:KISS(“保持简单，笨蛋”)和“做最简单的工作。”极限程序员还给出了另一个相关的缩写:YAGNI。“你不需要它”，这意味着除非真的需要，否则你不应该实现一个特性。

随着警告的消失，我可以继续我那令人窒息的热情。正如我在第九章中所阐述的，模式倾向于体现一套可以推广并应用于所有代码的原则。

#### 偏爱合成而非遗传

继承关系是强大的。我们使用继承来支持运行时类切换(多态性)，这是我在本书中探索的许多模式和技术的核心。但是，通过在设计中仅仅依赖继承，您可能会产生易于重复的不灵活的结构。

#### 避免紧密耦合

我在本章已经谈到了这个问题，但为了完整起见，这里值得一提。您永远无法回避这样一个事实，即一个组件的变更可能需要项目其他部分的变更。但是，您可以通过避免重复(在我们的示例中以并行条件为代表)和过度使用全局变量(或单例)来最小化这种情况。当抽象类型可以用来促进多态性时，也应该尽量减少具体子类的使用。这最后一点引导我们到另一个原则。

#### 接口的代码，而不是实现

用清晰定义的公共接口设计你的软件组件，使每个组件的职责透明。如果你在一个抽象超类中定义你的接口，并且让客户端类请求并使用这个抽象类型，那么你就可以将客户端从具体的实现中分离出来。

说到这里，请记住 YAGNI 原则。如果你开始时只需要一个类型的实现，没有直接的理由去创建一个抽象超类。你也可以在一个具体的类中定义一个清晰的接口。一旦您发现您的单个实现试图同时做多件事情，您可以将您的具体类重新指定为两个子类的抽象父类。客户端代码不会变得更聪明，因为它继续使用单一类型。

您可能需要拆分实现并将结果类隐藏在抽象父类之后的一个典型标志是实现中出现了条件语句。

#### 概括不同的概念

如果你发现你淹没在子类中，也许你应该把所有这些子类化的原因提取到它自己的类型中。如果原因是为了达到某种目的，而这种目的是你的类型的主要目的所附带的，那就更是如此了。

例如，给定一个类型`UpdatableThing`，您可能会发现自己创建了`FtpUpdatableThing`、`HttpUpdatableThing`和`FileSystemUpdatableThing`子类型。然而，你的类型的责任是成为一个可更新的东西——存储和检索的机制是附带的。`Ftp`、`Http`和`FileSystem`是这里变化的东西，它们属于自己的类型——姑且称之为`UpdateMechanism`。`UpdateMechanism`将有不同实现的子类。然后，您可以添加尽可能多的更新机制，而不会干扰`UpdatableThing`类型，后者仍然专注于其核心职责。顺便提一下，注意`UpdateMechanism`也可以被命名为`UpdateStrategy`。我已经描述了策略模式的一个实现。有关更多信息，请参见第十一章。

还要注意，我在这里用动态运行时安排替换了静态编译时结构，让我们(好像是偶然地)回到了我们的第一个原则:“优先组合而不是继承。”

## 实践

我在本书的这一部分提到的问题(以及在第十四章中介绍的问题)经常被教科书和编码人员忽略。在我自己作为程序员的生活中，我发现这些工具和技术至少和设计一样与项目的成功相关。毫无疑问，像文档和自动化构建这样的问题在本质上不如组合模式这样的奇迹有启示性。

Note

让我们提醒一下 Composite 的美妙之处:一个简单的继承树，它的对象可以在运行时连接起来，形成同样是树的结构，但是要灵活和复杂得多。多个对象共享一个接口，通过这个接口向外界展示它们。简单与复杂、多重与单一之间的相互作用，一定会让你的脉搏加速——这不仅仅是软件设计，而是诗歌。

即使像文档和构建、测试和版本控制这样的问题比模式更加平淡无奇，它们也同样重要。在现实世界中，如果多个开发人员不能轻松地参与其中或理解其来源，那么一个出色的设计将无法存活。没有自动化测试，系统变得难以维护和扩展。没有构建工具，没有人会费心部署您的工作。随着 PHP 用户群的扩大，我们作为开发人员确保质量和易于部署的责任也在增加。

项目以两种模式存在。项目是其代码和功能的结构，它也是一组文件和目录，一个合作的基础，一组源和目标，以及一个转换的主题。从这个意义上说，一个项目从外部看是一个系统，就像它在代码中一样。构建、测试、文档和版本控制的机制需要像这些机制支持的代码一样关注细节。像关注系统本身一样关注元系统。

### 测试

尽管测试是从外部应用于项目的框架的一部分，但它与代码本身紧密地集成在一起。因为完全解耦是不可能的，甚至是不可取的，所以测试框架是监控变更结果的强大方法。改变方法的返回类型可能会影响其他地方的客户端代码，导致错误在更改后几周或几个月出现。测试框架让您有一半的机会捕捉到这种错误(测试越好，这里的机会就越大)。

测试也是改进面向对象设计的工具。首先测试(或者至少同时测试)有助于你关注一个类的接口，并仔细考虑每个方法的责任和行为。我在第十八章介绍了用于测试的 PHPUnit。

### 标准

我天生是个反向投资者。我讨厌别人告诉我该做什么。像*合规*这样的词会立刻引起我的战斗或逃跑反应。但是，尽管看起来有悖常理，标准推动创新。这是因为它们推动了互操作性。互联网的兴起在一定程度上是因为开放标准已经成为其核心。网站可以相互链接，web 服务器可以在任何域中重用，因为协议是众所周知和受尊重的。筒仓中的解决方案可能比广泛接受和应用的标准更好，但是如果筒仓烧毁了怎么办？如果买了，新主人决定收取访问费怎么办？当一些人决定隔壁的筒仓更好时会发生什么？在第十五章中，我讨论了 PSR，PHP 标准建议。我特别关注了自动加载的标准，它在清理 PHP 开发人员包含类的方式方面做了很多工作。我也看了 PSR-12，编码风格的标准。程序员对大括号的放置和参数列表的部署有强烈的感觉，但同意遵守一组公共规则有助于代码的可读性和一致性，并允许我们使用工具来检查和重新格式化源文件。本着这种精神，我已经将这个版本中的所有代码示例重新格式化为*符合*PSR-12。

### 版本控制

合作很难。面对现实吧:人是尴尬的。程序员更惨。一旦你理清了团队中的角色和任务，你最不想处理的就是源代码本身的冲突。正如你在第十七章中看到的，Git(以及类似的工具，如 CVS 和 Subversion)使你能够将多个程序员的工作合并到一个单一的存储库中。在冲突不可避免的地方，Git 会标记出事实并指出问题的根源。

即使你是单飞程序员，版本控制也是必须的。Git 支持分支，因此您可以同时维护一个软件版本和开发下一个版本，将稳定版本中的 bug 修复合并到开发分支中。

Git 还提供了对项目的每次提交的记录。这意味着您可以按日期或标记回滚到任何时刻。相信我，总有一天这会拯救你的项目。

### 自动化构建

没有自动构建的版本控制是有限的。任何复杂的项目都需要部署工作。需要将各种文件移动到系统的不同位置，需要转换配置文件以获得适合当前平台和数据库的正确值，并且需要设置或转换数据库表。我介绍了两个为安装而设计的工具。第一个是 Composer(参见第十六章)，是独立软件包和小型应用的理想选择。我介绍的第二个构建工具是 Phing(参见第十九章)，这是一个具有足够能力和灵活性的工具，可以自动安装最大最复杂的项目。

自动化构建将部署从繁琐的工作转变为命令行中的一两行代码。只需很少的努力，您就可以从构建工具中调用您的测试框架和文档输出。如果您的开发人员的需求没有动摇您，请记住当您的用户发现他们不再需要在每次您发布项目的新版本时花费整个下午来复制文件和更改配置字段时，他们可怜的感激叫声。

### 持续集成

能够测试和构建一个项目是不够的；你必须一直做这件事。随着项目变得越来越复杂，并且您管理着多个分支，这变得越来越重要。您应该构建并测试一个稳定的分支，从这个分支您可以发布较小的 bug 修复版本，一个或两个实验性的开发分支，以及您的主干。如果您试图手动完成所有这些工作，即使有构建和测试工具的帮助，您也永远无法进行任何编码。当然，所有的程序员都讨厌这样，所以构建和测试不可避免地会被忽略。

在第二十一章中，我谈到了持续集成，一种尽可能自动化构建和测试过程的实践和一套工具。

### 我错过了什么

由于时间和空间的限制，我不得不从本书中省略一些工具类别，尽管如此，它们对任何项目都非常有用。在大多数情况下，对于手头的工作，有不止一个好的工具，所以，尽管我会推荐一两个，但在做出选择之前，您可能需要花一些时间与其他开发人员交流，并使用您最喜欢的搜索引擎进行搜索。

如果您的项目有不止一个开发人员，甚至只有一个活动的客户，那么您将需要一个工具来跟踪 bug 和任务。像版本控制一样，bug 追踪器是一种生产力工具，一旦你在项目中尝试过，你就无法想象不使用它。追踪器允许用户报告项目中的问题，但是它们也经常被用作描述所需特性和将它们的实现分配给团队成员的手段。

您可以随时获得打开任务的快照，根据产品、任务所有者、版本号和优先级缩小搜索范围。每个任务都有自己的页面，您可以在其中讨论任何正在进行的问题。讨论条目和任务状态的更改可以通过邮件复制给团队成员，这样就可以很容易地关注事情，而不用一直去跟踪 URL。

外面有很多工具。尽管过了这么久，我通常还是会回到令人尊敬的 Bugzilla ( [`www.bugzilla.org`](http://www.bugzilla.org) )。Bugzilla 是免费的开源软件，拥有大多数开发者可能需要的所有特性。它是一个可下载的产品，所以你必须在你自己的服务器上运行它。它看起来仍然有点 Web 1.0 的味道，但并没有因此而变得更糟。如果你不想拥有自己的追踪器，并且你有或者喜欢你的界面漂亮一点(并且有更深的口袋)，你可以看看 Atlassian 的 SAAS 解决方案，吉拉( [`www.atlassian.com/software/jira`](http://www.atlassian.com/software/jira) )。

对于高层次的任务跟踪和项目规划(尤其是如果你对使用看板系统感兴趣)，你可能还会考虑 Trello ( [`www.trello.com`](http://www.trello.com) )。

追踪器通常只是您想要用来共享项目信息的一套协作工具中的一个。你可以付费使用 Basecamp ( [`https://basecamp.com/`](https://basecamp.com/) )或 Atlassian tools ( [`www.atlassian.com/`](http://www.atlassian.com/) )等集成解决方案。或者您可以选择使用各种工具将工具生态系统缝合在一起。例如，为了促进团队内部的交流，您可能需要一种聊天或消息传递的机制。也许在撰写本文时，最流行的工具是 Slack ( [`www.slack.com`](http://www.slack.com) )。Slack 是一个基于网络的多房间聊天环境。如果你像我一样是老派，你可能会立即想到 IRC(互联网中继聊天)——你可能是对的:除了 Slack 基于浏览器，易于使用，并与其他内置服务集成之外，你几乎可以用 Slack 做 IRC 做不到的事情。Slack 是免费的，除非你需要高级功能。

说到老学校，你也可以考虑为你的项目使用邮件列表。我最喜欢的邮件列表软件是 Mailman ( [`www.gnu.org/software/mailman/`](http://www.gnu.org/software/mailman/) )，免费，相对容易安装，可配置性强。

对于可协同编辑的文本文档和电子表格，Google Docs ( [`https://docs.google.com/`](https://docs.google.com/) )可能是最简单的解决方案。

你的代码没有你想象的那么清晰。第一次访问代码库的陌生人可能会面临一项艰巨的任务。即使是你，作为代码的作者，最终也会忘记这一切是如何联系在一起的。对于内联文档，您应该看看 phpDocumentor ( [`www.phpdoc.org/`](http://www.phpdoc.org/) )，它允许您随时记录文档，并自动生成超链接输出。phpDocumentor 的输出在面向对象的上下文中特别有用，因为它允许用户从一个类点击到另一个类。由于类通常包含在它们自己的文件中，直接读取源代码可能涉及到从一个源文件到另一个源文件的复杂过程。

虽然内联文档很重要，但是项目也会产生大量的书面材料。这包括使用说明、关于未来方向的咨询、客户资产、会议记录和聚会公告。在一个项目的生命周期中，这样的材料是非常易变的，并且经常需要一种机制来允许人们在他们的发展过程中进行协作。

wiki (wiki 显然源自夏威夷语 *wikiwiki* 的意思是“非常快”)是创建超链接文档协作网络的完美工具。只需点击一个按钮，就可以创建或编辑页面，并且为匹配页面名称的单词自动生成超链接。wiki 是另一种工具，它看起来如此简单、重要和明显，以至于你确信你可能首先有了这个想法，但只是没有着手做任何事情。有许多维基可供选择。PhpWiki 我用的很好，可以从 [`https://phpwiki.sourceforge.io/`](https://phpwiki.sourceforge.io/) 下载，DokuWiki 你可以在 [`www.dokuwiki.org/dokuwiki`](http://www.dokuwiki.org/dokuwiki) 找到。

但是，对于文档(以及一般的写作)，我越来越倾向于削减到简单的文本文档和版本控制。对于格式，我使用 Markdown，一种轻量级标记语言。它在渲染之前易于阅读，并且通常在渲染之后是干净和平衡的(尽管，和所有渲染一样，你是在渲染器的支配下)。降价的最佳起点是 [`https://commonmark.org/`](https://commonmark.org/) 。经过多年与 Word 和 Word 兼容的文字处理器的斗争，我非常感谢 Apress 让我对这本书的这个版本使用 Markdown！

Note

虽然我没有省略这个工具(参见第十七章)，但值得一提的是，转换到纯文本格式使我们有可能在本书的开发中广泛使用 Git。

本期的技术评论员(Paul Tregoing)希望看到 Docker ( [`https://docs.docker.com/`](https://docs.docker.com/) )被添加到持续集成的章节中，但是时间限制阻止了这一点。Jenkins 构建作业在 Docker 容器中运行意味着您可以完全自由地调整构建环境，而不受托管 Jenkins 的系统的限制。您可以使用不同版本的包甚至不同的 Linux 发行版来构建。

## 摘要

在这一章中，我总结了一下，重温了构成这本书的核心主题。虽然我在这里还没有解决任何具体的问题，比如单个模式或对象函数，但这一章应该是本书关注点的合理总结。

永远没有足够的空间或时间来涵盖一个人想要的所有材料。尽管如此，我还是希望这本书能够证明一个观点:PHP 已经完全成熟了。它现在是世界上最流行的编程语言之一。我希望 PHP 仍然是业余爱好者最喜欢的语言，并且许多新的 PHP 程序员会很高兴地发现他们只用一点代码就能走多远。然而与此同时，越来越多的专业团队正在用 PHP 构建大型系统。这样的项目不应该只有简单的方法。通过它的扩展层，PHP 一直是一种通用语言，提供了数百个应用和库的入口。另一方面，它的面向对象的支持使您可以访问一组不同的工具。一旦你开始用对象来思考，你就可以把其他程序员来之不易的经验绘制成图表。您不仅可以导航和部署参考 PHP 开发的模式语言，还可以参考 Smalltalk、C++、C#或 Java。我们有责任通过精心设计和良好实践来迎接这一挑战。未来是可重复使用的。