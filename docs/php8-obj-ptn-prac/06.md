# 6.对象和设计

既然我们已经详细了解了 PHP 对象支持的机制，我们将从细节上退一步，考虑如何最好地使用我们遇到的工具。在这一章中，我将向你介绍一些关于对象和设计的问题。我还将研究 UML，一种用于描述面向对象系统的强大的图形语言。

本章将涵盖以下主题:

*   设计基础知识:我所说的设计是什么，面向对象的设计与过程代码有什么不同

*   *类范围*:如何决定一个类包含什么

*   封装:将实现和数据隐藏在类的接口后面

*   *多态性*:使用一个公共超类型来允许在运行时透明地替换专门化的子类型

*   UML :使用图来描述面向对象的架构

## 定义代码设计

代码设计的一个意义涉及系统的定义:确定系统的需求、范围和目标。系统需要做什么？它需要为谁做这件事？系统的输出是什么？它们满足陈述的需求吗？在较低的层面上，设计可以被理解为定义系统参与者并组织他们之间关系的过程。本章关注的是第二种意义:类和对象的定义和配置。

那么什么是参与者呢？面向对象的系统是由类组成的。在你的系统中决定这些玩家的性质是很重要的。类部分是由方法组成的；所以在定义你的类时，你必须决定哪些方法属于同一个类。但是，正如您将看到的，类通常在继承关系中组合在一起，以符合公共接口。在设计系统时，这些接口或类型应该是您的第一选择。

您还可以为您的类定义其他关系。您可以创建由其他类型组成的类或管理其他类型实例列表的类。您可以设计简单使用其他对象的类。这种组合或使用关系的可能性是内置在您的类中的(例如，通过在方法签名中使用类型声明)，但是实际的对象关系发生在运行时，这可以为您的设计增加灵活性。你将在本章中看到如何建立这些关系的模型，我们将在整本书中进一步探讨它们。

作为设计过程的一部分，您必须决定一个操作何时应该属于一个类型，何时应该属于该类型使用的另一个类。无论你走到哪里，你都会面临选择和决定，这些选择和决定可能会让你变得清晰和优雅，也可能会让你陷入妥协的泥沼。

在这一章中，我将探讨一些可能影响其中一些选择的问题。

## 面向对象和过程编程

面向对象的设计与更传统的过程化代码有什么不同？很容易说主要的区别是面向对象的代码中有对象。这既不真实也没用。在 PHP 中，你经常会发现使用对象的程序代码。您还可能遇到包含程序代码片段的类。类的存在并不能保证面向对象的设计，即使在 Java 这样的语言中也是如此，它迫使你在一个类中做大多数事情。

面向对象和过程化代码的一个核心区别在于责任的分配方式。过程代码采取一系列连续的命令和函数调用的形式。控制代码倾向于负责处理不同的情况。这种自上而下的控制会导致项目中重复和依赖的发展。面向对象的代码试图通过将处理任务的责任从客户端代码转移到系统中的对象来最小化这些依赖性。

在这一节中，我将设置一个简单的问题，然后从面向对象和过程代码两个方面来分析它，以说明这些要点。我的项目是建立一个快速的工具来读取和写入配置文件。为了保持对代码结构的关注，我将在这些例子中省略实现细节。

我将从解决这个问题的程序方法开始。首先，我将以这种格式读写文本:

```
key:value

```

为此，我只需要两个函数:

```
// listing 06.01
function readParams(string $source): array
{
    $params = [];
    // read text parameters from $source
    return $params;
}

function writeParams(array $params, string $source): void
{
    // write text parameters to $source
}

```

`readParams`函数需要源文件的名称。它试图打开它并读取每一行，寻找键/值对。它构建了一个关联数组。最后，它将数组返回给控制代码。`writeParams()`接受关联数组和源文件的路径。它遍历关联数组，将每个键/值对写入文件。下面是一些使用这些函数的客户端代码:

```
// listing 06.02
$file = "/tmp/params.txt";
$params = [
    "key1" => "val1",
    "key2" => "val2",
    "key3" => "val3",
];
writeParams($params, $file);
$output = readParams($file);
print_r($output);

```

这段代码相对紧凑，应该易于维护。调用`writeParams()`函数来创建`param.txt`,并向其写入如下内容:

```
key1:val1
key2:val2
key3:val3

```

`readParams()`函数解析相同的格式。

在许多项目中，范围不断扩大和发展。让我们通过引入一个新的需求来掩饰这一点。代码现在还必须处理如下所示的 XML 结构:

```
<params>
    <param>
        <key>my key</key>
        <val>my val</val>
    </param>
</params>

```

如果参数文件以`.xml`结尾，则应以 XML 模式读取参数文件。尽管这并不难适应，但它可能会使我的代码更难维护。现阶段我真的有两个选择。我可以检查控制代码中的文件扩展名，或者在我的读写函数中进行测试。在这里，我倾向于后一种方法:

```
// listing 06.03
function readParams(string $source): array
{
    $params = [];
    if (preg_match("/\.xml$/i", $source)) {
        // read XML parameters from $source
    } else {
        // read text parameters from $source
    }
    return $params;
}

function writeParams(array $params, string $source): void
{
    if (preg_match("/\.xml$/i", $source)) {
        // write XML parameters to $source
    } else {
        // write text parameters to $source
    }
}

```

Note

说明性代码总是包含一个困难的平衡动作。它需要足够清楚地表明自己的观点，这通常意味着为了表面上的目的而牺牲错误检查和适用性。换句话说，这里的例子实际上是为了说明设计和复制的问题，而不是解析和写入文件数据的最佳方式。为此，我省略了与当前问题无关的实现。

如您所见，我不得不在每个函数中使用 XML 扩展测试。这种重复可能会给我们带来问题。如果我被要求包含另一种参数格式，我需要记住保持`readParams()`和`writeParams()`函数相互一致。

现在我将用一些简单的类来解决同样的问题。首先，我创建一个抽象基类，它将定义类型的接口:

```
// listing 06.04
abstract class ParamHandler
{
    protected array $params = [];

    public function __construct(protected string $source)
    {
    }

    public function addParam(string $key, string $val): void
    {
        $this->params[$key] = $val;
    }

    public function getAllParams(): array
    {
        return $this->params;
    }

    public static function getInstance(string $filename): ParamHandler
    {
        if (preg_match("/\.xml$/i",  $filename))  {
            return new XmlParamHandler($filename);
        }
        return new TextParamHandler($filename);
    }

    abstract public function write(): void;
    abstract public function read(): void;
}

```

我定义了`addParam()`方法，允许用户向受保护的`$params`属性和`getAllParams()`添加参数，以提供对数组副本的访问。

我还创建了一个静态的`getInstance()`方法来测试文件扩展名，并根据结果返回一个特定的子类。关键的是，我定义了两个抽象方法，`read()`和`write()`，确保任何子类都支持这个接口。

Note

将用于生成子对象的静态方法放在父类中很方便。然而，这样的设计决策有其自身的后果。`ParamHandler`类型现在基本上仅限于处理这个中央条件语句中的具体类。如果需要处理另一种格式，会发生什么？当然，如果你是`ParamHandler`的维护者，你可以随时修改`getInstance()`的方法。然而，如果您是一名客户端编码人员，更改这个库类可能不那么容易(事实上，更改它并不难，但是您面临的前景是，每次重新安装提供它的包时，都必须重新应用您的补丁)。我将在第 9 章中讨论物体创建的问题。

现在，我将定义子类，再次省略实现的细节以保持示例的简洁:

```
// listing 06.05
class XmlParamHandler extends ParamHandler
{

    public function write(): void
    {
        // write XML
        // using $this->params
    }

    public function read(): void
    {
        // read XML
        // and populate $this->params
    }
}

```

```
// listing 06.06
class TextParamHandler extends ParamHandler
{

    public function write(): void
    {
        // write text
        // using $this->params
    }

    public function read(): void
    {
        // read text
        // and populate $this->params
    }
}

```

这些类只是提供了`write()`和`read()`方法的实现。每个班级将根据适当的格式写作和阅读。

根据文件扩展名，客户端代码将完全透明地写入文本和 XML 格式:

```
// listing 06.07
$test = ParamHandler::getInstance(__DIR__ . "/params.xml");
$test->addParam("key1", "val1");
$test->addParam("key2", "val2");
$test->addParam("key3", "val3");
$test->write(); // writing in XML format

```

我们也可以从任一文件格式中读取:

```
// listing 06.08
$test = ParamHandler::getInstance(__DIR__ . "/params.txt");
$test->read(); // reading in text format
$params = $test->getAllParams();
print_r($params);

```

那么，我们能从这两种方法中学到什么呢？

### 责任

过程示例中的控制代码负责决定格式——不是一次，而是两次。当然，条件代码被整理成函数，但这只是掩盖了单个流程的事实，即在流程进行时做出决策。对`readParams()`和`writeParams()`的调用发生在不同的上下文中，所以我们被迫在每个函数中重复文件扩展名测试(或者对这个测试执行不同的操作)。

在面向对象版本中，关于文件格式的选择是在静态`getInstance()`方法中进行的，该方法只测试一次文件扩展名，提供正确的子类。客户端代码不负责实现。它使用所提供的对象，而不知道或对它所属的特定子类不感兴趣。它只知道它正在处理一个`ParamHandler`对象，并且它将支持`write()`和`read()`。过程代码忙于细节，而面向对象的代码只处理接口，不关心实现的细节。因为实现的责任在于对象，而不在于客户机代码，所以很容易透明地支持新格式。

### 内聚力

内聚性是最接近的过程相互关联的程度。理想情况下，您应该创建共享明确职责的组件。如果您的代码广泛传播相关的例程，您会发现它们更难维护，因为您必须四处搜寻以进行更改。

我们的`ParamHandler`类将相关的过程收集到一个公共的上下文中。处理 XML 的方法共享一个上下文，在这个上下文中，它们可以共享数据，并且如果需要的话，对一个方法的更改可以很容易地反映在另一个方法中(例如，如果您需要更改 XML 元素名称)。因此可以说`ParamHandler`类具有很高的内聚性。

另一方面，过程示例将相关的过程分开。使用 XML 的代码分布在不同的函数中。

### 耦合

当系统代码的离散部分彼此紧密结合在一起，以至于一个部分的变化必然导致其他部分的变化时，紧耦合就发生了。紧密耦合绝不是过程代码所独有的，尽管这种代码的顺序性质使它容易出现问题。

您可以在程序示例中看到这种耦合。`writeParams()`和`readParams()`函数对文件扩展名运行相同的测试，以确定它们应该如何处理数据。您对其中一个进行的任何逻辑更改都必须在另一个中实现。例如，如果您要添加一种新的格式，您必须使这些函数相互一致，以便它们都以相同的方式实现新的文件扩展名测试。随着您添加新的与参数相关的函数，这个问题只会变得更糟。

面向对象的示例将各个子类彼此分离，并与客户端代码分离。如果需要添加新的参数格式，可以简单地创建一个新的子类，修改静态`getInstance()`方法中的一个测试。

### 正交性

具有严格定义的职责并且独立于更广泛的系统的组件的杀手级组合有时被称为*正交性*。安德鲁·亨特和戴维·托马斯在他们的书《实用主义程序员 T2 20 周年纪念版》中讨论了这个问题。

有人认为，正交性促进了重用，因为组件可以插入新系统，而不需要任何特殊的配置。这些组成部分将有明确的输入和输出，独立于任何更广泛的背景。正交代码使更改更容易，因为更改实现的影响将局限于被更改的组件。最后，正交码更安全。bug 的影响范围应该是有限的。高度相互依赖的代码中的错误很容易在更广泛的系统中引起连锁反应。

在类上下文中，松散耦合和高内聚并不是自动的。毕竟，我们可以将整个过程性的例子嵌入到一个被误导的类中。那么，我们如何在代码中实现这种平衡呢？我通常从考虑应该存在于我的系统中的类开始。

## 选择你的课程

定义你的类的边界是非常困难的，特别是当它们随着你构建的任何系统而发展的时候。

当你对真实世界建模时，这看起来很简单。面向对象的系统通常以真实事物的软件表示为特色——有大量的`Person`、`Invoice`和`Shop`类。这似乎表明定义一个类就是在你的系统中找到*事物*，然后通过方法给它们代理。这是一个不错的起点，但确实有其危险性。如果你把一个类看作一个名词，一个任意数量的动词的主语，那么你可能会发现它膨胀了，因为正在进行的开发和需求变化要求它做越来越多的事情。

让我们考虑一下我们在第 [3](03.html) 章中创建的`ShopProduct`示例。我们的系统存在是为了向客户提供产品，所以定义一个`ShopProduct`类是一个显而易见的选择。但这是我们需要做的唯一决定吗？我们提供了诸如`getTitle()`和`getPrice()`的方法来访问产品数据。当我们被要求提供一种输出发票和交货通知汇总信息的机制时，定义一个`write()`方法似乎是有意义的。当客户要求我们提供不同格式的产品摘要时，我们再次查看我们的类。除了`write()`方法之外，我们适时地创建了`writeXML()`和`writeHTML()`方法。或者我们给`write()`添加条件代码，根据一个选项标志输出不同的格式。

不管怎样，这里的问题是`ShopProduct`类现在试图做的太多了。它正在努力管理展示策略和产品数据。

你应该如何考虑定义类？最好的方法是认为一个类有一个主要的责任，并且尽可能地使这个责任单一和集中。把责任用语言表达出来。有人说过，你应该能够用 25 个或更少的单词来描述一个类的责任，很少使用“和”或“或”这样的词如果你的句子太长或陷入子句中，可能是时候考虑按照你描述的一些职责定义新的类了。

所以，`ShopProduct`类负责管理产品数据。如果我们增加了不同格式的写作方法，我们就开始增加一个新的责任领域:产品展示。正如你在第 [3](03.html) 章中看到的，我们实际上根据这些不同的职责定义了两种类型。`ShopProduct`类型仍然负责产品数据，而`ShopProductWriter`类型负责显示产品信息。各个子类细化了这些职责。

Note

很少有设计规则是完全不灵活的。例如，您有时会看到在一个不相关的类中保存对象数据的代码。虽然这似乎违反了一个类应该有一个单独职责的规则，但它可能是功能存在的最方便的地方，因为一个方法必须拥有对实例字段的完全访问权。使用本地持久化方法还可以避免我们创建一个并行的持久化类层次结构来镜像我们的可保存类，从而引入不可避免的耦合。我们将在第 12 章中讨论对象持久化的其他策略。避免宗教式的遵守设计规则；他们不能代替你分析面前的问题。努力保持对规则背后的推理的关注，并强调这一点胜过规则本身。

## 多态性

多态性，或者说类切换，是面向对象系统的一个常见特征。你已经在这本书里遇到过几次了。

多态是在一个公共接口后面维护多个实现。这听起来很复杂，但实际上你现在应该很熟悉了。代码中大量条件语句的出现通常表明了对多态性的需求。

当我在第 3 章中第一次创建`ShopProduct`类时，我尝试了一个单独的类，它管理书籍和 CD 的功能，以及通用产品。为了提供汇总信息，我依赖一个条件语句:

```
// listing 06.09
public function getSummaryLine(): string
{
    $base = "{$this->title} ( {$this->producerMainName}, ";
    $base .= "{$this->producerFirstName} )";
    if ($this->type == 'book') {
        $base .= ": page count - {$this->numPages}";
    } elseif ($this->type == 'cd') {
        $base .= ": playing time - {$this->playLength}";
    }
    return $base;
}

```

这些陈述暗示了两个子类的形状:`CdProduct`和`BookProduct`。

出于同样的原因，我的过程参数示例中的条件语句包含了我最终实现的面向对象结构的种子。我在脚本的两个部分重复了相同的条件:

```
// listing 06.10
function readParams(string $source): array
{
    $params = [];
    if (preg_match("/\.xml$/i", $source)) {
        // read XML parameters from $source
    } else {
        // read text parameters from $source
    }
    return $params;
}

function writeParams(array $params, string $source): void
{
    if (preg_match("/\.xml$/i", $source)) {
        // write XML parameters to $source
    } else {
        // write text parameters to $source
    }
}

```

每个子句都暗示了我最终产生的一个子类:`XmlParamHandler`和`TextParamHandler`。这些扩展了抽象基类`ParamHandler`的`write()`和`read()`的方法:

```
// listing 06.11
// could return XmlParamHandler or TextParamHandler
$test = ParamHandler::getInstance($file);

$test->read(); // could be XmlParamHandler::read() or TextParamHandler::read()
$test->addParam("newkey1", "newval1");
$test->write(); // could be XmlParamHandler::write() or TextParamHandler::write()

```

值得注意的是，多态并不排斥条件句。像`ParamHandler::getInstance()`这样的方法通常会根据`switch`或`if`语句来决定返回哪些对象。但是，这些倾向于将条件代码集中到一个地方。

正如您所看到的，PHP 强制执行由抽象类定义的接口。这是有帮助的，因为我们可以确定一个具体的子类将支持与那些由抽象父类定义的方法签名完全相同的方法签名。这包括类型声明和访问控制。因此，客户端代码可以互换地对待一个公共超类的所有子类(只要它只依赖于父类中定义的功能)。

## 包装

封装仅仅意味着对客户端隐藏数据和功能。再说一次，它是一个关键的面向对象的概念。

在最简单的层面上，通过声明属性`private`或`protected`来封装数据。通过对客户端代码隐藏属性，可以强制实施接口并防止对象数据的意外损坏。

多态说明了另一种封装。通过将不同的实现放在一个公共接口后面，您可以对客户端隐藏这些底层策略。这意味着在这个接口后面所做的任何更改对更广泛的系统都是透明的。您可以添加新类或更改类中的代码，而不会导致错误。重要的是接口，而不是接口下的工作机制。这些机制保持得越独立，变更或修复在您的项目中产生连锁反应的机会就越小。

在某些方面，封装是面向对象编程的关键。你的目标应该是使每个部分尽可能独立于其他部分。类和方法应该接收尽可能多的信息来执行分配给它们的任务，这些任务应该限制在一定的范围内，并清楚地标识出来。

`private`、`protected`和`public`关键字的引入使得封装变得更加容易。然而，封装也是一种精神状态。PHP 4 没有为隐藏数据提供正式的支持。隐私必须使用文档和命名约定来表示。例如，下划线是表示私有属性的常用方式:

```
var $_touchezpas;

```

当然，代码必须被仔细检查，因为隐私没有被严格执行。不过有趣的是，错误很少发生，因为代码的结构和风格非常清楚地表明了哪些属性不需要处理。

出于同样的原因，即使在 PHP 5 到来之后，我们也可以打破规则，通过使用`instanceof`操作符来发现我们在类切换上下文中使用的对象的确切子类型:

```
// listing 06.12
public function workWithProducts(ShopProduct $prod)
{
    if ($prod instanceof CdProduct) {
        // do cd thing
    } elseif ($prod instanceof BookProduct) {
        // do book thing
    }
}

```

你可能有一个很好的理由这样做，但是，一般来说，它带有一点不确定的气味。通过查询示例中的特定子类型，我建立了一个依赖关系。虽然子类型的细节被多态隐藏了，但是完全改变`ShopProduct`继承层次结构而没有不良影响是可能的。这段代码结束了这一切。现在，如果我需要合理化`CdProduct`和`BookProduct`类，我可能会在`workWithProducts()`方法中产生意想不到的副作用。

从这个例子中可以吸取两个教训。首先，封装有助于创建正交码。第二，封装的可实施程度无关紧要。封装是一种技术，应该被类和它们的客户同等地遵守。

## 忘记怎么做了

如果你像我一样，提到一个问题会让你的思维加速，寻找可能提供解决方案的机制。您可能会选择能够解决某个问题的函数，重新使用巧妙的正则表达式，并跟踪 Composer 包。您可能在一个旧项目中有一些可粘贴的代码，做一些类似的事情。在设计阶段，你可以把所有这些都放在一边一段时间。清空你头脑中的程序和机制。

只考虑系统的关键参与者:它需要的类型和它们的接口。当然，你对过程的了解会影响你的思维。打开文件的类需要路径，数据库代码需要管理表名和密码，等等。但是，让代码中的结构和关系引导你。您会发现，在定义良好的接口背后，实现很容易到位。然后，如果需要，您可以灵活地切换、改进或扩展实现，而不会影响更广泛的系统。

为了强调接口，考虑抽象基类或接口，而不是具体的孩子。例如，在我获取参数的代码中，接口是设计中最重要的方面。我想要一个读写名称/值对的类型。对于类型来说，重要的是这种责任，而不是实际的持久性介质或存储和检索数据的方式。我围绕抽象的`ParamHandler`类来设计系统，并且只在稍后添加实际读写参数的具体策略。这样，我从一开始就将多态和封装构建到我的系统中。该结构有助于类别切换。

当然，话虽如此，我从一开始就知道会有文本和 XML 实现`ParamHandler`，毫无疑问这影响了我的界面。在设计界面时，总会有一些心理杂耍要做。

在*Design Patterns:Elements of Reusable Object-Oriented Software*(Addison-Wesley Professional，1995 年)中，四人组用一句话总结了这个原则:“编程到一个接口，而不是一个实现。”这是一个很好的补充到你的编码手册。

## 四个路标

很少有人在设计阶段就完全正确。随着需求的变化，或者随着我们对正在解决的问题的本质有了更深的理解，我们大多数人都会修改我们的代码。

当你修改你的代码时，它很容易脱离你的控制。这里增加一个方法，那里增加一个新类，渐渐地你的系统开始衰退。正如您已经看到的，您的代码可以指出改进的方向。代码中的这些指针有时被称为代码味道——也就是说，代码中的特性*可能会*建议特定的修复，或者至少会让你重新审视你的设计。在这一节中，我将已经提出的一些要点提炼为四个迹象，您应该在编码时注意这些迹象。

### 代码复制

重复是代码中最大的弊端之一。如果你在编写一个例程时有一种奇怪的似曾相识的感觉，很可能你有问题。

看看你系统中重复的例子。也许他们属于彼此。复制通常意味着紧密耦合。如果你改变了某个套路的一些基本内容，类似的套路需要修改吗？如果是这样的话，他们很可能属于同一个班级。

### 知道得太多的阶层

从一个方法到另一个方法传递参数可能很痛苦。为什么不简单地通过使用全局变量来减少痛苦呢？有了全球，每个人都可以得到数据。

全局变量有它们的位置，但是它们确实需要以某种程度的怀疑来看待。顺便说一句，这是相当高的怀疑程度。通过使用一个全局变量，或者通过给一个类任何种类的关于它的更广领域的知识，你把它锚定到它的上下文中，使它不那么可重用和依赖于超出它控制的代码。请记住，您希望解耦您的类和例程，而不是创建相互依赖。尝试限制一个类对其上下文的了解。我将在本书的后面部分探讨一些策略。

### 百事通

你的班级是否试图同时做太多事情？如果是的话，看看你能否列出这个班级的职责。你会发现其中的一个会成为一个好的课程的基础。

如果创建子类，保持一个过分热心的类不变会导致特殊的问题。您在子类中扩展了哪个职责？如果您需要一个子类来承担多个责任，您会怎么做？你可能会有太多的子类或者过度依赖条件代码。

### 条件语句

在你的项目中，你会有充分的理由使用`if`和`switch`语句。不过，有时这种结构可能是对多态性的一种呼唤。

如果您发现您在一个类中频繁地测试某些条件，特别是如果您发现这些测试在不止一个方法中被镜像，这可能是您的一个类应该是两个或更多的迹象。看看条件代码的结构是否暗示了可以在类中表达的职责。新的类应该实现一个共享的抽象基类。很有可能你必须解决如何将正确的类传递给客户端代码。我将在第 9 章介绍一些创建对象的模式。

## UML

到目前为止，在本书中，我让代码自己说话，我用简短的例子来说明继承和多态等概念。这很有用，因为 PHP 在这里是一种通用的语言:如果你已经读到这里，它是我们共有的语言。然而，随着我们的例子越来越大，越来越复杂，仅仅使用代码来说明广泛的设计变得有些荒谬。很难在几行代码中看到一个概述。

UML 代表统一建模语言。首字母正确地用于定冠词。这不仅仅是一种统一建模语言，也是 T2 的统一建模语言。

也许这种权威的语气来自于语言形成的环境。根据 Martin Fowler ( *UML 精华*，Addison-Wesley Professional，1999)的说法，UML 只是在面向对象设计社区的精英们之间经过多年的知识和官僚争论后才成为一个标准。

这场斗争的结果是一个强大的描述面向对象系统的图形语法。在这一节中，我们将仅仅触及表面，但是你将很快发现一点点 UML(对不起，一点点*的* UML)就能走很长的路。

特别是类图可以描述结构和模式，这样它们的意义就显而易见了。这种明亮的清晰度在代码片段和要点中通常很难找到。

### 类图

虽然类图只是 UML 的一个方面，但是它们可能是最普遍的。因为它们对于描述面向对象的关系特别有用，所以我将在本书中主要使用它们。

#### 代表类别

如你所料，类是类图的主要组成部分。一个类由一个命名的盒子表示(见图 [6-1](#Fig1) )。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig1_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig1_HTML.png)

图 6-1

头等

该类分为三个部分，名称显示在第一个部分。当我们只给出类名的信息时，这些分割线是可选的。在设计类图时，我们可能会发现图 [6-1](#Fig1) 的详细程度对于某些类来说已经足够了。我们没有义务在类图中表示每个字段和方法，甚至每个类。

抽象类要么用斜体表示类名(见图 [6-2](#Fig2) )，要么在类名前加上`{abstract}`(见图 [6-3](#Fig3) )。第一种方法是两种方法中比较常见的，但第二种方法在你做笔记时更有用。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig3_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig3_HTML.png)

图 6-3

使用约束定义的抽象类

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig2_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig2_HTML.png)

图 6-2

抽象类

Note

`{abstract}`语法是约束的一个例子。约束在类图中用来描述特定元素的使用方式。大括号之间的文本没有特殊的结构；它应该简单地提供适用于该元素的任何条件的简短说明。

接口的定义方式与类相同，只是它们必须包含一个原型(即 UML 的扩展)，如图 [6-4](#Fig4) 所示。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig4_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig4_HTML.png)

图 6-4

一个界面

#### 属性

概括地说，属性描述了一个类的特性。属性列在类名正下方的部分(见图 [6-5](#Fig5) )。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig5_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig5_HTML.png)

图 6-5

一个属性

让我们仔细看看示例中的属性。初始符号表示属性的可见性或访问控制级别。表 [6-1](#Tab1) 显示了三种可用的符号。

表 6-1

可见度符号

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

标志

 | 

能见度

 | 

说明

 |
| --- | --- | --- |
| + | 公众 | 适用于所有代码 |
| - | 私人的 | 仅适用于当前班级 |
| # | 保护 | 仅适用于当前类别及其子类 |

可见性符号后跟属性的名称。在这种情况下，我描述的是`ShopProduct::$price`属性。冒号用于将属性名与其类型分开(或者，可以在末尾提供一个默认值，用等号分隔)。

同样，你只需要为了清晰起见，尽可能多地包括细节。

#### 操作

操作描述方法；或者，更确切地说，它们描述了可以对一个类的实例进行的调用。图 [6-6](#Fig6) 显示了`ShopProduct`类中的两个操作。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig6_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig6_HTML.png)

图 6-6

操作

如您所见，操作使用与属性相似的语法。可见性符号位于方法名之前。参数列表用括号括起来。该方法的返回类型(如果有)用冒号分隔。参数用逗号分隔，遵循属性语法，属性名称和类型用冒号分隔。

如您所料，这种语法相对灵活。您可以省略可见性标志和返回类型。参数通常只由它们的类型表示，因为参数名通常并不重要。

#### 描述继承和实现

UML 将继承关系描述为一般化。这种关系用一条从子类别到其父类别的线来表示。这条线带有一个空的闭合箭头。

图 [6-7](#Fig7) 显示了`ShopProduct`类与其子类之间的关系。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig7_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig7_HTML.png)

图 6-7

描述继承

UML 描述了接口和实现它的类之间的关系。因此，如果`ShopProduct`类要实现`Chargeable`接口，我们可以将其添加到我们的类图中，如图 [6-8](#Fig8) 所示。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig8_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig8_HTML.png)

图 6-8

描述接口实现

#### 联合

继承只是面向对象系统中许多关系中的一种。当一个类属性被声明为包含对另一个类的一个(或多个)实例的引用时，就会发生关联。

在图 [6-9](#Fig9) 中，我们建模了两个类，并在它们之间创建了一个关联。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig9_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig9_HTML.png)

图 6-9

班级协会

在这个阶段，我们对这种关系的性质是模糊的。我们只指定了一个`Teacher`对象将引用一个或多个`Pupil`对象，反之亦然。这种关系可能是也可能不是互惠的。

你可以用箭头来描述关联的方向。如果`Teacher`类有一个`Pupil`类的实例，而不是相反，那么你应该把你的关联做成一个从`Teacher`指向`Pupil`类的箭头。这种关联称为单向关联，如图 [6-10](#Fig10) 所示。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig10_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig10_HTML.png)

图 6-10

单向联系

如果每个类都有对另一个类的引用，你可以用一个双向箭头来描述双向关系，如图 [6-11](#Fig11) 所示。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig11_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig11_HTML.png)

图 6-11

双向联系

您还可以指定一个类被关联中的另一个类引用的实例的数量(这也称为关联的“基数”)。您可以通过在每个类别旁边放置一个数字或范围来实现这一点。您也可以使用星号(*)代表任何数字。在图 [6-12](#Fig12) 中，可以有一个`Teacher`对象，也可以有零个或多个`Pupil`对象。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig12_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig12_HTML.png)

图 6-12

定义关联的多重性

在图 [6-13](#Fig13) 中，关联中可以有一个`Teacher`对象和五到十个`Pupil`对象。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig13_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig13_HTML.png)

图 6-13

定义关联的多重性

#### 聚集和组成

聚合和组合类似于关联。所有这些都描述了这样一种情况:一个类拥有对另一个类的一个或多个实例的永久引用。但是，通过聚合和组合，被引用的实例形成了引用对象的固有部分。

在聚合的情况下，包含的对象是容器的核心部分，但是它们也可以同时被其他对象包含。聚合关系由一条以空心菱形开始的线表示。

在图 [6-14](#Fig14) 中，我定义了两类:`SchoolClass`和`Pupil`。`SchoolClass`班蕴`Pupil`。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig14_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig14_HTML.png)

图 6-14

聚合

小学生组成一个类，但是同一个`Pupil`对象可以同时被不同的`SchoolClass`实例引用。如果我要解散一个学校班级，我不一定会删除该学生，他可能会参加其他班级。

组成代表了比这更强的关系。在合成中，被包含的对象只能由其容器引用。当容器被删除时，它应该被删除。组合关系的描述方式与聚合关系相同，只是菱形应被填充(见图 [6-15](#Fig15) )。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig15_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig15_HTML.png)

图 6-15

作文

一个`Person`类维护一个对`SocialSecurityData`对象的引用。包含的实例只能属于包含的`Person`对象。

#### 描述用途

在 UML 中，使用关系被描述为*依赖关系*。它是本节讨论的关系中最短暂的，因为它没有描述类之间的永久链接。

使用的类可以作为参数传递，也可以作为方法调用的结果获取。

图 [6-16](#Fig16) 中的`Report`类使用了一个`ShopProductWriter`对象。使用关系由连接两者的虚线和空心箭头表示。然而，它并不像一个`ShopProductWriter`对象维护一个`ShopProduct`对象数组那样将这个引用作为一个属性来维护。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig16_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig16_HTML.png)

图 6-16

依赖关系

#### 使用笔记

类图可以捕捉系统的结构，但是它们没有提供过程感。图 [6-16](#Fig16) 告诉我们系统中的类。从图 [6-16](#Fig16) ，你知道一个`Report`对象使用一个`ShopProductWriter`，但是你不知道这个的机制。在图 [6-17](#Fig17) 中，我用一个注释来说明一些事情。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig17_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig17_HTML.png)

图 6-17

使用注释来阐明依赖关系

如你所见，一张纸币由一个带有折叠角的盒子组成。它通常包含伪代码的碎片。

这阐明了图[6-16](#Fig16)；您现在可以看到,`Report`对象使用了一个`ShopProductWriter`来输出产品数据。这不是一个启示，但是使用关系并不总是那么明显。在某些情况下，即使是一张便条也不能提供足够的信息。幸运的是，您可以对系统中对象的交互以及类的结构进行建模。

### 序列图

序列图是基于对象的，而不是基于类的。它用于一步一步地对系统中的过程进行建模。

让我们构建一个简单的图表，对一个`Report`对象写入产品数据的方式进行建模。序列图从左至右展示了系统的参与者(见图 [6-18](#Fig18) )。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig18_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig18_HTML.png)

图 6-18

序列图中的对象

我已经用类名单独标记了我的对象。如果在我的图中，同一个类有多个独立工作的实例，我将使用格式`label:class`(例如`product1:ShopProduct`)包含一个对象名。

您从上到下展示了您正在建模的流程的生命周期，如图 [6-19](#Fig19) 所示。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig19_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig19_HTML.png)

图 6-19

序列图中的对象生命线

垂直虚线表示系统中对象的寿命。生命线后面的大方框代表过程的焦点。如果您从上到下阅读图 [6-19](#Fig19) ，您可以看到该过程如何在系统中的对象之间移动。如果不显示对象之间传递的消息，这很难阅读。我在图 [6-20](#Fig20) 中添加了这些。

![../images/314621_6_En_6_Chapter/314621_6_En_6_Fig20_HTML.png](../images/314621_6_En_6_Chapter/314621_6_En_6_Fig20_HTML.png)

图 6-20

完整的序列图

箭头表示从一个对象发送到另一个对象的消息。返回值通常是隐式的(尽管它们可以用虚线表示，从被调用的对象传递到消息发起者)。每条消息都使用相关的方法调用进行标记。虽然有一些语法，但是你可以非常灵活地使用你的标签。方括号表示一种情况:

```
[okToPrint]
write()

```

这个代码片段意味着只有满足正确的条件时，才应该进行`write()`调用。星号用于表示重复；可选地，进一步的澄清可以放在方括号中:

```
*[for each ShopProduct]
write()

```

可以从上到下解读图 [6-20](#Fig20) 。首先，`Report`对象从一个`ProductStore`对象获取一个`ShopProduct`对象的列表。它将这些传递给一个`ShopProductWriter`对象，该对象存储对它们的引用(尽管我们只能从图中推断出这一点)。`ShopProductWriter`对象为它引用的每个`ShopProduct`对象调用`ShopProduct::getSummaryLine()`，将结果添加到它的输出中。

正如你所看到的，序列图可以模拟流程，冻结动态交互的片段，并以惊人的清晰度呈现出来。

Note

看图 [6-16](#Fig16) 和 [6-20](#Fig20) 。注意类图是如何说明多态性的，显示了从`ShopProductWriter`和`ShopProduct`派生的类。现在请注意，当我们对对象间的通信进行建模时，这个细节是如何变得透明的。在可能的情况下，我们希望对象使用最通用的类型，这样我们就可以隐藏实现的细节。

## 摘要

在这一章中，我超越了面向对象编程的具体细节，着眼于一些关键的设计问题。我研究了封装、松散耦合和内聚等特性，这些特性是灵活且可重用的面向对象系统的基本方面。我接着看了 UML，为本书后面的模式工作打下了基础。