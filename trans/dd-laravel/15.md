# 十五、工厂和集合

在这一章中，我们将讨论工厂、工厂方法和集合，以及它们在应用中的用途。在深入研究聚合之前，您应该了解一些先决条件，这将使您更好地理解它们做什么，以及为什么它们是领域驱动设计的技术部分中最难正确理解的概念之一。我们将探索工厂和工厂方法对于总体设计的价值，并探索我们可以在 Laravel 和口才中做的一些很酷的事情，以使代码更容易理解和更简洁。

在此之前，让我们先了解一些核心知识，这些知识将有助于您了解聚合。我所指的主要概念包括以下内容:

*   处理

*   交易的特征
    *   酸
        *   原子数

        *   一致性

        *   隔离

        *   持久性

*   数据不一致

*   工厂

*   总计

*   强制不变量

## 一些健脑食品

我再怎么强调这一点也不为过:一个现代的 web 应用是由许多不同的软件技术组成的，每一种技术都被分割成各自的领域。一如既往，今天的软件技术总是越来越好，越来越专业化。企业过去花费数万美元创建的组件现在只需花费其中的一小部分就可以完成。这之所以可能是因为开源运动。事实证明(谁会想到)，开源软件已经对我们做生意的方式，甚至我们的生活方式产生了持久的影响。我们可以利用开源软件来实现我们的业务需求，并且我们可以直接在我们的应用中使用它，而无需支付一分钱的许可证或订阅费，这样可以节省时间和金钱，因为您不再需要重新发明轮子。我的意思是，你很可能不得不花钱请人帮你把它连接到你的系统或应用栈上，当然，除非你是一个开发人员，但是真正的“开发”时间可以集中在正确地获得领域模型上。去开源！

### 改善 PHP 的无状态性

如果您打算保存用户的设置和配置，以便下次更快地加载应用(或者您可能希望实现某种跟踪功能来判断您的访问者在哪个国家)，您可以选择创建一个 cookie，该 cookie 可以保存在客户端计算机上，然后在用户访问站点时加载。或者，如果您有一些对时间敏感的数据，例如允许应用用户访问应用的某些特定区域的 JWT 令牌，您可能希望将该令牌保存在 HTTP 头中(例如承载令牌)，可能包含在授权头中的每个请求中。或者，如果您有一些只适用于该特定访问的数据，比如在线订单，您可以将这些数据保存在会话中。重点是，PHP 本身是无状态的，一般来说 web 也是无状态的(由于客户端-服务器模型)，但是我们可以通过一些技巧和一些经过深思熟虑的代码，用现代 Web 应用的基本设施创建优雅的即兴方法。

#### 应用很便宜，数据很贵

我们有一个保存数据的数据库，这些数据为我们的网站或应用提供内容，并且在大多数情况下提供价值。你看，一个应用(基本上)只是围绕着一个典型的数据结构(由数据库模式、索引定义，或者如果你使用 NoSQL 持久化方法，文档)。我们可以改变应用一千次，它仍然可以工作，只要我们在开发时考虑到数据库结构/模式。

下面的例子不是一个场景或“假设…”虚构的讨论，但实际上是真实的。就拿 [`http://Slashdot.org`](http://slashdot.org) 这个网站来说。Slashdot 是一个非常古老、非常著名、非常受欢迎的新闻公告栏类型的网站，它发布来自用户的关于(主要是)技术和与技术相关的事物的讨论、评论和反馈(尽管它现在有许多跨越过多兴趣的类别)。作为 Slashdot 的(新)首席开发者，让我告诉你，我陷入了*的混乱。我发现这个网站实际上是用 Perl 构建的。不仅如此，它实际上是 Perl 的某个分支(出于某种原因)被编译到了网站 [`http://Slashdot.org`](http://slashdot.org) 。我一生中从未听说过这样的事。编译 Perl？那是什么？*

有趣的是，“编译”部分意味着一个独立的、专有的编程语法，这让我想起了某种类型的 4GL，它实际上决定了编译什么，并且是整个应用编译过程的主要驱动因素。当然，我的第一个想法是，“让我们重建这该死的东西，从零开始，把它做好。”然后我看了看代码。天哪，这真是太复杂了，对于一个每月有超过 300 万访问者的网站，几乎没有任何关于其当前实现或部署的文档。在我被雇佣并开始使用它的时候，这个应用的最初开发者已经离开很久很久了。事实上，在它最终落入我现在工作的公司手中之前，它已经被买卖过几次。很少有人问我关于网站如何工作的问题，你应该调用哪个函数来实现 X 事件，或者几乎没有其他的事情。在进一步了解了这个项目之后，我开始明白，这个网站的长期用户，那些首先对它的成功和受欢迎程度负责的人，坚持认为这个网站的核心外观、外观、感觉和功能与他们现在的一样或相似。有趣的是，他们希望网站的外观、感觉和功能保持和过去 18 年一样。事实和真相是，用户在网站上想要什么，用户就在网站上得到什么，因为用户*就是网站*！

Slashdot 过去是、现在是、将来也是——在很大程度上与其他规模和活跃用户相似的网站相同——就是这些用户。任何公共应用都是如此。老实说，这是我职业生涯中第一次目睹一个流行网站的用户发号施令的场景！在他们自己从另一家公司购买之前，我们公司已经从另一家拥有该网站多年的公司那里购买了该网站；我们真的受到每天访问我们网站的成千上万忠实用户的支配。埃隆·马斯克(Elon Musk)就是这样一个人，他在 Twitter 上直接引用了 Slashdot 的文章和讨论。如果我们激怒了他们(就像微软已经做的并且仍然经常对它的用户做的那样)，他们肯定会跳出来加入我们竞争对手的网站，很可能是一去不复返；之后，收视率会下降，公司甚至会失去在网站上的投资，至少可以说这是一笔可观的投资。在某种程度上，这让我崩溃了，我开始有一段时间不想去工作了。

有一天，我突然意识到，应用只是一个“外壳”,它本质上是对网站、应用或当今存在的几乎任何其他类型的软件都重要的唯一真实的东西。为 Slashdot.org 网站提供动力的编译后的 Perl 代码正在做它被设计用来做的事情:从数据库中提取数据，并系统地将其转化为用户可以消化和响应的东西(通过评论)。然而，由于源代码的复杂性(以及最初对其工作原理缺乏了解)，网站的维护是一场噩梦(尤其是对我来说)。变更通常一次需要几周时间，并且很难确定地预测站点上的任何变更需要多长时间才能投入生产。

这种理解导致了该网站的未来计划的突破。维护和更新的高成本是无法忍受的，我们决定简单地重建网站，从长远来看更容易保持。我们想要一个网站，随着时间的推移，它一定会长寿，容易更新和维护。我们选择了 Laravel 框架。我们采用了网站当前运行的现有 HTML、CSS 和 JavaScript，并将其重构到我们新的后端。是的，我建议我们使用 Laravel 框架，因为它是众所周知的、有良好文档记录的、得到良好支持的，并且(最重要的)得到良好维护的。最重要的是，我们保留了数据库中的原始数据，尽管我们随着时间的推移重构了模式，使其更加可靠和易于维护，但我们迁移了自网站首次向公众开放以来数据库中的所有数据。这次迁移包括所有用户的设置、帖子、评论和其他任何相关内容。我们将旧的普通 JavaScript + HTML 4 翻译成用 React 构建的高度可伸缩和更加灵活的前端，它与后端 Laravel 实现对话。网站的模板、功能和外观保持不变，因为我们只是将旧的外观“移植”到新的代码中，网站的用户根本不知道他们正在使用一个全新的重构系统。对他们来说，这是同一个网站。

我们是怎么做到的？我们依赖于我们所知道的质量、开源软件和 Laravel 包形式的源代码来完成我们的投标，换句话说，处理 Web 上几乎所有其他应用共有的、常见的、通常是艰苦的机制和组件。我们依靠 Laravel 提供指导框架、支持工具、帮助社区和精心编写的文档，使框架按照我们需要的方式为我们工作，从而使它成为我们自己的。

从这个故事中得出的中心观点是，无论您决定如何构建应用，任何系统最重要的方面都是数据。如果要正确设置任何东西，数据库模式应该在列表的顶部。在数据库结构(模式)上投入足够的时间来使其正确是值得的，因为您永远不知道何时会有一天您想要在长期成员不知道发生了任何变化的情况下改变后端。您可以随时替换、重建或重构应用。与这些应用生成和使用的数据相比，这些任务是廉价的。我们希望采取适当的措施来确保我们的数据保持一致的状态。交易是帮助确保这一点的一种方式。

## 处理

在《PHP 中的域驱动设计》一书中，作者用下面的话定义了事务的一般概念:

> *“事务是所有数据库系统的基本概念。事务的要点在于它将多个步骤捆绑成一个要么全有要么全无的操作。这些步骤之间的中间状态对其他并发事务是不可见的，如果发生某种故障导致事务无法完成，那么这些步骤根本不会影响数据库。”*
> 
> —Buenosvinos，Soronellas，和 Akbary，*PHP 中的域驱动设计*

因此，我们有一套操作，我们需要要么全部成功，要么全部失败，但不是每一种都有一部分。这是因为数据库的一致性。数据库一致性可以被认为是数据库相对于系统其余部分的准确性和最新性的完好程度的度量。应用、数据库、服务器和浏览器(以及一大堆其他东西)在微妙的平衡中工作。因为 PHP 是无状态的，所以必须采取措施来确保您可以跨请求保持应用数据的状态。我们有各种各样的工具可以使用，在某些特定的情况下可能会有所帮助。

最常见的交易证明是银行账户。在每个账户的每笔交易中，有一些规则，可以说，必须遵循这些规则才能实际过账到任何账户。我们现在将讨论一些对事务至关重要的共同特征。

### 原子数

原子性是一种描述方式，即使单个事务中可能涉及不同的查询，它们要么全部成功，要么全部失败，从而保证数据库即使在有错误时也保持一致的状态。

例如，假设我们有两个账户，Account_A 和 Account_B，它们有相同的货币价值，比如 500 美元。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| **账户 _A** | $500 |
| **账户 _B** | $500 |

然后，假设我们想将 100 美元从 Account_A 转移到 Account_B，这必然会在系统中创建两个相反的操作:一个是将 Account_A 减少 100 美元，另一个是将 Account_B 增加 100 美元。

**交易 1** :减少账户 A 100 美元

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| **账户 _A** | 500 美元-100 美元= 400 美元(待定) |
| **账户 _B** | $500 |

**交易 2** :增加 Account _ B by 美元

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| **账户 _A** | 500 美元-100 美元= 400 美元(待定) |
| **账户 _B** | 500 美元-100 美元= 600 美元(待定) |

请注意，在每个事务之后，都有一个尚未执行的挂起事务。当第二个事务事件被设置时，两个事务仍然处于挂起模式。只有当每个账户都被验证在其账户中具有相应的金额并且有足够的资金给第二个账户时，每个交易才会同时被执行。

这样做是为了确保不会有一个事务实际上执行了，而另一个没有执行。例如，如果只执行了第一笔交易，而没有执行第二笔交易，第二天就会有一些愤怒的电话和电子邮件，因为会有 100 美元在系统中根本没有入账。这是数据差异，是数据不一致的一种形式，因为 Account_A 将被扣除 100 美元，但 Account_B 将保持不变，仍为 500 美元。这就是*原子性*的含义:要么都执行，要么都不执行。在其中一个事务失败的情况下，数据库将经历一种机制来防止数据丢失，这种机制被称为*回滚*(在数据库的生命周期中及时后退)。

### 一致性

通过使用事务，我们可以使数据库始终保持恒定状态，即使在事务或回滚过程中也是如此。数据要么全部是旧值，要么全部是新值，但不能是两者的混合。要么全部，要么一个都没有。一致性也必须存在于领域模型中的代码和操作中。这就是领域驱动的设计如此重要的原因:它以一种几乎精确的方式反映了它所建模的领域中的过程，并且数据库应该以一种应用易于交流、使用和命令的方式建模。

然而，不仅仅是在数据库级别，事务才是重要的。一个域对象上的典型业务操作可能跨越几个事务，每个事务可能都与不同的表或数据库相关。

就请求、响应和客户机-服务器模型而言，互联网的本质是无状态的。为了创造良好的用户体验，作为开发人员，我们的工作是管理必要的事物状态，使网站的功能正常工作，并且看起来好像是有状态的。正如前面在“改善 PHP 无状态性”中所描述的，我们有许多工具可以用来管理应用的状态和它周围的数据。

因此，始终有两股力量在起作用:应用本身和它所操作的数据。我们可以在几乎任何框架或 PHP 脚本中轻松地使用数据库事务，因为有一些工具，如 Laravel 的口才，Symfony 的学说，以及作为这些和其他类似工具基础的整个 PDO PHP 库，这太棒了！但是，请考虑以下情况。

数据库事务基本上是在不同的表上运行一组多个查询，这些查询对数据库的更改要么全部发生，要么都不发生。然而，这意味着数据库事务实际上是一种保存由多个查询描述的单个事务的方法。这一点之所以相关，是因为在现实世界中，一家公司的业务流程可能跨越许多事务的整体，所有这些业务流程都需要应用于数据库事务的相同的“全有或全无”规则。这里的问题是，单独使用数据库，我们一次只能指定一个事务。我们如何确保以原子的方式处理多个数据库事务的事务组？仅仅使用数据库，我们真的做不到——无论如何效率都不高。

#### 深入挖掘:应用和数据库级的一致性

答案是应用。应用负责管理业务问题在现实世界中实际封装的大量事务，依靠数据库来执行(可能是许多)数据库事务，以便能够完全表达应用和数据存储上下文中的流程。根据情况，我们可以使用数据库来处理大部分工作，因为我们绝对需要数据库事务原子性；然而，数据库事务本身是由应用创建、管理和触发的，这意味着需要应用级别的事务。

从大的方面来看，这意味着 web 应用既是代码*又是数据*。它们都是网站或应用对任何人有用所必需的。当然，该规则也有一些例外，比如静态网站、通过 REST 接口利用 API 作为其“数据库”类型组件的脚本，或者只是发布给定领域内所有公司的目录列表的网站，目的是让这些公司购买许可证以位于列表的顶部。这个网站可以由 UI 的模板组成，组成应用内容的数据可以通过一种一次性的、随需应变的服务来获取，一旦用户偶然发现(不是故意的)特定类别网站的登录页面，就会调用该服务。在这种情况下，您实际上可以获取您需要的数据，可能为了缓存的目的而存储它，并通过 web 应用按需显示它。这只是一个例子，但这是一个可行的和低成本的在线营销或搜索引擎优化为基础的公司解决方案。

我在职业生涯中见过的大多数应用都使用数据库来保存数据，根据业务需求，可以使用任何数量的现代数据库技术(其中大多数是开源的):Elasticsearch、MySQL、Postgres、MSSQL、Redis、Firebase、Mongo DB、Propel...你明白我的意思了。

因此，要想在隧道的尽头得到一个可用的软件，有两件事情是必须的:应用和数据库。这就是数据库一致性很重要的原因；同样重要的是应用的核心功能、逻辑和流程的一致性，以及在软件中对真实情况建模时与底层领域的一致性。如果我们想要长期成功，我们应该在我们工作的任何项目中注意这两个问题。

### 隔离

就数据库一致性和 ACID 而言，隔离是指这样的事务，即事务本身中执行的任何查询或单个操作都不能影响同一事务中的任何其他查询。例如，当记录了在两个帐户之间转移资金的交易时，会运行两个查询:一个帐户增加，另一个帐户减少。当这两个查询在数据库事务的范围内时，我们可以确定它们将同时发生，而不会影响另一个，直到事务完成并提交到数据库。这是原子的和孤立的，有助于保持我们的数据一致。除了事务内的查询相互隔离之外，事务以相同的方式操作:作为独立且完全分离的操作，以可预测的原子方式修改数据库。

现在，假设我们选择在没有事务的情况下实现相同的场景，并且只是连续运行两个查询。嗯，第一个查询*增加了*第一个帐户将成功运行，因为任何给定的帐户可以有多少没有上限。然而，在这个会计系统(以及所有会计系统)中实现了一个业务规则，该规则限制了一个帐户的余额可以降到 0 美元以下多少(如果无论如何都允许的话，但是假设这个规则没有在域模型中明确定义)。因此，执行第二个查询，并尝试将第二个帐户减少第一个帐户增加的金额，这将正确执行，并对第二个帐户执行余额修改。你能看到我描述的场景有什么潜在的问题吗？

问题在于第二个账户可能没有足够的钱来支付转账到第一个账户的金额。因为查询是在安全和有保证的交易范围之外执行的，所以第一帐户被记入第二帐户不能提供的金额。所以现在，第二个账户出现了负结余。假设应用以某种方式检测到这种异常，一分钟后尝试进行相反的交易，以使账簿中的余额正确。结果是，Johnny Gambler 那天失去了所有的钱，他正看着手机，期待着政府支票打到他的账户上，结果他从自己的账户(在这种情况下，是第一个账户)中提取了相同的金额，这样这笔金额就从他的账户中扣除了。一般来说，这里的问题是，第二个账户现在有一个赤字余额，如果不在第一个账户上创造另一个赤字余额，这个赤字余额就无法逆转。

假设他们已经修复了软件中的业务逻辑，该逻辑将在向第一个帐户转账之前检查以确保第二个帐户中的余额可用，但仍然拒绝实现简单的数据库事务以确保事务的原子性得到尊重。所以，下一次，同样的情况发生了，请求需要在账户之间转移一些钱。一切都很顺利，第一笔交易执行成功，第一个账户增加了交易中指定的金额。然而，幸运的是，在第一个查询执行之后，运行事务的服务器的电源就中断了，这个过程停止了，并且被系统遗忘了。在这种情况下，问题是我们现在有一个处于*不一致状态*的数据库，我们甚至不会知道这一点，直到我们运行每月报告，表明数字没有增加，或者直到有人打电话抱怨他们没有收到他们的钱。

所有这些都可以通过一个简单的数据库事务来避免，因为事务内部的独立查询都保证单独运行，不会影响其他查询，同时，要么同时运行，要么根本不运行。这是我们确保数据一致性的方法。事务在许多应用中使用，但不应该过度使用，因为当并发请求被发送到同一台服务器上执行时，它们会降低系统速度或产生锁定问题。

### 持久性

ACID 首字母缩写词的最后一部分代表持久性，是事务的特征，对应于一旦事务运行(包括其中的所有查询)，数据本身就受到保护，不会受到电源故障和系统崩溃的影响。这在基础架构级别上意味着数据已经被持久化到硬盘上，并且已经建立了某种类型的冗余，以确保在持久化级别上发生硬盘崩溃或硬件错误时有更高的恢复机会。

## 对常见任务使用第三方代码

要知道，我们都希望从头开始构建一些优秀的软件，按照我们认为合适的方式进行设计，并最终能够帮助推动由最新、最棒的代码制成的新产品取得成功。但这几乎不是现实。在日常生活中，有来自老板的压力，项目经理盯着你，有人站在你旁边敲他们的脚，以及损失预防和会计部门总是试图“最小化”的费用报告。我们并不总是能够从头开始设计一个新系统。那么，我们必须做些什么来为自己的成功做准备，而不是重新发明轮子，并且仍然拿出一个高质量的、可维护的、长寿命的软件呢？在我看来，做到这一点的最佳方式是依靠你所知道的最佳实践和标准，专注于核心领域和应用特性，坚持使用无处不在的语言，并依靠走过相同道路的其他人的帮助。当我们选择高质量的库、包和开源代码并加以利用、定制和“自制”时，我们获得了大量的时间和生产力，因为这些第三方工具将针对所有现代 web 应用所需的常见的、非领域的、琐碎的东西，如缓存管理、数据库层、ORM、应用框架、日志记录工具、文件存储管理、即插即用的所见即所得界面，或者您可以在几分钟内制作自己的完整的预构建应用和博客。(我说的当然是 WordPress 或者 Drupal。)你接下来的项目很可能需要这些东西中的一些或全部，这没关系。只要我们对集成到应用中的所有第三方代码的质量做出明智的决定，我们就可以从中受益。

当然，主要的好处是减少我们自己重新构建这些系统或者重新发明轮子(或者重新迭代)的需要。当我们将这些常见的任务“外包”给其他开源代码时，我们可以更长时间、更努力地关注任何软件应用最重要的方面:领域。在本书中，我们将经常为 Laravel 开发有用的第三方库和包。

## 工厂

像存储库一样，工厂是领域层的一部分，但不是代表底层业务的模型的一部分。存储库封装了我们持久化模型的方式，而工厂封装了构建或实例化一个对象、一组对象或集合的逻辑。聚合尤其不能被如何创造自己的关注所拖累，就像它们不应该知道如何坚持自己一样。在 DDD，解决这些问题的工具分别是工厂和仓库。

图 [15-1](#Fig1) 提供了一个工厂的视觉效果。

![img/488324_1_En_15_Chapter/488324_1_En_15_Fig1_HTML.jpg](img/488324_1_En_15_Chapter/488324_1_En_15_Fig1_HTML.jpg)

图 15-1

订单工厂示例

在这里，客户端向带有`id`参数的 API 端点(带有 HTTP GET 动词)发送一个请求，该请求被转发给`ApiAdapter`类的`getOrder()`方法，将一些 JSON 编码的数据返回给 API 控制器，然后该控制器调用`OrderFactory::create()`方法，该方法实际上构建了`Order`对象，并最终将其返回给客户端。可能需要调用不止一个`ApiAdapter`来取回正确的数据。例如，在不可能或最初没有包含关系的聚合中(可能在遗留应用上)，`OrderFactory`类会在`Order`对象的创建中包含它们。

在我看来，只有在以下情况下才需要像前面那样的独立工厂:

*   涉及多个模型。

*   因为一些奇怪的原因，关系是不存在的。

一个成熟的`Factory`对象中包含的大部分逻辑通常可以放在聚合根的构造函数方法中，但是也可以作为一个基于聚合根的工厂方法来实现。创建域对象时最大的关注点是真正的业务不变量被恰当地建模，并且以给出域值的实现的方式与域一致。几乎在任何业务或领域模型中，都有前置条件、后置条件和不变量需要保护。工厂可以在这方面提供帮助；然而，我在现实项目中使用的大多数工厂都是工厂方法模式。在使用 Laravel 作为框架时，我个人并没有过多地使用抽象工厂模式。

## ddl 中的聚合

如果我们没有尝试 DDD，我们使用 Laravel 的事实使得创建和使用集合变得相当容易。但是，事实就是如此，试图在 DDD 描述的正常环境和实践中对骨料进行建模会导致整个过程存在一些缺陷。就像任何其他事情一样，拥有一个活动记录模式也是有代价的，因为在一种情况下，你可以使用关系和雄辩提供的所有很酷的东西，但在另一种情况下，我们实际上永远无法将模型从基础设施中分离出来。我试图向您证明，在现实世界的开发过程中，这种耦合是值得的，因为我们经常会因为“只要完成它”的心态而点燃导火索。我们仍将设计聚合，但我们的版本将在许多方面略有不同，这允许在 Laravel 和口才中有更好的“流动”或进展，因为主干将被证明是非常有用的。

### 设计骨料时

您可以采用一些简单的规则，使系统中聚合的设计和实现更容易、更简化。

#### 围绕真正的业务不变量进行设计聚合

只有在帮助解决领域模型中的特定业务问题时，聚合才是有用的，这通常涉及保护领域模型对象的一些不变量。在采购订单汇总中，可能有一个基本的业务规则，它规定一个 PO 中至少应该有一个行项目，以便能够被会计部门批准。这将是一个业务不变量，应该在聚合中的某个地方建模为一个明确的概念，我们将在本章中看到一个例子。必须在采购订单聚合中建模的另一个可能的不变量可能是一个最大允许金额，如果要获得批准，PO 中的行项目的总和必须保持在该金额之下。系统中的不变量需要在数据库和应用中保持对象的有效、一致的顺序。

#### 设计小骨料

较小的聚合比较大的聚合更受青睐，主要是因为跨越较大上下文的较大对象中的对象的复杂性增加了。更困难的是这样一个对象的持久性。因为聚合通常在事务的上下文中持久化，持久化过程的复杂性随着事务执行中涉及的查询越来越多而增加。如果数据库锁定可以防止数据中的不一致，那么系统的多个用户在应用上做同样的事情可能会导致性能影响以及系统的不一致或意外行为。

### 示例聚合

例如，让我们来看一个电子商务应用，它有一个`Order`的概念，这是系统中的一个模型，包含许多`OrderLine`，如果我们要为这样的东西设计一个模型(记住总体设计的基本规则)，我们可以从列出真正的业务不变量开始。

*   一个`Order`必须至少包含一个`OrderLine`实例(没有双关的意思),这样它才能进入结帐过程的下一个阶段(在本例中是计算销售税和将它添加到订单总额中所需的操作)。

*   `Order`模型跟踪总金额，即该订单中所有`OrderLine`实例的总和加上销售税，并将其用于多种用途(例如在用户购物时向用户显示总额，并在结账过程结束时进行金融交易)。这本身不是一个不变量，但这是模型设计的一个因素，导致了一个不变量:一个`Order`必须跟踪总金额，这需要随时更新，因为用户在购物时会看到这个数字。因此，为了保持订单总数的一致性和不断更新，我们必须有一个机制，在每次添加、删除或更新`OrderLine`时执行重新计算。

*   前一个不变量的另一部分包括销售税，它被添加到订单总数中，并在每次更新、删除或创建`OrderLine`时被更新，因为它基于`OrderLine`实例总数的百分比。虽然与前一个相似，但为了更好地分离关注点，我们应该将它建模为`Order`对象上的独立不变量。

#### 将订单模型创建为聚合

让我们给这个例子一个简单的草图。我们将从`Order`模型开始，因为它是集合中最重要的对象。现在，我们将只对订单建模，不使用我们之前列出的不变量(清单 [15-1](#PC1) )。

```php
<?php

namespace Ecommerce\Domain\Models\Orders\Order;

use Illuminate\Database\Eloquent\Model;
use Ecommerce\Domain\Models\{Payment\PaymentId,Shipping\ShippingId, Cart\CartId, Billing\BillingId};

class Order extends Model
{
     protected float $total=0.00;

     protected ShopperId $shopper;
     protected CartId $cartId;
     protected ShippingId $shippingId;
     protected PaymentId $paymentId;

     protected $fillable = ['shopper_id','cart_id','payment_id', 'shipping_id'];

     public function __construct(Shopper $shopper, CartId $cartId, Payment $paymentId=null, ShippingId $shippingId=null)
     {
          parent::__construct();
          $this->shopperId = $shopperId;
          $this->cartId = $cartId;
          $this->billingId = $billingId;
          $this->shippingId = $shippingId;
     }

     public function orderLines()
     {
         return $this->hasMany(OrderLine::class);
     }
}

Listing 15-1An Example Entity Representing an Online E-commerce Order

```

在前面的例子中，我们有一个基本的标准类，它扩展了雄辩的抽象类`Model`。它的构造函数中有许多值对象，对应于一个在线`Order`的不同数据点:订购的购物者的 ID、订单的账单数据的 ID、对应于`Order`的目的地地址的运输模型的 ID，以及用于创建订单的购物车对象的 ID。我们有`billingId`和`shippingId`的默认值，因为直到结账的最后一部分，当用户将它们输入 web 支付表单时，我们才知道它们。此外，我们有一个相关的`OrderLines`对象，它定义了与`Order`模型的`hasMany()`关系。我们在类中还没有任何不变量。我们还使用了`group use`语句，这是 PHP 自版本 7 以来的一个特性。现在，让我们以类似的方式创建我们的`OrderLine`模型(清单 [15-2](#PC2) )。

```php
<?php

namespace Ecommerce\Domain\Models\Orders\Order;

use Illuminate\Database\Eloquent\Model;
use Ecommerce\Domain\Models\{Product\ProductId, Order\OrderId};

class OrderLine extends Model
{
     protected Order $order;
     protected Product $product;
     protected int $quantity;

     protected $fillable = ['product_id', 'orderLineAmount', 'order_id', 'quantity'];

     public function __construct(Product $product, int $quantity, Order $order)
     {
          parent::__construct();
          $this->product = $product;
          $this->quantity = $quantity;
     }

     public function order()
     {
          return $this->belongsTo(Order::class);
     }

     public function product()
     {
          return $this->hasOne(Product::class);
     }
}

Listing 15-2An Example Entity Representing a Single Line Item on the Order Entity

```

示例`OrderLine`类中定义了与`Product`模型、`Order`模型和`quantity`的关系，对应于订单上存在的特定`product`的金额。如果我们像现在这样使用这些类，它可能看起来像这样:

```php
//create order object
$order = new Order($shopperId, $cartId);
//create product object & quantity of that product
$product = Product::find(420);
$quantity = 3;

$orderLine = OrderLine::create($product, $quantity);
$order->orderLine->associate($orderLine);
$order->save();

```

如果您一直在关注本章中描述的聚合的特征，那么您可能已经发现了前面的实现中的一个问题。我们直接访问聚合的内部对象，这不是我们应该创建聚合对象的方式。我们不希望在聚合的边界内直接实例化任何对象，这是我们在前面的代码中明确要做的。

一个好的简单方法是在聚合根上使用一个命名工厂方法，该方法将接受正确定义`OrderLine`对象所需的参数，然后将它与`Order`本身相关联。然而，具体到 DDL 和 concertive，每个扩展抽象`Model`类的模型都将有一个 facade，允许开发人员静态调用它，从而通过任何阻止这种直接实例化的尝试(例如，`OrderLine::create()`总是可以被调用，只要我们是扩展模型)。那么，我们能做的最好的事情就是创建一个命名工厂，适当地记录它，并给开发人员留下注释，表明它应该在任何情况下都被用作实例化`OrderLine`对象的手段。它被称为名为 factory 的*，因为方法的名称对应于被实例化的实体。我们不能使用`$order->orderLine()`方法，因为它已经存在于 concertive 中，允许对与定义它的*相关的*类进行查询。相反，我们选择了`addOrderLine()`。参见清单 [15-3](#PC4) 中的示例。*

```php
<?php

//namespace & use cases

class Order extends Model
{
     //methods and property definitions

     public function addOrderLine(Product $product, int $qty)
     {
          $orderLine = OrderLine::create($product, $qty);
          $this->orderLines()->associate($orderLine);
          $this->save();
     }
}

Listing 15-3Updated Order Class with a Named Factory Method, addOrderLine()

```

现在我们可以使用 aggregate 根类来实例化我们的 aggregate 的内部对象。

```php
$order = new Order($shopperId, $cartId);
$order->addOrderLine($product, $qty);

```

这种方法更适合聚合，并且遵循聚合设计的基本规则，因为我们不再关心实例化一个`OrderLine`对象，用数据填充它，然后将它与客户端 cod 中的`Order`相关联。相反，我们只需要调用`Order`类上的命名工厂，让它处理订单行的设置和保存。然而，在我们的实现中还有另一个违反基本集合设计的地方:持久性。聚合对象应该由数据库事务以“全有或全无”类型的交易来持久化。这样，我们可以确保`Order`对象和它的内部对象是一致的，即使在断电或不相关的系统故障的情况下。这在这里没什么大不了的，因为我们所要做的就是在`Order`模型上延迟`save()`方法(这是在将`OrderLine`关联到`Order`对象之后立即完成的),并将其推迟到结帐之前的步骤。在这个简化的例子中，我们没有过多的要求，假设在我们的领域模型中，只有当用户对订单中的订单行感到满意并点击页面上指定的 Checkout 按钮时,`Order`才准备好付款和发货。一旦点击了这个按钮，就会触发一个事件，告诉事件侦听器和应用一个订单已经准备好可以结账了(我们甚至可以将它建模为一个状态，但不是在这里)。这将通过重新计算增加的销售税和运费的总额来继续该过程。

然后，还有不变量要考虑，这我们还没有做到。为了拯救树(或者眼睛，如果你正在阅读这本书的电子版)，清单 [15-4](#PC6) 展示了解决不变量和解决`Order`集合的事务持久性问题的潜在方法。

```php
<?php

//use cases & namespaces
use Ecommerce\Domain\Models\Orders\OrderStatus;
use Illuminate\Support\Facades\DB;

class Order extends Model
{
    //methods and property definitions
    public $orderLines = [];
    const  TAX_RATE = .10;

    private $status = OrderStatus::ORDER_STARTED;

    /**
    * Invariant #2 & #3 are protected here
    */
    public function addOrderLine(Product $product, int $qty=1)
    {
        $orderLine = new OrderLine($product, $qty);
        $price = $product->price;

        foreach ($qty as $q) {
            $this->total += ($price +
                (static::TAX_RATE * $price));
        }

        $this->orderLines[] = $orderLine;
    }

    /**
     * Invariant #1 is protected here
     */
    public function startCheckout()
    {
        if (!empty($this->orderLines) &&
               (count($this->orderLines) > 0)) {
               //save the order lines within a transaction so we can
               //guarantee the state of the order stays consistent
               DB::transaction(function() {
                    foreach ($this->orderLines as $orderLine) {
                       $this->associate($orderLine);
                }
                $this->save();
            });
            /*start checkout process with a job or service.
            In theory, this would also change the status of the
            Order to something like OrderStatus::CHECKOUT_STARTED*/
            }

            return new JsonResponse("Order must have at least one Order Line before Checkout can begin", 500);
     }
}

Listing 15-4Updated Order Class, with Invariant Protection Included

```

在清单 [15-4](#PC6) 的例子中，我们有一个相当简单的类，该类有一个声明为静态常量的`TAX_RATE`变量，它是以十进制形式表示的，每当有新的`OrderLine`添加到订单中时，我们必须添加到订单总数中的税额。当我们向订单中添加产品时，不是创建并持久化一个新的`OrderLine`对象(这是`OrderLine`对象上的 facade 方法`orderLines`所做的)，而是简单地将它们存储在一个数组中供以后处理。这个简单的变化将允许我们推迟真正向表中写入单独的订单，直到最后，当用户完成购物并且`Order`进入应用的结帐部分。只有在那时，我们才真正使用雄辩的门面方法`associate()`将`OrderLine`实例推送到`Order`对象，该方法处理多对多关系的持久性。此时，我们才调用 save 方法，正式将记录写入`orders`和`order_lines`表，并结束应用的订购部分。这一部分是在该类的`startCheckout()`方法中完成的，该方法在向前移动之前检查以确保在`orderLines`数组中至少有一个项目。还有一个`$status`类成员变量，用于跟踪`Order`对象的正确状态。在结帐过程开始时，该状态可能会发生变化，以表明发生了状态转换，如果需要告诉应用的其余部分发生了这种情况，则很可能会在该过程中引发一些事件(可能会将订单存储在某种缓存中，以防用户决定离开该页面，该页面会在用户稍后返回站点时重新加载订单)。我们在一个事务中调用 store `orderLines`和订单本身，这样我们可以保持数据库的完整性。

我们可以选择在域层的某些服务中进行这种计算，但是这些操作非常接近根模型(聚合根)，在本例中是`Order`模型，因此在模型中进行操作是有意义的。这部分是因为如果我们将逻辑放在服务中，我们将为流程的发生建立一个隐含的依赖关系，因为开发人员将永远记住调用该服务，而不仅仅是用雄辩的手动操作(使用雄辩的外观非常容易)。通过约束和保护模型上的不变量，我们可以轻松地将订单行保存在事务范围内，确保不会将任何内容保存到事务之外的数据库中，并且只在订单的结帐阶段开始时执行。

这个版本更加圆滑，并且有更好的关注点分离。例如，我们不再需要用`OrderLine`对象的概念来关注客户端代码。我们所要做的就是传递`OrderLine`类的构造函数需要的参数，但是客户端代码并不知道这一点！它只需提供已经可用的数据(即产品和数量)。另一件要注意的事情是，我们已经从产品中去除了任何销售税的概念，让它完全在`Order`类中处理，这很容易通过修改`TAX_RATE`常量的值来改变。这在`OrderLine`对象中创建了更少的数据。我们可以对这段代码做的一个升级是进一步将这个功能从`startCheckout()`方法中的其余逻辑中分离出来，但这不是必需的。

清单 [15-5](#PC7) 提供了一个可能的使用示例。

```php
<?php

//create order object
$order = new Order($shopperId, $cartId);

//create product object & quantity of that product
$product = Product::find(420);
$quantity = 3;

//we no longer have to worry about the orderLine object at all!
//instead, we just pass in the data we already have...
$order->addOrderLine($product, $qty);
$order->addOrderLine($product2, $qty2);
$order->addOrderLine($product3, $qty3);

//user clicks on the "Checkout" button:
if ($order->startCheckout()) {
     dispatch(new RunCheckout($order));
} else {
     //return some response indicating to the frontend the issue,
     //which would presumably display a notification to the user
}

Listing 15-5Usage Example (Client Code) for the Previous Implementation

```

另外需要注意的是，因为我们将`OrderLine`的概念封装在一个聚合中，所以对`OrderLine`对象*的任何访问都必须通过`Order`聚合根*来完成。如果我们仔细想想，这非常有意义，因为没有必要或要求在`Order`类之外修改`OrderLine`。所有的`OrderLine`实例都属于一个`Order`，这就是为什么我们将`Order`类作为聚合根。理解了这一点，如果我们想要更新一个`OrderLine`的数量、替换一个`OrderLine`或者完全删除它，我们就需要在那个聚合根上添加方法。这意味着额外的代码，如清单 [15-6](#PC8) 所示。

```php
<?php
//namespace & use statements

class Order extends Model
{
     //properties and method definitions

     /**
     * @param $sequence : The location of the order line in the array
     */
     public function removeOrderLine($sequence)
     {
          if (isset($this->orderLines[$sequence])) {
               unset ($this->orderLines[$sequence]));
          }
     }

     public function updateQuantity($sequence, $newQuantity)
     {
          if (isset($this->orderLines[$sequence])) {
               //get the product that corresponds to that order line:
               $product = $this->orderLines[$sequence]->product;
               //remove the orderLine completely from the array:
               unset($this->orderLines[$sequence]);
               //add the new orderLine to the array:
               $this->addOrderLine($product, $newQuantity);
          }
     }

}

Listing 15-6Additional Methods for the Order Class Needed to Modify Existing OrderLines

```

在清单 [15-6](#PC8) 中，我们有两个额外的方法，一个更新订单行的数量，另一个删除订单行。这看起来相当不错；然而，它缺少了一个重要的部分，这将使整个系统无法使用。你能指出我们忘记包括的是什么吗？

总金额！通过更改订单行的数量或删除一个订单行，我们基本上需要更新订单的总金额(包括为每个订单添加的税)。请记住，对于这个示例状态中列出的不变量，订单的数量需要随时更新，因此我们需要再次修改`Order`类以包含该逻辑(清单 [15-7](#PC9) )。

```php
<?php

//namespace & use statements

class Order extends Model
{
     //properties and method definitions

     /**
     * @param $sequence : The location of the order line in the array
     */
     public function removeOrderLine($sequence)
     {
          if (isset($this->orderLines[$sequence])) {
               $orderLine = $this->orderLines[$sequence];
               $totalAmountDelta = $orderLine->product->price +
                    ($orderLine->product->price * static::TAX_RATE);
               $this->total -= $totalAmountDelta;
               unset ($this->orderLines[$sequence]));
          }
     }

     public function updateQuantity($sequence, $newQuantity)
     {

          if (isset($this->orderLines[$sequence])) {
               //get the product that corresponds to that order line:
               $orderLine = $this->orderLines[$sequence];
               $product = $orderLine->product;
               //remove the orderLine completely from the array:
               $totalAmountDelta = $product->price + ($product->price
                    * static::TAX_RATE);
               $this->amount -= $totalAmountDelta;
               unset($this->orderLines[$sequence]);
               //we dont have to worry about adding the product's
               //tax because that logic is already in addOrderLine():
               $this->addOrderLine($product, $newQuantity);
          }
     }
}

Listing 15-7Additional Methods for the Order Class Needed to Modify Existing OrderLines

```

这样看起来更好！现在，每次使用`Order`作为聚合根对`OrderLine`进行更改时，我们都会更新总金额，并且在`OrderLine`中，每个产品包含的销售税也是不变的。

这里仍然有一个疏忽。聚合根应该有一个全局可访问的身份——它们确实有——并且有一个围绕其他模型的边界。此外，它们中的每一个都应该只能从聚合根访问，而不能从全局上下文访问，这很难停止，但通过聚合根上的命名工厂方法变得显而易见，这就是我们最初在清单 [15-3](#PC4) 中所做的。我们利用了`Order`类上的一个工厂方法来创建各种`LineOrder`对象，这些对象需要用来表示现实生活中`Order`的各个方面(这是建模的定义)。然而，我们很快发现这种方法缺少一些我们必须拥有的东西，以确保`Order` aggregate: transactions 中的数据一致性。我们从`addOrderLine()`方法中移除了对`associate()`和`save()`的调用，并使用一个原始数组来保存非持久化的`OrderLine`对象(并且与`Order`无关)。然后，在结帐时，我们将实体持久化到数据库的实际代码放在`startCheckout()`方法中，使用一个事务来确保不同目标表的记录的一致性，将转换后的模型写入这些表。

### 活动采购

事件源是一个大而深的主题，我不会在本章中深入讨论，但在本书的后面，我们将通过一个简单的场景，使用 Laravel 的包 EventSauce ( [`https://eventsauce.io/`](https://eventsauce.io/) )使用事件源建模。它是高度可定制的，并为您提供了定制其行为方式的几乎每个方面的灵活性，以满足您的需求。一般来说，事件源是一个极其复杂的考验，大多数 web 应用项目都不推荐使用它，因为向现有应用添加事件源或基于事件源启动一个新的应用需要原始开销和技术诀窍。如同生活中的任何事情一样，事件采购也伴随着取舍。大多数应用不需要事件源提供的复杂程度。当您面临以下问题时，应该使用它:

*   在领域模型中跟踪实体生命周期中的每一个变化的需求

*   需要对您的模型执行审计

*   需要一个异步解决方案来处理各种数据和服务的大量请求

*   当需要在聚合系统中使用事务来保持数据库和应用中的数据一致时

## 结论

在本章的开始，我们介绍了一些事务的基本理论，它们是如何使用的，以及它们如何帮助保持数据库中的数据一致，并确保数据库的更新是以原子的方式完成的。事务是持久化聚合中涉及的基本概念。可以用缩写 ACID 来记住事务的特征，ACID 代表原子性、并发性、隔离性和持久性。

我们讨论了集合对象和对象工厂的特征。大多数时候，一个工厂方法实际上是使一个集合设计工作及其所有不变的检查和平衡所需要的。聚合基本上是一个边界，其中包含了封装在所谓的聚合根后面的几个不同的模型类。聚合根是“预先”模型，任何访问聚合内部对象的请求都必须经过这个模型。我们需要小心不要直接访问内部对象，尽管实际上这是无法避免的。我们可以通过在聚合根上提供方便的方法来减轻这一点，这些方法将为我们处理访问或修改内部对象，从而保持聚合根中包含的不变量和业务规则。这在高层次上是有意义的，因为我们不需要直接访问聚合的内部部分，而是依赖于聚合根模型中的操作。

我们看了一个可能的聚合的例子，`Order`聚合，在其聚合边界内有一个内部的`OrderLine`对象和一个充当聚合根的`Order`对象。工厂帮助我们保持边界完整，并且通常聚合应该只在必要的地方使用，因为它们会导致用于对域建模的代码的开销和维护的增加，以及增加不必要的复杂性，这会将注意力从域模型转移到使聚合在应用的其余部分工作上，或者甚至将聚合保存在数据库中。复杂的应用值得使用聚合和事件源。