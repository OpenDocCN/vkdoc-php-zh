# 9.弱映射

日期:2019-11-04

作者:尼基塔·波波夫

票数:25 票/ 0 票

弱地图不仅仅是孩子们用来描述 MapQuest 的。它们必须处理垃圾收集和内存管理。我们先来看看什么是弱引用。弱引用用于引用符合垃圾回收条件的对象。垃圾收集发生在不再有引用指向它们的对象上。弱映射是弱引用的集合，它不会阻止对象上的垃圾收集，并且在对象被移除后也会被释放。已经有`SplObjectStorage`允许创建从对象到任意值的贴图，但这与弱贴图不同。稍后将对此进行更多介绍。现在，我已经在互联网上搜索了一些例子(有好几个例子)来证明这一点。这些情况绝对是一次性的。这是一个大多数开发人员很可能不会使用的特性，但是了解您的选择将使您成为顶级的编码人员。

所以，这怎么不像`SplObjectStorage`？很高兴你问了。波波夫在 RFC 中指出了多重原因。首先，`spl_object_id()`值不会消失，在对象被销毁后会被重用。多个对象可以在不同时间拥有相同的对象 ID。第二，没有从对象 ID 到对象的反向标识，因此防止了映射上的迭代。最后，销毁对象不会释放 ID 下的存储值。

弱引用是在 PHP 7.4 中引入的，与 PHP 8 的弱映射相似，但有一些不同。弱映射可以被克隆，而弱引用不能，因为对象是唯一的。当使用非对象键`$map[$key]`或`offset*()`方法时，弱映射中会出现类型错误异常。类似地，使用`$map[]`添加到弱映射或读取不存在的键会导致错误异常。也支持弱映射的引用迭代。弱引用和弱映射的相似之处在于，它们都是不可序列化的，并且禁止对它们设置动态属性。波波夫谈到了连载(或缺乏连载)。

> 您能提供一些背景信息，说明为什么您认为 WeakMap 的序列化支持很重要吗？由于弱映射本质上是缓存结构，序列化它们似乎并不是特别有用，但是当结合序列化可能具有的非常不直观的行为时，我觉得最好将此留给用户(与 WeakReference 相同)。

> *具体来说，我所说的无效是指:当你执行* `$s = serialize($weakMap)` *时，你会得到一个大的有效载荷字符串，但是当你试图执行* `unserialize($s)` *时，你会得到一个空的 WeakMap(或者更糟:一个弱 Map，它只会在下一次 GC 时变空)，因为一旦取消序列化完成，所有这些对象都会被删除。这“有效”，但似乎并不十分有用，而且很可能成为一个 wtf 时刻*。
> 
> *—Nikita Popov*

这是一个`WeakMap`类的样子。

```php
$map = new WeakMap;
$obj = new stdClass;
$map[$obj] = 311;
var_dump($map);
// object(WeakMap)#1 (1) {
//   [0]=>
//   array(2) {
//     ["key"]=>
//     object(stdClass)#2 (0) {
//     }
//     ["value"]=>
//     int(311)
//   }
// }

// The key is removed from the map once the object is deleted.
unset($obj);
var_dump($map);
// object(WeakMap)#1 (0) {
// }

```