# 7.什么是设计模式？为什么使用它们？

我们作为程序员遇到的大多数问题已经被我们社区中的其他人一次又一次地处理过了。设计模式可以为我们提供挖掘智慧的方法。一旦一个模式成为一种通用货币，它就丰富了我们的语言，使得分享设计思想及其结果变得容易。设计模式只是提取常见问题，定义经过测试的解决方案，并描述可能的结果。许多书籍和文章关注计算机语言的细节，比如可用的函数、类和方法等等。相反，模式目录关注的是如何从这些基础(“什么”)转移到对项目中的问题和潜在解决方案的理解(“为什么”和“如何”)。

在这一章中，我将向你介绍设计模式，并看看它们流行的一些原因。本章将涵盖以下内容:

*   *模式基础*:什么是设计模式？

*   *模式结构*:一个设计模式的关键元素是什么？

*   *模式的好处*:为什么模式值得你花时间？

## 什么是设计模式？

> 在软件世界中，模式是组织部落记忆的有形表现。
> 
> ——格雷迪·布奇在*核心 J2EE 模式*

> *【模式是】在一个上下文中对一个问题的解决方案。*
> 
> *—四人帮，设计模式:可重用面向对象软件的要素*

正如这些引文所暗示的，设计模式提供了对特定问题的分析，并描述了解决该问题的良好实践。

问题往往会反复出现，作为 web 程序员，我们必须一次又一次地解决它们。我们应该如何处理传入的请求？我们如何将这些数据转化为我们系统的指令？我们应该如何获取数据？呈现结果？随着时间的推移，我们以或多或少的优雅程度回答了这些问题，并发展出一套我们在项目中使用和重用的非正式技术。这些技术是设计的模式。

设计模式记录并形式化了这些问题和解决方案，使得来之不易的经验可以为更广泛的编程社区所用。模式本质上是(或者应该是)自底向上的，而不是自顶向下的。它们植根于实践，而不是理论。这并不是说设计模式没有很强的理论元素(我们将在下一章看到)，但是模式是基于真正的程序员使用的真实技术的。著名的模式孵化者马丁·福勒说他发现了模式；他没有发明它们。由于这个原因，当你意识到你自己使用的技术时，许多模式会产生一种似曾相识的感觉。

模式目录不是食谱。菜谱可以照单全收；代码可以复制并插入到项目中，只需稍作修改。你甚至不总是需要理解食谱中使用的所有代码。设计模式记录了解决特定问题的方法。根据更广泛的背景，实现的细节可能有很大的不同。这种环境可能包括您正在使用的编程语言、应用的性质、项目的规模以及问题的具体情况。

比方说，你的项目要求你创建一个模板系统。给定模板文件的名称，您必须解析它并构建一个对象树来表示您遇到的标签。

首先使用默认解析器扫描文本中的触发器标记。当它找到一个匹配时，它把寻找的责任交给另一个解析器对象，这个解析器对象专门用于读取标签的内部信息。这将继续检查模板数据，直到失败、完成或找到另一个触发器。如果它找到了一个触发器，它也必须把责任交给一个专家——也许是一个参数解析器。总的来说，这些组件形成了所谓的递归下降解析器。

这些是你的参与者:一个`MainParser`、一个`TagParser`和一个`ArgumentParser`。您创建一个`ParserFactory`类来创建和返回这些对象。

当然，没有一件事是容易的，在游戏后期你会被告知你必须在你的模板中支持不止一种语法。现在，您需要根据语法创建一组并行的解析器:一个`OtherTagParser`，一个`OtherArgumentParser`，等等。

这是您的问题:您需要根据环境生成一组不同的对象，并且您希望这对系统中的其他组件或多或少是透明的。恰好四人组在他们的书《模式抽象工厂》的总结页中定义了以下问题，“提供一个接口来创建相关或依赖对象的系列，而不指定它们的具体类。”

那非常合适。正是我们问题的本质决定并塑造了我们对这种模式的使用。正如你在第 [9](09.html) 章中看到的，这个解决方案也没有任何剪切和粘贴的成分，在这一章中我讨论了抽象工厂。

命名一个模式的行为本身就是有价值的；它有助于在古老的工艺和职业中自然出现的那种通用词汇。这种简写极大地帮助了协作设计，因为替代方法和它们的各种结果被权衡和测试。例如，当您讨论备选的解析器系列时，您可以简单地告诉同事，系统使用抽象工厂模式创建每组对象。他们会明智地点头，要么立刻明白过来，要么记下来以后再查。关键是这一堆概念和结果有一个句柄，这是一个有用的简写，我将在本章后面说明。

最后，根据国际法，写关于模式的文章而不引用 Christopher Alexander 是非法的，他是一位建筑学者，他的工作对最初的面向对象模式倡导者产生了重大影响。他在*中陈述了一种模式语言*(牛津大学出版社，1977 年):

> 每个模式都描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，这样你就可以使用这个解决方案一百万次，而不必以同样的方式做两次。

重要的是，这个定义(适用于架构问题和解决方案)从问题及其更广泛的背景开始，然后发展到解决方案。近年来有一些批评说设计模式被过度使用了，尤其是被没有经验的程序员使用。这通常是一个信号，表明在问题和背景不存在的地方已经应用了解决方案。模式不仅仅是以特定方式合作的类和对象的特定组织。模式的结构定义了解决方案应该应用的条件，并讨论了解决方案的效果。

在本书中，我将关注模式领域中一个特别有影响力的分支:四人组(Addison-Wesley Professional，1995)在*Design Patterns:Elements of Reusable Object-Oriented Software*中描述的形式。它专注于面向对象软件开发中的模式，并记录了大多数现代面向对象项目中出现的一些经典模式。

《四人帮》这本书很重要，因为它记录了关键模式，并且描述了指导和激励这些模式的设计原则。我们将在下一章探讨其中的一些原则。

Note

四人帮和本书中描述的模式实际上是模式语言的实例。模式语言是组织在一起的问题和解决方案的目录，因此它们相互补充，形成一个相互关联的整体。还有其他问题空间的模式语言，比如视觉设计和项目管理(当然还有架构)。当我在这里讨论设计模式时，我指的是面向对象软件开发中的问题和解决方案。

## 设计模式概述

本质上，设计模式由四部分组成:名称、问题、解决方案和后果。

### 名字

名字很重要。它们丰富了程序员的语言；几个简短的词可以代表相当复杂的问题和解决方案。他们必须平衡简洁和描述。四人组声称，“找到好名字是开发我们目录最困难的部分之一。”

Martin Fowler 同意:“模式名称至关重要，因为模式的部分目的是创建一个允许开发人员更有效地交流的词汇表”(*企业应用架构的模式*，Addison-Wesley Professional，2002)。

在企业应用架构的*模式*中，Martin Fowler 提炼了我在 Deepak Alur、Dan Malks 和 John Crupi (Prentice Hall，2001)的*核心 J2EE 模式*中首次遇到的数据库访问模式。Fowler 定义了两种模式来描述旧模式的专门化。他的方法的逻辑显然是正确的(一个新模式建模领域对象，而另一个建模数据库表，这种区别在早期的工作中是模糊的)。然而，很难训练自己用新的模式来思考。我在设计会议和文档中使用原作的名字已经很久了，它已经成为我语言的一部分。

### 问题

无论解决方案多么优雅(有些确实非常优雅)，问题及其背景都是模式的基础。识别问题比应用模式目录中的任何一个解决方案都要困难。这是一些模式解决方案可能被误用或过度使用的一个原因。

模式非常小心地描述了一个问题空间。对问题进行简要描述，然后结合上下文，通常有一个典型的例子和一个或多个图表。它被分解成它的细节，它的各种表现。描述了可能有助于识别问题的任何警告信号。

### 解决方案

结合问题对解决方案进行初步总结。它也被详细描述，经常使用 UML 类图和交互图。该模式通常包括一个代码示例。

虽然可能会出现代码，但解决方案永远不会是剪切和粘贴。模式描述了解决问题的方法。它的实现可能有成百上千的细微差别。想想播种粮食作物的说明。如果你只是盲目地按照一套步骤去做，到了收获季节，你很可能会挨饿。更有用的是基于模式的方法，它涵盖了可能适用的各种条件。这个问题的基本解决方案(让你的作物生长)总是一样的(准备土壤、播种、灌溉、收获作物)，但是你采取的实际步骤将取决于各种因素，例如你的土壤类型、你的位置、你的土地的方向、当地的害虫等等。

Martin Fowler 将模式中的解决方案称为“半成品”也就是说，编码者必须拿走概念，自己完成。

### 结果

你做出的每一个设计决策都会产生更广泛的影响。这当然应该包括令人满意地解决问题。一个解决方案一旦部署，可能非常适合与其他模式一起工作。也可能有危险需要注意。

## “四人帮”的形式

当我写的时候，我面前的桌子上有五个图案目录。快速看一下每个中的模式，可以确认它们都没有使用相同的结构。有些是正式的；有些是细粒度的，有很多子节；还有一些是散漫的。

有许多定义良好的模式结构，包括由 Christopher Alexander 开发的原始形式(亚历山大形式)和波特兰模式库偏爱的叙述方法(波特兰形式)。因为“四人帮”的书影响如此之大，而且因为我们将涵盖他们描述的许多模式，所以让我们检查一下他们的模式中包括的一些部分:

*   *意图*:模式目的的简要陈述。你应该一眼就能看出图案的要点。

*   *动机*:描述的问题，通常是根据一个典型的情况。轶事方法有助于使模式易于掌握。

*   *适用性*:检查您可能应用模式的不同情况。虽然动机描述了一个典型的问题，但本节定义了具体的情况，并在每种情况下权衡了解决方案的优点。

*   *结构/交互*:这些部分可能包含描述解决方案中的类和对象之间关系的 UML 类和交互图。

*   *实现*:这一部分着眼于解决方案的细节。它分析了应用该技术时可能出现的任何问题，并提供了部署技巧。

*   样本代码:我总是跳到这一节。我发现一个简单的代码示例通常提供了一种进入模式的方法。为了暴露解决方案，这个例子经常被删减到最基本的部分。它可以是任何面向对象的语言。当然，在这本书里，永远是 PHP。

*   *已知用途*:这些描述模式(问题、上下文和解决方案)出现的真实系统。有人说，一个模式要成为真实的，它必须在至少三个公开可用的上下文中找到。这有时被称为“三法则”

*   *相关模式*:一些模式暗示着另一些模式。在应用一个解决方案时，您可以创建另一个解决方案变得有用的环境。本节研究这些协同作用。它还可能讨论与问题或解决方案有相似之处的模式，以及任何先例(即，在当前模式的基础上定义的模式)。

## 为什么要使用设计模式？

那么模式能带来什么好处呢？假设模式是定义的问题和描述的解决方案，答案应该是显而易见的。模式可以帮助你解决常见的问题。当然，模式还不止这些。

### 设计模式定义了一个问题

有多少次你在一个项目中到了一个阶段，发现已经没有前进的方向了？在重新开始之前，你可能必须原路返回。

通过定义常见问题，模式可以帮助您改进设计。有时候，解决问题的第一步是认识到你有问题。

### 设计模式定义了一个解决方案

在定义和识别了问题(并确定它是正确的问题)之后，模式给你提供了一个解决方案，以及对使用它的后果的分析。尽管模式并不能免除你考虑设计决策含义的责任，但你至少可以确定你使用的是一种久经考验的技术。

### 设计模式是独立于语言的

模式用面向对象的术语定义对象和解决方案。这意味着许多模式同样适用于不止一种语言。当我第一次开始使用模式时，我阅读 C++和 Smalltalk 中的代码示例，然后用 Java 部署我的解决方案。其他的随着模式的适用性或结果的修改而转移，但是仍然有效。无论哪种方式，当你在不同语言间转换时，模式都可以帮助你。同样，基于良好的面向对象设计原则构建的应用可以相对容易地在不同语言之间移植(尽管总有一些问题必须解决)。

### 模式定义了词汇表

通过为开发人员提供技术名称，模式使得交流更加丰富。想象一个设计会议。我已经描述了我的抽象工厂解决方案，现在我需要描述我管理系统编译的数据的策略。我向鲍勃描述了我的计划:

*   我:我在考虑使用复合材料。

*   鲍勃:我不认为你已经考虑清楚了。

好吧，鲍勃不同意我的观点。他从来没有。但他知道我在说什么，因此也知道为什么我的想法很糟糕。让我们在没有设计词汇的情况下再次播放那个场景。

*   我打算使用共享相同类型的对象树。该类型的接口将提供用于添加其自身类型的子对象的方法。这样，我们可以在运行时构建实现对象的复杂组合。

*   鲍勃:嗯？

模式，或者它们描述的技术，倾向于互操作。复合模式适合与访问者模式协作，例如:

*   我:然后我们可以用访客来总结数据。

*   鲍勃:你没抓住重点。

忽略鲍勃。我不会描述这个曲折的非模式版本；我将在第 10 章介绍复合材料，在第 11 章[介绍访客。](11.html)

关键是，如果没有模式语言，我们仍然会使用这些技术。他们*先于*他们的命名和组织。如果模式不存在，它们会自己进化。任何被充分使用的工具最终都会获得一个名字。

### 模式是经过试验和测试的

因此，如果模式记录了良好的实践，那么命名是模式目录中唯一真正原创的东西吗？从某种意义上说，这似乎是真的。模式代表了面向对象环境中的最佳实践。对于一些经验丰富的程序员来说，这似乎是对显而易见的东西进行重新包装。对我们其余的人来说，模式提供了解决问题和解决方案的途径，否则我们将不得不艰难地去发现。

模式让设计变得容易理解。随着模式目录出现在越来越多的专业领域，即使是经验丰富的人也可以在进入他们领域的新方面时发现好处。例如，GUI 程序员可以快速访问企业编程中的常见问题和解决方案。一个网络程序员可以快速制定策略，避免平板电脑和智能手机项目中潜伏的陷阱。

### 模式是为协作而设计的

从本质上讲，模式应该是可生成和可组合的。这意味着您应该能够应用一种模式，从而为另一种模式的应用创造条件。换句话说，在使用一个模式时，你可能会发现其他的门为你打开了。

模式目录的设计通常考虑了这种协作，模式组合的潜力总是记录在模式本身中。

### 设计模式促进好的设计

设计模式展示并应用了面向对象设计的原则。因此，对设计模式的研究可以在一个环境中产生比特定解决方案更多的东西。您可以从一个新的角度来看待对象和类的组合方式，以实现一个目标。

### 流行的框架使用设计模式

这本书主要是关于从头开始的设计。这里介绍的模式和原则应该使您能够根据项目的需要设计自己的核心框架。然而，懒惰也是一种美德，你可能希望使用(或者继承已经使用的代码)Zend、Laravel 或 Symfony 等框架。当您使用这些框架 API 时，对核心设计模式的良好理解会对您有所帮助。

## PHP 和设计模式

这一章中很少是专门针对 PHP 的，这在某种程度上是我们主题的特点。许多模式适用于许多支持对象的语言，很少或没有实现问题。

当然，情况并非总是如此。一些企业模式在应用流程在服务器请求之间继续运行的语言中工作得很好。PHP 不是这样工作的。对于每个请求，都会启动一个新的脚本执行。这意味着有些模式需要更加小心地对待。

例如，前端控制器通常需要很长的初始化时间。当初始化在应用启动时发生一次时，这没问题，但是当它必须为每个请求发生时，这就更成问题了。这并不是说我们不能使用模式；我过去部署过它，效果非常好。我们必须确保在讨论模式时考虑到 PHP 相关的问题。PHP 构成了本书所考察的所有模式的背景。

我在本节前面提到了支持对象的语言。你可以不用定义任何类就用 PHP 编码。然而，除了几个明显的例外，对象和面向对象的设计是大多数 PHP 项目和库的核心。

## 摘要

在这一章中，我介绍了设计模式，向您展示了它们的结构(使用四人组的形式)，并提出了一些您可能希望在脚本中使用设计模式的原因。

重要的是要记住，设计模式不是可以像组件一样组合起来构建项目的嵌入式解决方案。它们是解决常见问题的建议方法。这些解决方案体现了一些关键的设计原则。这就是我们将在下一章探讨的问题。