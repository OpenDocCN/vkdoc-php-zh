# 5.处理和记录异常

Electronic supplementary material The online version of this chapter (doi:[10.​1007/​978-1-4842-1730-6_​5](http://dx.doi.org/10.1007/978-1-4842-1730-6_5)) contains supplementary material, which is available to authorized users.

一个人的教育直到他死了才算完成——罗伯特·李(引自劳伦斯·J·彼得《彼得语录:我们时代的思想》(1977 年)，第 175 页)

## 章节目标/学生学习成果

完成本章后，学生将能够:

*   解释错误和异常之间的区别
*   创建一个可以处理一般异常的 PHP 程序
*   创建一个可以创建、引发和处理用户异常的 PHP 程序
*   解释并使用`switch`和/或嵌入式`if/else`语句
*   创建一个使用`while`循环和/或`for`循环的 PHP 程序
*   创建一个使用二维数组读取/更新文本文件的程序
*   创建一个 PHP 程序，记录异常并向支持人员发送电子邮件

## 处理异常

作为一名程序员，你想尽一切可能确保你的程序不会崩溃。任何使用你的应用程序的人，如果他们不得不处理系统崩溃，他们的嘴里都会有不好的味道。你可能也处理过这种情况。作为用户，你可能因为差评而选择了一个应用而不是另一个。一旦应用程序被确定为“有问题”，就很难说服客户使用该产品，即使新版本已经纠正了部分或全部问题。必须创建一个应用程序来处理每一个可能的意外事件。

一个程序必须考虑每一种情况，决定它是继续运行还是必须关闭。由于意外事件，应用程序始终有可能无法继续运行。正确开发的程序会让用户知道有问题，而不会导致程序崩溃。当应用程序要求用户“稍后再试”时，用户更容易理解(假设在他们返回网站之前问题已经解决)。

错误是由系统处理的导致程序关闭的程序事件。在某些情况下，系统可以关闭程序并显示错误消息。有些错误会立即导致程序崩溃(比如服务器本身崩溃)。错误通常是超出程序控制的事件，不是由程序中的代码(或缺少代码)直接引起的。例如，内存不足会导致应用程序错误。

异常是不属于程序逻辑正常流程的事件。所有的异常都应该由程序来处理。当应用程序预见到一个问题(一个丢失的文件)或者当用户做了一些不寻常的事情(试图输入无效的信息)时，可以“引发”异常。程序应该“捕捉”所有的异常。然后，它可以检查该异常，并确定是否可以纠正、忽略它，或者是否必须关闭应用程序。如果程序没有捕捉到异常，系统将显示异常消息，然后关闭应用程序。

PHP 会根据具体情况产生错误和异常。在 PHP 5 之前，异常处理是不存在的。因此，一些旧的 PHP 命令产生错误(关闭程序)而不是异常。在 PHP 7 中，异常处理是“规则”。PHP 7 错误可以用异常处理技术来处理。如果程序代码没有处理异常，程序将会像致命错误一样暂停。

任何时候一个应用程序依赖于外部的东西，很可能在某个时候这个动作不会发生。例如，在`Dog`应用程序中，用户需要输入正确的信息。应用程序必须预见到并非所有用户都会输入正确的信息。该应用程序还依赖于服务器上存在的几个文件(`dog_interface`、`dog_container`、`dog_applications`和`get_breeds`)。如果缺少这些文件中的任何一个，应用程序将无法继续正常运行。

大多数面向对象编程语言使用标准格式来处理异常。PHP 的当前版本也使用这种方法。当您在互联网上研究 PHP 示例时，您会发现现有的 PHP 代码不使用这种标准格式。虽然这段代码仍然可以在当前版本的 PHP 中执行，但是建议使用标准技术。标准方法使用`try-catch`块。

`try {`

`// code that might cause an exception`

`}`

`catch(Exception $e) {`

`// code that executes if there is an exception`

`}`

catch(错误$e) {

`// PHP 7+ capture and handle errors`

`}`

任何可能导致异常的代码都应该包含在`try`块中。此外，您可能还想考虑在`try`块中放置其他条件(比如数学计算)。

`try {`

`$result = $firstNumber / $secondNumber;`

`}`

`catch(Exception $e) {`

`// code that executes if there is an exception`

`}`

catch(错误$e) {

`// PHP 7+ capture and handle errors`

`}`

如果`$secondNumber`包含一个零(除以零)，这个例子可能会产生一个异常。如果异常发生，代码将跳转到`catch`块。然后将执行块中的任何代码。语句`$e->getMessage();`将显示任何与异常相关的系统消息(在本例中，是关于试图被零除的消息)。但是，您不必使用系统消息；您可以使用`echo`或`print`向用户显示信息。

`try {`

`$result = $firstNumber /$secondNumber;`

`}`

`catch(Exception $e) {`

`echo "You entered zero for the second number. Your entry must be greater than zero";`

`}`

然而，这些例子有一个问题。如果您试图在`try`块中捕获多种类型的异常，所有异常都将进入一个`catch`块。任何异常都会显示相同的消息。有几种不同的方法可以解决这个问题。

一种方法是抛出自己的异常，而不是让系统抛出。

`try {`

`if ($secondNumber == 0)`

`{ throw new Exception("Zero Exception"); }`

`else { $result = $firstnumber / $secondnumber; }`

`// other code with exceptions }`

`catch(Exception $e) {`

`switch ($e->getMessage()) {`

`case "Zero Exception":`

`echo "The value of second number must be greater than zero";`

`break;`

`case "Some other exception":`

`echo "You did something else wrong";`

`break;`

`default:`

`echo $e->getMessage();`

`}`

> Precautions for programming-In addition to the `getMessage` method, the `Exception` and `Error` objects also include: `getCode()`-displaying the code causing the exception `getFile()`-displaying the file name containing the code causing the exception `getLine()`-displaying the line numbers `getTrace()` and `getTraceAsString()` causing the exception-displaying the backtracking (exception flowing through the program) information, and in some cases, displaying it to the user. However, other methods should only be used for debugging or log entries. Providing code information to users is usually unnecessary and violates security.

在这个例子中，在`catch`块中使用了一个`switch`语句来查看所有可能的异常消息。一条`switch`语句与一条嵌入式`if`语句完成相同的任务。你可以使用:

`If($e->getMessage == "Zero Exception")`

`{ echo "The value of second number must be greater than zero"; }`

`else if($e->getMessage == "Some other exception")`

`{ echo "You did something else wrong"; }`

`else`

`{ echo $e->getMessage(); }`

对于某些人来说，当查看同一个属性(变量)的多个可能值或执行方法的结果时,`switch`语句更容易理解(如本例所示)。`switch`语句的默认部分(或者嵌入式`if`语句中的最后一个`else`语句)捕捉任何您没有预料到的内容。在本例中，您只需显示其他异常的异常消息。

如前所述，处理所有异常和错误非常重要。通过包含默认代码，您能够处理您可能从未预料到的异常和错误。注意，每个`case`部分必须包含一个`break`作为最后一条语句。这阻止了代码进入下一个`case`语句。

`Catch(Exception $e) {`

`switch($e->getMessage()) {`

`case "Zero Exception":`

`echo "The value of second number must be greater than zero";`

`case "Some other exception":`

`echo "You did something else wrong";`

`break;`

`default:`

`echo $e->getMessage():`

`}`

在本例中，如果发生了`Zero Exception`，将显示消息`("The value of the second number must be greater than zero"`和`You did something else wrong"`。`switch`语句的使用在`catch`块中很常见。然而，如前所述，如果您愿意，可以使用嵌入式的`if`语句。

处理多个异常的另一种方法是创建自己的异常，抛出它们，然后捕获它们。您需要为自己的异常创建一个类。

`class zeroException extends Exception {`

`public function errorMessage() {`

`$errorMessage = "Second Number cannot be " . $this->getMessage();`

`return $errorMessage;`

`}`

`}`

`try {`

`if ($secondNumber == 0)`

`{ throw new zeroException("Zero"); }`

`else`

`{ $result = $firstnumber / $secondnumber; }`

`// other code with exceptions }`

`catch(zeroException $e) {`

`echo $e->errorMessage();`

`}`

`catch(Exception $e) {`

`Echo $e->getMessage();`

`}`

`zeroException`类扩展了`Exception`类。`extends`关键字用于继承`Exception`类的所有功能。继承是面向对象编程的另一个关键组件(还有封装和多态)。一个子类(比如`zeroException`)可以继承其父类(`Exception`)的所有属性和方法。然后，子类可以添加特定于该类的方法(比如函数`errorMessage`)。由于`zeroException`继承了`Exception`，它被视为与任何其他异常相同。`zeroException`可以被抛出(抛出新的`zeroException("Zero"))`并且可以被抓住(`catch(zeroException $e)`)。

> Program notes-exception classes created by programmers inherit from `Exception`. Therefore, all functions of the `Exception` class are available in any new exception class. `Class zeroException extends Exception { }` The previous code created an effective new `zeroException` class with no new method. `catch(zeroException $e) { echo $e->getMessage(); }` This `catch` block will be called by a new exception, and the exception message generated by the `Exception` class will be displayed.

对于创建和抛出的每个异常或错误类，必须有一个`catch`块来捕捉异常或错误。在这个例子中，有两个 catch 块；一个捕捉`zeroException`，另一个捕捉任何其他可能发生的异常。就像前面使用`switch`默认或`if else`语句的例子一样，您应该总是让最后的`catch`块处理任何剩余的异常或错误。如果通用`catch`模块首先列出，所有异常将被该模块捕获，而不是该异常的特定模块。

如上所述，开发人员应该尽一切努力防止应用程序崩溃。然而，错误是用来显示消息和关闭带有错误代码的程序(您认为是“崩溃”程序)。在 PHP 7 之前，在某些情况下，您可以通过创建一个处理错误的方法来覆盖这个功能。

`function errorHandler($severity, $message, $file, $line) {`

`throw new errorException($message, 0, $severity, $file, $line); }`

`set_error_handler('errorHandler');`

`// set_error_handler() doesn’t work with all fatal errors, some can’t be thrown as Exceptions.`

`try { trigger_error( "User Error", E_USER_ERROR);`

`}`

`catch(errorException $e)`

`{ echo $e->getMessage(); }`

`catch(Exception $e)`

`{ echo $e->getMessage(); }`

`// Code placed here would execute after an error with this handler. It would not execute if`

`// there was not a handler.`

在这个例子中，`set_error_handler`方法将所有错误(可以被重定向)重定向到方法`errorHandler`。当方法`trigger_error`导致`E_USER_ERROR`发生时，错误的处理被重定向到`errorHandler`方法。然后，这个方法从错误中收集信息，抛出一个异常(`errorException`)。该异常由`catch(errorException $e)`方法捕获，这将导致显示消息`"User Error"`。

在 PHP 7 中，Error 对象捕获潜在的系统错误作为异常。

`try {`

call _ method(null)；//没有这样的方法！

`} catch (Error $e)`

`{ echo $e->getMessage; }`

以前，调用不存在的函数会导致致命错误。使用`EngineException`对象允许程序员处理错误。前面显示的例子(在 PHP 7 之前)只能捕获一些错误；这项新技术旨在让程序员对错误有更多的控制。如果不包括这个`catch`块，任何“错误”都会导致程序因`"Fatal error: Uncaught exception"`消息而崩溃。

如果你安装了 PHP 7，使用新的`Error`对象和`Exception`对象来尽可能避免致命错误。

安全性和性能——通常使用抛出和捕获异常可以减少程序所需的代码量。然而，有一个权衡。对不同面向对象编程语言的几项研究得出结论，异常处理比使用开发人员创建的例程效率(性能)低。开发人员应该使用异常作为应用程序正常流程的真正“异常”。对于更频繁发生的情况，开发人员应该在应用程序中创建情况处理例程。

![A978-1-4842-1730-6_5_Fig1_HTML.jpg](A978-1-4842-1730-6_5_Fig1_HTML.jpg)

图 5-1。

Data flow for the dog application

在`Dog`应用程序中，信息在许多不同的程序之间流动。这些程序中的每一个都必须能够正确地处理异常。然而，消息处理应该全部发生在接口中。任何属于业务规则层的对象(`dog_container`、`dog`和`get_breeds`)都应该将任何异常消息传递给接口进行处理。起初，这听起来像是一项复杂而令人困惑的任务。然而，异常处理的层次结构将大大简化这项任务。正如您将要看到的，使用异常处理将减少必要的代码量。

当抛出异常时，环境会查看程序(或类)本身，以确定是否有一个`catch`块可以处理异常。如果没有一个`catch`块，它将在层次结构中上升一级，并检查任何调用程序(或生成了该类实例的程序)是否有一个`catch`块。这个过程将继续，直到发现一个`catch`块，或者已经确定环境本身必须处理该异常。

使用这个过程，您可以在不使用 catches 的情况下在`dog_container`、dog 和`get_breeds`模块中抛出异常。在`dog_interface`中，您可以围绕对这些文件的调用创建一个`try`块。可以在接口中创建多个`catch`块(或者一个带有`switch`语句的块)来处理来自接口和所有其他模块的异常。这满足了三层编程的要求之一。业务规则层(和数据层)将消息传递给接口层。然后，接口层决定如何处理这些消息。它可以向用户显示它们，将它们放在日志文件中(您将在本章后面看到)，或者忽略它们(如果不会对应用程序的操作产生负面影响的话)。

在更改`Dog`应用程序代码之前，让我们看一个由层次结构处理的异常的例子。

Example 5-1\. testerror.php with error and exception-producing methods

`<?php`

`class testerror {`

`function produceerror() {`

`trigger_error( "User Error", E_USER_ERROR);`

`echo "This line will not display";  }`

`function throwexception() {`

`throw new userException("User Exception");`

`echo "This line will not display";  }  }`

`?>`

Example 5-2\. The handleerror.php file captures error or exception

`<?php`

`function errorHandler($severity, $message, $file, $line) {`

`throw new errorException($message, 0, $severity, $file, $line);`

`}`

`class userException extends Exception { }`

`Set_error_handler(‘errorHandler’);`

`try {`

`require_once(“testerror.php”);`

`$tester = new testerror();`

`$tester->produceerror();`

`echo “This line does not display”;`

`$tester->throwexception(); // will not execute if produceerror() is executed`

`echo “This line does not display”; }`

`catch (errorException $e ){`

`echo $e->getMessage(); }`

`catch (userException $e) {`

`echo $e->getMessage(); }`

`catch (Exception $e) {`

`echo $e->getMessage(); }`

`echo “This line will display”;`

`?>`

`testerror`类(在示例 [5-1](#FPar1) 中)包括一个导致错误的方法(`produceerror`)和一个抛出异常的方法(`throwexception`)。然而，该类没有`try`或`catch`块。它没有能力对可能发生的任何异常或错误做出反应。

`handleerror`程序(例如 [5-2](#FPar2) )包括一个处理用户错误的方法(`errorHandler`)，以及将错误重定向到该方法的`set_error_handler`命令。它还包括一个类(`userException`，当`try`块中抛出`userException`异常时，该类可以做出反应。`require_once`语句包含在`try`块中，试图在文件丢失时捕获错误。但是，这恰好是一个系统错误(不是用户错误)，无法重定向。为了捕获 PHP 7 中的系统错误，Error 类必须在前面所示的`catch`块中使用。

在`require_once`语句之后，创建了一个类`testerror`的实例。如果缺少该类，系统也会显示一条致命消息。这个块调用了`produceerror`方法，这导致了一个用户错误。这个错误被重定向到`errorHandler`，它抛出一个异常(`errorException`)。`catch`模块接收异常并显示错误信息。由于异常不会关闭程序(比如致命错误)，所以在所有`catch`阻塞并执行`echo`语句(`echo "This line will display";`)后，程序流程跳转到第一行。对错误的反应将导致程序跳过`try`块中任何剩余的代码。在这个例子中，`throwexception`方法调用将被忽略。

如果注释掉了`$tester->produceerror()`行，就可以调用`throwexception`方法。方法中抛出了`userException`。`userException`类继承了`Exception`类。`userException`中未包含特殊方法。程序流程将跳转到`userException`的`catch`模块。这个块使用`Exception`类`getMessage`方法来显示消息。在`catch`阻塞并执行`echo "This line will display"`语句后，逻辑跳转到第一行代码。

> Note-`try/catch` can also include a `finally` block after all `catch` blocks. After the relevant `catch` block is executed, `finally` block will be executed for all captured exceptions. PHP allows `finally` blocks without any `catch` blocks to exist (but `try` blocks must still exist). `finally` One of the most common uses of blocks is to close files and/or databases when an exception occurs. Programs should not be closed until files and databases are properly closed. If it is not properly closed, the data may be damaged and inaccessible.

### 做它

Go to the book’s web site and download the files for Examples [5-1](#FPar1) and [5-2](#FPar2). Adjust the `testerror` program to only create an error. Create an additional `testexception` program (with a `testexception` class) to throw an exception. Now adjust the `handleerror` program to create an instance of both programs. The `handleerror` program should now be able to handle errors or exceptions from either program (class).  

## 异常和错误处理与 If/Else 条件

程序员总是可以选择使用第 4 章的[中的`dog`应用文件所示的`If/else`条件语句来处理异常和错误。以这种方式处理错误并没有降低效率(甚至可能更有效率)。但是，您将会发现，如果使用异常处理，业务规则层(和数据层)中的代码的态度会发生变化。当你使用`if/else`语句时，程序流花费了大量时间悲观地为最坏的情况(错误和/或异常)做准备。在许多情况下，通过使用异常处理，大多数业务规则层(和数据层)的编码变得乐观，包括处理程序正常操作的代码。应用程序依靠接口层来处理任何问题。](4.html)

Example 5-3\. The dog.class with exception handling

`<?php`

`class Dog`

`{`

`// ------------------------------------ Properties -----------------------------------------`

`private $dog_weight = 0;`

`private $dog_breed = "no breed";`

`private $dog_color = "no color";`

`private $dog_name = "no name";`

`private $error_message = "??";`

`private $breedxml = "";`

`// ------------------------------------ Constructor ----------------------------------------`

`function __construct($properties_array)`

`{`

`if (method_exists('dog_container', 'create_object')) {`

`$this->breedxml = $properties_array[4];`

`$name_error = $this->set_dog_name($properties_array[0]) == TRUE ? 'TRUE,' : 'FALSE,';`

`$color_error = $this->set_dog_color($properties_array[2]) == TRUE ? 'TRUE,' : 'FALSE,';`

`$weight_error= $this->set_dog_weight($properties_array[3]) == TRUE ? 'TRUE' : 'FALSE';`

`$breed_error = $this->set_dog_breed($properties_array[1]) == TRUE ? 'TRUE,' : 'FALSE,';`

`$this->error_message = $name_error . $breed_error . $color_error . $weight_error;`

`if(stristr($this->error_message, 'FALSE'))`

`{`

`throw new setException($this->error_message);`

`}`

`}`

`else { exit; }`

`}`

`function set_dog_name($value) {`

`$error_message = TRUE;`

`(ctype_alpha($value) && strlen($value) <= 20) ? $this->dog_name = $value : $this->error_message = FALSE;`

`return $this->error_message; }`

`function set_dog_weight($value) {`

`$error_message = TRUE;`

`(ctype_digit($value) && ($value > 0 && $value <= 120)) ? $this->dog_weight = $value : $this->error_message = FALSE;`

`return $this->error_message; }`

`function set_dog_breed($value) {`

`$error_message = TRUE;`

`($this->validator_breed($value) === TRUE) ? $this->dog_breed = $value : $this->error_message = FALSE;`

`return $this->error_message; }`

`function set_dog_color($value) {`

`$error_message = TRUE;`

`(ctype_alpha($value) && strlen($value) <= 15) ? $this->dog_color = $value : $this->error_message = FALSE;`

`return $this->error_message; }`

`// ----------------------------------Get Methods--------------------------------------------`

`function get_dog_name() {`

`return $this->dog_name; }`

`function get_dog_weight() {`

`return $this->dog_weight; }`

`function get_dog_breed() {`

`return $this->dog_breed; }`

`function get_dog_color() {`

`return $this->dog_color; }`

`function get_properties() {`

`return "$this->dog_name,$this->dog_weight,$this->dog_breed,$this->dog_color."; }`

`// ----------------------------------General Method-----------------------------------------`

`private function validator_breed($value)`

`{`

`$breed_file = simplexml:load_file($this->breedxml);`

`$xmlText = $breed_file->asXML();`

`if(stristr($xmlText, $value) === FALSE)`

`{`

`return FALSE;`

`}`

`else`

`{`

`return TRUE;`

`}`

`}`

`}`

`?>`

将示例 [4-8](4.html#FPar11) 与示例 [5-3](#FPar3) 进行比较，您会注意到代码中仅有几处细微的变化。`__toString`方法已经被移除，取而代之的是一个`if`语句，它检查`FALSE`是否存在于`error_message`字符串中。如果确实存在，就会产生一条`setException`消息，将`error_message`字符串传递给异常处理程序。这导致了整个应用程序流程的逻辑变化。代替`dog_interface`程序(在例子 [4-12](4.html#FPar15) 中)通过调用`__toString`方法检查用户输入错误，当用户错误发生时`Dog`类通知`dog_interface`(通过抛出的异常)。以前，接口必须从`Dog`类中提取错误。在这个例子中，`Dog`类将错误推送到接口类。正如您将看到的，这将从`dog_interface`程序中消除代码，因为它不再需要询问是否有任何错误。

> And security-the `__toString` method "exposes" anything it returns to any program, which creates an instance of its class. Passing error messages in this way may allow hackers to determine what incorrect messages they sent to the program. In the [example in Chapter 4, `__toString` returns the `error_message` string containing `'TRUE'` or `'FALSE'` responses. This is safer than returning an error message. However, you can provide better security by throwing a special exception instead of the `__toString` method. Hackers must now know not only what `error_message` means, but also the name of this exception (`setException`) in order to catch it in their own programs.](4.html)

Example 5-4\. The getbreeds.class with exception handling

`<?php`

`class GetBreeds {`

`function __construct($properties_array) {`

`if (!(method_exists('dog_container', 'create_object')))`

`{ exit; }`

`}`

`private $result = "??";`

`public function get_select($dog_app)`

`{`

`if (($dog_app != FALSE) && ( file_exists($dog_app)))`

`{`

`$breed_file = simplexml:load_file($dog_app);`

`$xmlText = $breed_file->asXML();`

`$this->result = "<select name='dog_breed' id='dog_breed'>";`

`$this->result = $this->result . "<option value='-1' selected>Select a dog breed</option>";`

`foreach ($breed_file->children() as $name => $value)`

`{`

`$this->result = $this->result . "<option value='$value'>$value</option>";`

`}`

`$this->result = $this->result . "</select>";`

`return $this->result;`

`}`

`else`

`{`

`throw new Exception("Breed xml file missing or corrupt");`

`}`

`}`

`}`

`?>`

将先前的`GetBreeds`类(在示例 [4-11](4.html#FPar14) 中)与示例 [5-4](#FPar4) 进行比较，仅显示一处变化。它返回`'FALSE'`并抛出一个一般异常，表明`breed.xml`文件丢失或损坏。同样，`GetBreeds`类将任何异常推送到接口。接口不再需要确定是否有任何异常。尽管丢失文件错误不能被重定向为异常处理，但是如果文件丢失，代码使用`file_exists`抛出异常。

Example 5-5\. The dog_container.php file with exception handling

`<?php`

`class dog_container`

`{`

`private $app;`

`private $dog_location;`

`function __construct($value) {`

`if (function_exists('clean_input')) {`

`$this->app = $value;`

`} else { exit; }`

`}`

`public function set_app($value) {`

`$this->app = $value; }`

`public function get_dog_application($search_value) {`

`$xmlDoc = new DOMDocument();`

`if ( file_exists("e5dog_applications.xml") ) {`

`$xmlDoc->load( 'e5dog_applications.xml' );`

`$searchNode = $xmlDoc->getElementsByTagName( "type" );`

`foreach( $searchNode as $searchNode )  {`

`$valueID = $searchNode->getAttribute('ID');`

`if($valueID == $search_value)   {`

`$xmlLocation = $searchNode->getElementsByTagName( "location" );`

`return $xmlLocation->item(0)->nodeValue;`

`break;    }`

`} }`

`throw new Exception("Dog applications xml file missing or corrupt"); }`

`function create_object($properties_array) {`

`$dog_loc = $this->get_dog_application($this->app);`

`if(($dog_loc == FALSE) || (!file_exists($dog_loc))) {`

`throw new Exception("File $dog_loc missing or corrupt.");  }`

`else`

`{`

`require_once($dog_loc);`

`$class_array = get_declared_classes();`

`$last_position = count($class_array) - 1;`

`$class_name = $class_array[$last_position];`

`$dog_object = new $class_name($properties_array);`

`return $dog_object;`

`}`

`}`

`}`

`?>`

当`dog_application.xml`文件、`dog.class`文件和/或`get_breeds`文件丢失时，实例 [5-5](#FPar5) 中的`dog_container`代替实例 [4-10](4.html#FPar13) 中的返回`'FALSE'`。相反，会引发一个异常，指出哪个文件丢失了。

Example 5-6\. The dog_interface.php file with exception handling

`<?php`

`function clean_input($value)`

`{`

`$value = htmlentities($value);`

`$value = strip_tags($value);`

`if (get_magic_quotes_gpc())`

`{`

`$value = stripslashes($value);`

`}`

`$value = htmlentities($value);`

`$bad_chars = array( "{", "}", "(", ")", ";", ":", "<", ">", "/", "$" );`

`$value = str_ireplace($bad_chars,"",$value);`

`return $value;`

`}`

`class setException extends Exception {`

`public function errorMessage() {`

`list($name_error, $breed_error, $color_error, $weight_error) = explode(',', $this->getMessage());`

`$name_error   == 'TRUE' ? $eMessage = '' : $eMessage = 'Name update not successful<br/>';`

`$breed_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Breed update not successful<br/>';`

`$color_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Color update not successful<br/>';`

`$weight_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Weight update not successful<br/>';`

`return $eMessage;`

`}`

`}`

`function get_dog_app_properties($lab)`

`{`

`print "Your dog's name is " . $lab->get_dog_name() . "<br/>";`

`print "Your dog weights " . $lab->get_dog_weight() . " lbs. <br />";`

`print "Your dog's breed is " . $lab->get_dog_breed() . "<br />";`

`print "Your dog's color is " . $lab->get_dog_color() . "<br />";`

`}`

`//----------------Main Section-------------------------------------`

`try {`

`if ( file_exists("e5dog_container.php"))`

`{   Require_once("e5dog_container.php"); }`

`else`

`{    throw new Exception("Dog container file missing or corrupt"); }`

`if (isset($_POST['dog_app'])) {`

`if ((isset($_POST['dog_name'])) && (isset($_POST['dog_breed'])) && (isset($_POST['dog_color'])) &&  (isset($_POST['dog_weight'])))`

`{`

`$container = new dog_container(clean_input($_POST['dog_app']));`

`$dog_name = clean_input(filter_input(INPUT_POST, "dog_name"));`

`$dog_breed = clean_input($_POST['dog_breed']);`

`$dog_color = clean_input($_POST['dog_color']);`

`$dog_weight = clean_input($_POST['dog_weight']);`

`$breedxml = $container->get_dog_application("breeds");`

`$properties_array = array($dog_name,$dog_breed,$dog_color,$dog_weight,$breedxml);`

`$lab = $container->create_object($properties_array);`

`print "Updates successful<br />";`

`get_dog_app_properties($lab); }`

`else {`

`print "<p>Missing or invalid parameters. Please go back to the lab.html page to enter valid information.<br />";`

`print "<a href='dog.html'>Dog Creation Page</a>";`

`}`

`} else // select box {`

`$container = new dog_container("selectbox");`

`$properties_array = array("selectbox");`

`$lab = $container->create_object($properties_array);`

`$container->set_app("breeds");`

`$dog_app = $container->get_dog_application("breeds");`

`$result = $lab->get_select($dog_app);`

`print $result;`

`}`

`} // try`

`catch(setException $e)`

`{`

`echo $e->errorMessage();`

`}`

`catch(Exception $e)`

`{`

`echo $e->getMessage();`

`}`

`catch(Error $e) // PHP 7+ only`

`{`

`echo $e->getMessage();`

`}`

`?>`

当比较示例 [4-12](4.html#FPar15) 和示例 [5-6](#FPar6) 时，处理异常所需的代码量少于使用`if/else`条件语句。使用很少的`else`语句，程序的逻辑流程更容易理解。这是因为这个应用程序中所有文件抛出的异常都是由`dog_interface`中的`catch`模块处理的。用户错误被抛出到一个特殊的`setException`异常中。系统错误由错误`catch`模块捕获。`error_check_dog_app`方法(在示例 [4-12](4.html#FPar15) 中)已被`setException`类取代。类中的代码与`error_check_dog_app`中的代码非常相似。删除了在`$eMessage`字符串中显示的单个更新消息，因为该类对用户错误做出反应，而不是成功的更新。在代码主体中添加了一个普通的`print`行，让用户知道所有更新都已成功。该接口中的所有代码周围都添加了`try`块。这有助于捕捉该应用程序任何部分中的任何问题。注意，如果找不到`dog_container`文件，也会抛出异常。

该应用只需要三个`catch`模块。`setException catch`块从`setException`类调用`errorMessage`方法，该方法确定发生了什么用户错误。然后将信息显示给用户。`Exception catch`块处理所有其他异常。它当前向用户显示这些信息。然而，异常和错误捕捉块目前向用户提供了太多的信息。通知用户应用程序可能遇到的其他问题违反了安全性。你应该告诉他们，该系统目前不可用，请他们稍后再来查看。测试时显示详细的错误是可以的。然而，这对现实世界并不好。您将在下一节中解决这个安全漏洞。

> For more information about exception handling, please visit the example: [`http://www.w3schools.com/php/php_exception.asp`](http://www.w3schools.com/php/php_exception.asp) Video: `https://www.thenewboston.com/videos.php?cat=11&video=17171`

### 做它

Examine the code from this section. Are there any areas in which error checking could have been converted to exception handling? Go to the book’s web site and download the code for this section. Make the potential changes to the existing code to use additional exception handling.  

## 记录异常

应用程序必须能够在出现问题时通知系统分析师。但是，不应该向应用程序的用户显示关于错误的特定消息。应该通知用户系统当前不可操作。应该通知系统分析师已经发生的特定问题。

提供这种能力的最简单方法是将错误消息放入日志文件中。PHP 应用程序可以将消息记录到默认的 PHP 错误文件或应用程序特定的文件中。可以编辑`php.ini`文件(参见[第 1 章](1.html)中的位置)来指定默认错误日志文件的位置和名称。一旦`php.ini`文件在编辑器中打开，搜索`error_log`。如果分号位于行首，则该位置已被注释掉。只需删除分号并指定一个位置，例如:

`error_log = c:/temp/php_errors.log`

`-or-`

`error_log =`[`http://www.asite.com/temp/php_errors.log`T3】](http://www.asite.com/temp/php_errors.log)

当写入默认错误日志时，PHP 将在您提交的错误消息中插入一个时间戳。您的默认时区可能没有在`php.ini`文件中正确设置。搜索`date.timezone`。美国大陆的有效时区设置为:

`date.timezone = "America/New_York"`

`date.timezone = "America/Chicago"`

`date.timezone = "America/Los_Angeles"`

`For all other American time zones visit:`[`http://www.php.net/manual/en/timezones.america.php`T3】](http://www.php.net/manual/en/timezones.america.php)

`For worldwide time zones visit:`[`http://php.net/manual/en/timezones.php`T3】](http://php.net/manual/en/timezones.php)

Apache `httpd`配置文件(位置见[第 1 章](1.html))可以覆盖`php.ini`文件中的设置。你也应该打开这个文件，搜索`date.timezone`。用类似下面的格式替换现有行。

`php_value date.timezone "America/New_York"`

一旦你更新并保存了`php.ini`和/或`apache.httpd`文件，你必须重新加载你的 Apache 服务器以使更改生效(参见[第 1 章](1.html))。

Note

时区也可以用程序代码来设置。PHP 7 不支持`datefmt_set_timezone_id`方法。对于 PHP 5.2+可以使用`datefmt_set_timezone`方法。关于用程序代码设置时区的更多信息，请访问 [`http://php.net/manual/en/datetime.settimezone.php`](http://php.net/manual/en/datetime.settimezone.php) 。

`<?php`

`error_log("error message");`

`?>`

输入此代码并将其保存在测试文件中。在您的环境中测试它。如果您的设置是正确的，PHP 将在`error_log`参数中指定的位置创建错误日志。不要自己创建文件。PHP 不会将信息记录到不是自己创建的日志文件中。发送到日志文件的消息格式应类似于以下内容:

`[25-Jun-2015 17:01:12 America/New_York] error message`

只用简单的一行代码，PHP 就在指定的位置创建了基于文本的文件，并将消息放在文件中。

如果您不能访问这些文件，您可以在 PHP 应用程序中指定一个特定的位置来发送您的消息。此功能还允许您设置多个应用程序日志文件。应用程序通常具有信息日志文件、身份验证(登录)日志文件、错误日志文件和安全日志文件。通过分离每种类型的消息，可以更容易地在日志文件中扫描特定类型的消息。

假设您希望在一个文件中记录用户错误，在另一个文件中记录其他错误。

`<?php`

`const USER_ERROR_LOG = 'User_Errors.log';`

`const ERROR_LOG = 'Errors.log';`

`// sending a user error`

`error_log("A user error",3,USER_ERROR_LOG);`

`// sending all other errors`

`error_log("A general error",3,ERROR_LOG);`

`<?php`

这段代码将使用常量(`USER_ERROR_LOG`和`ERROR_LOG`)将错误消息指向正确的位置。注意，`3`的第二个参数被用来让`error_log`方法知道一个不同的位置将被用来记录错误。应该使用标准格式向日志发送消息。格式应该包括时间/日期(如果环境中没有包括，如前所述)、消息类型(如果文件中有多种消息类型)、错误消息和任何其他相关信息。默认情况下，消息长度限制为 120 个字符。然而，这可以在`php.ini`文件中更改。

`$date = date('m.d.Y h:i:s');`

`// For more info on data time format go to:`[`http://php.net/manual/en/function.date.php`T3】](http://php.net/manual/en/function.date.php)

`$errormessage = "This is the error";`

`$eMessage =  $date . " | User Error | " . $errormessage . "\n";`

`error_log($eMessage,3,USER_ERROR_LOG);`

`The above code would produce`

`06.06.2015 03:00:55 | User Error | This is the error`

可以使用标准的文本编辑器(Notepad++或 Notepad)或日志监控软件(您将在本章的后面创建一个日志阅读器程序)来查看文件的内容。

系统将限制日志文件的大小。但是，假设每天没有太多的日志记录，应用程序可以创建特定于每天的日志。

`$USER_ERROR_LOG = "User_Errors" . date('mdy') . ".log";`

`$ERROR_LOG = "Errors" . date('mdy') . ".log";`

`...`

`error_log($eMessage,3,$USER_ERROR_LOG);`

> And security—The location of the log file should be in a different folder from the application. The folder needs to allow write access to the application. However, it should be prevented from being read or written outside the server itself. Only authorized personnel can access the log.

请注意，由于日期方法创建了一个可能的变量输出(不同的日期)，常量(`USER_ERROR_LOG`和`ERROR_LOG`)必须更改为变量。该格式将创建一个类似于`User_Errors06062015.log`或`Errors06062015.log`的文件名。

PHP 还使得在日志文件中写入内容时发送电子邮件警报变得非常容易。web 服务器必须包括电子邮件服务器。您的本地机器可能没有此功能。然而，通常，web 主机提供商(具有 PHP 功能)包括电子邮件服务。要使用这种能力，您可以添加一个`error_log`语句:

`error_log("Date/Time: $date - Serious System Problems with Dog Application. Check error log for details", 1, "noone@helpme.com", "Subject: Dog Application Error \nFrom: System Log <systemlog@helpme.com>" . "\r\n");`

> And security-although it is easy to tell the employees who receive e-mail the exact problems in the application, don't do it. By default, email is not encrypted. Sending an unencrypted e-mail containing application details will cause hackers to destroy your application. However, you should provide enough information in the message (such as date/time stamp and possibly error number) to help employees find the error message in the log file.

第一个参数指定电子邮件的消息。第二个参数通知`error_log`通过电子邮件发送该信息。第三个参数提供“收件人”电子邮件地址。第四个参数是一个额外的头字段。该字段通常用于包含电子邮件的主题和发送邮件的电子邮件地址。必须包含“发件人”地址，否则邮件将不会被发送。但是,“发件人”地址不必是现有的地址。

> For more information about log errors, please visit the example: [`http://php.net/manual/en/function.error-log.php`](http://php.net/manual/en/function.error-log.php) Example: [`http://www.w3schools.com/php/php_error.asp`](http://www.w3schools.com/php/php_error.asp)

在`Dog`应用程序中，您可以通过调整`dog_interface`的`catch`块来提供记录异常和通过电子邮件发送主要错误的能力(来自示例 [5-6](#FPar6) )。

Example 5-7\. The dog_inteface.php file with exception logging and e-mail

`<?php`

`const USER_ERROR_LOG = "User_Errors.log";`

`const ERROR_LOG = "Errors.log";`

`function clean_input($value)`

`{`

`$value = htmlentities($value);`

`// Removes any html from the string and turns it into < format`

`$value = strip_tags($value);`

`if (get_magic_quotes_gpc())`

`{`

`$value = stripslashes($value);        // Gets rid of unwanted slashes`

`}`

`$value = htmlentities($value);        // Removes any html from the string and turns it into < format`

`$bad_chars = array( "{", "}", "(", ")", ";", ":", "<", ">", "/", "$" );`

`$value = str_ireplace($bad_chars,"",$value);`

`return $value;`

`}`

`class setException extends Exception {`

`public function errorMessage() {`

`list($name_error, $breed_error, $color_error, $weight_error) = explode(',', $this->getMessage());`

`$name_error == 'TRUE' ? $eMessage = '' : $eMessage = 'Name update not successful<br/>';`

`$breed_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Breed update not successful<br/>';`

`$color_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Color update not successful<br/>';`

`$weight_error == 'TRUE' ? $eMessage .= '' : $eMessage .= 'Weight update not successful<br/>';`

`return $eMessage;`

`} }`

`}`

`function get_dog_app_properties($lab)`

`{`

`print "Your dog's name is " . $lab->get_dog_name() . "<br/>";`

`print "Your dog weights " . $lab->get_dog_weight() . " lbs. <br />";`

`print "Your dog's breed is " . $lab->get_dog_breed() . "<br />";`

`print "Your dog's color is " . $lab->get_dog_color() . "<br />";`

`}`

`//----------------Main Section-------------------------------------`

`try {`

`if ( file_exists("e5dog_container.php"))`

`{`

`Require_once("e5dog_container.php");`

`}`

`else`

`{`

`throw new Exception("Dog container file missing or corrupt");`

`}`

`if (isset($_POST['dog_app']))`

`{`

`if ((isset($_POST['dog_name'])) && (isset($_POST['dog_breed'])) && (isset($_POST['dog_color'])) && (isset($_POST['dog_weight'])))`

`{`

`$container = new dog_container(clean_input($_POST['dog_app']));`

`$dog_name = clean_input(filter_input(INPUT_POST, "dog_name"));`

`$dog_breed = clean_input($_POST['dog_breed']);`

`$dog_color = clean_input($_POST['dog_color']);`

`$dog_weight = clean_input($_POST['dog_weight']);`

`$breedxml = $container->get_dog_application("breeds");`

`$properties_array = array($dog_name,$dog_breed,$dog_color,$dog_weight,$breedxml);`

`$lab = $container->create_object($properties_array);`

`print "Updates successful<br />";`

`get_dog_app_properties($lab);`

`}`

`else`

`{`

`print "<p>Missing or invalid parameters. Please go back to the dog.html page to enter valid information.<br />";`

`print "<a href='dog.html'>Dog Creation Page</a>";`

`}`

`}`

`else // select box`

`{`

`$container = new dog_container("selectbox");`

`$properties_array = array("selectbox");`

`$lab = $container->create_object($properties_array);`

`$container->set_app("breeds");`

`$dog_app = $container->get_dog_application("breeds");`

`$result = $lab->get_select($dog_app);`

`print $result;`

`}`

`}`

`catch(setException $e)`

`{`

`echo $e->errorMessage(); // displays to the user`

`$date = date('m.d.Y h:i:s');`

`$errormessage = $e->errorMessage();`

`$eMessage =  $date . " | User Error | " . $errormessage . "\n";`

`error_log($eMessage,3,USER_ERROR_LOG); // writes message to user error log file`

`}`

`catch(Exception $e)`

`{`

`echo "The system is currently unavailable. Please try again later."; // displays message to the user`

`$date = date('m.d.Y h:i:s');`

`$errormessage = $e->getMessage();`

`$eMessage = $date . " | User Error | " . $errormessage . "\n";`

`error_log($eMessage,3,ERROR_LOG); // writes message to error log file`

`error_log("Date/Time: $date - Serious System Problems with Dog Application. Check error log for details", 1, "noone@helpme.com", "Subject: Dog Application Error \nFrom: System Log <systemlog@helpme.com>" . "\r\n");`

`// e-mails personnel to alert them of a system problem`

`}`

`catch (Error $e)`

`{`

`echo "The system is currently unavailable. Please try again later."; // displays message to the user`

`$date = date('m.d.Y h:i:s');`

`$errormessage = $e->getMessage();`

`$eMessage = $date . " | Fatal System Error | " . $errormessage . "\n";`

`error_log($eMessage,3,ERROR_LOG); // writes message to error log file`

`error_log("Date/Time: $date - Serious System Problems with Dog Application. Check error log for details", 1, "noone@helpme.com", "Subject: Dog Application Error \nFrom: System Log <systemlog@helpme.com>" . "\r\n");`

`// e-mails personnel to alert them of a system problem`

`}`

在示例 [5-7](#FPar9) 代码的顶部，创建了常量`USER_ERROR_LOG`和`ERROR_LOG`来精确定位日志文件的名称和位置。在代码的顶部定位可能会发生变化的常数(例如税率),为负责支持应用程序的程序员提供了快速更改的便利。如前所述，日志文件的位置必须位于允许应用程序写访问的文件夹中。建议将日志文件与其他日志文件放在同一个文件夹中，以便数据中心人员(或系统分析师)轻松访问。

其他代码更改位于`catch`块中。`setException catch`块将由`setException`类生成的错误消息返回给用户。该消息让用户知道哪些属性(`Name`、`Breed`、`Color`和`Weight`)没有更新。导致此异常的错误可能来自用户，也可能是由于信息从客户机传输到服务器时遭到破坏。这些消息仅提供关于属性需求的信息，而用户应该已经知道这些信息。`catch`模块也向用户错误日志中写入类似的消息。用户错误不是需要分析师解决的紧急错误。然而，跟踪用户问题的趋势可以提供所需的可能变化的指示，以确保用户对应用程序具有可能的最佳体验。

`Exception and Error catch`块捕获所有非用户生成的异常。这些异常导致的消息可能会泄露会破坏应用程序安全性的信息。因此，应该向用户显示一条通用消息(如`"The system is currently unavailable. Please try again later."`)。有关异常的详细信息(错误消息、文件位置、引发异常的代码行)应该放在错误日志中，以供进一步分析。这些`catch`块捕获的大多数异常会阻止应用程序运行。因此，将出现的问题告知相关人员非常重要。这个`catch`街区是向支持人员发送电子邮件以提醒他们任何问题的好地方。

既然您已经在程序中内置了异常处理和错误处理，那么您可以编辑`php.ini`文件来关闭对用户的错误报告。但是，您应该等到所有开发和测试都完成后再这样做。在`php.ini`文件中找到行`"display_errors = On"`。如果您将此设置更改为`"display_errors = Off"`，大多数错误信息将不会显示给用户。这一改变不会影响程序通过`echo`或`print`方法(包括在任何`catch`块中)发回给用户的任何消息。这一改变将使开发人员能够更好地控制当系统出现问题时向用户显示的消息类型。

### 做它

Download the code for this section. Create or use an existing HTML page that does not check for user input errors. Run the program entering values for the name, breed, weight, and color, which should cause user errors. Stop the program and open the contents of the user error log file. Did the errors appear in the file? If not, check the security of the folder that contains the log file to make sure that it allows write access to the log file. Once you are satisfied that it has caught user errors, try to cause other system errors to occur. Hint: Change the file names to nonexistent names in the `dog` application XML file. Check the error log to determine if the errors have been written to the file. Were you able to cause any errors that are not captured by one of the log files? If so, is there a way to capture those errors?  

## 读取日志和文本文件

在上一节中，您发现了`error_log`方法只使用一行代码就可以写入日志文件。如果日志文件不存在，它会创建日志文件。它将传递给文件内容的任何消息追加(添加到文件的末尾)。然后它关闭文件。如果您要创建自己的日志记录过程，需要几行代码。

`$logFile = fopen("error_log.log", "a");`

`$eMessage = $e->getMessage();`

`fwrite($logFile, $eMessage);`

`fclose($logFile);`

如果这个文件不存在的话，`fopen`方法也会创建这个文件。“`a`”参数表示写入文件的任何内容都应该被附加。“`w`”表示文件中的任何内容都将丢失(被覆盖)。然后，`fwrite`方法将把位于第二个参数(`$eMessage`)中的字符串放入由第一个参数(`$logFile`)指示的文件中。`$logFile`是指向文本文件位置的指针。方法关闭文本文件。

> For more information about writing to a text file, please visit an example: visit w3schools at [`http://www.w3schools.com/php/php_file_create.asp`](http://www.w3schools.com/php/php_file_create.asp) Video: visit New Boston at `https://www.thenewboston.com/videos.php?cat=11&video=17063`

因为日志文件是基于文本的文件，所以您可以使用类似的逻辑创建自己的应用程序来打开日志文件并读取其内容。

`$logFile = fopen("error_log.log", "r");`

`echo fgets($logFile);`

`fclose($logFile);`

这段代码将打开日志文件，读取文件中的第一行(通过一个`fgets`方法)并关闭文件。但是，文件中可能有多行。您必须能够遍历并显示文件中的每一行。您可以使用这里显示的`while`循环来完成此操作。

`$logFile = fopen("error_log.log", "r");`

`while(!feof($logFile))`

`{`

`echo fgets($logFile) . "<br>";`

`}`

`fclose($logFile);`

只要条件语句为`TRUE`，则`while`循环将继续循环。一旦语句为`FALSE`，代码将退出循环，并在循环结束后跳转到下一行代码。在本例中，`error_log`文件以只读方式打开(`r`)。`while`循环查看日志文件的文件结束指示符(`feof`)，以确定是否已到达文件的结尾。如果`feof`返回`TRUE`，则已经到达文件的末尾。当您还没有到达文件末尾时，循环必须继续。要使条件语句产生一个`TRUE`，同时仍有记录要读取，您必须反转逻辑，如果有记录，让`feof`产生`TRUE`，如果没有记录，让`FALSE`产生。您可以使用`!`操作符来完成此操作。`!`操作符是一个`NOT`操作符，它反转结果。A `NOT TRUE`是`FALSE`或者 a `NOT FALSE`是`TRUE`。因此，当有更多记录时，`!feof`操作符将产生`TRUE`,当没有记录时产生`FALSE`。该循环结合`fgets`方法将显示文件中的每条记录。一旦显示了每条记录，它将使用`fclose`关闭文件。

> For more information about reading text files, please visit w3schools for example: [`http://www.w3schools.com/php/php_file_open.asp`](http://www.w3schools.com/php/php_file_open.asp) Visit New Boston for video: `https://www.thenewboston.com/videos.php?cat=11&video=17064` For more information about `while loop:`, please visit w3schools for example: [`http://www.w3schools.com/php/php_looping.asp`](http://www.w3schools.com/php/php_looping.asp) Visit New Boston for video: `https://www.thenewboston.com/videos.php?cat=11&video=17011`

前一个例子产生的输出非常简单。

`06.06.2015 03:00:55 | User Error | This is the error`

这并不比在文本编辑器中打开日志文件更好。您可以使用 HTML 表格、`explode`方法和数组的组合来产生更好的输出。您可以使用`explode`方法将日志文件中的每一行放入一个二维数组中。二维数组将像 HTML 表一样有行和列。

`$dogs = array`

`(`

`array("Sammy","Lab",18,"Yellow"),`

`array("Spot","Mixed",14,"Mixed"),`

`array("Princess","Chihuahua",4,"White"),`

`array("Max","Boxer",35,"Brown")`

`);`

二维数组是信息行的集合。每行的每个位置(列)都有公共信息。在前面的例子中，所有狗的名字在位置 0，狗的品种在位置 1，狗的体重在位置 2，狗的颜色在位置 3。这直接与表中的位置相关联。

> For more information about multidimensional arrays, please visit: Example: [`http://www.w3schools.com/php/php_arrays_multi.asp`](http://www.w3schools.com/php/php_arrays_multi.asp) Video: `https://www.thenewboston.com/videos.php?cat=11&video=17026`

<colgroup><col> <col> <col> <col></colgroup> 
| 制革时将皮弄湿 | 工党 | Eighteen | 黄色 |
| 地点 | 混合的 | Fourteen | 混合的 |
| 公主 | 奇瓦瓦州 | four | 白色的 |
| 最大 | 拳击运动员 | Thirty-five | 褐色的 |

表格和二维数组中的每个位置都由列和行引用。在这张表中，萨米的位置是(0，0)。黄色在位置(0，3)。最大值在位置(3，0)。布朗就位(3，3)。第一个位置是列。第二个位置是行。在 PHP 中，`[]`用来定义数组的位置(下标)。

`echo $dogs[0][0] // displays Sammy`

`echo $dogs[0][3] // displays Yellow`

`echo $dogs[3][0] // displays Max`

`echo $dogs[3][3] // displays Brown`

现在可以调整循环，将日志内容放在一个二维数组中。但是，您不知道数组的大小。所以不能使用之前显示的格式。如果开发人员没有使用 PHP，这可能会让他们头疼。然而，PHP 允许您动态创建数组，就像它允许您在需要时创建变量(属性)一样。

`$logFile = fopen("error_log.log", "r");`

`$row_Count = 0;`

`while(!feof($logFile))`

`{`

`print_r ($error_Array[$row_Count] = explode(' | ', fgets($logFile)));$row_Count++;`

`}`

`fclose($logFile);`

在本例的循环中，`explode`方法通过`|`字符(实际上是一个空格、`|`和一个空格)从文本文件中断开输入行。它将每个分隔的字符串放入`$error_Array`中由`$row_Count`中的值指示的行。第一次循环时，日志文件的第一行放在`$error_Array[0]`(数组的第一行)。因为`explode`命令分隔了字符串，这导致为每个片段创建列。

如果文件的第一行包含:

`A general error | stuff | more stuff`

那么数组的第一行将包含:

`$error_Array[0][0] = "A general error"`

`$error_Array[0][1] = "stuff";`

`$error_Array[0][2] = "more stuff";`

您可以使用示例中所示的`print_r`命令来验证这一点。`print_r`以下列格式显示数组的内容。

`Array ( [0] => A general error [1] => stuff [2] => more stuff )`

这种格式验证字符串的每一部分都已放入数组中的正确位置。

`$row_count`在循环继续之前增加 1。这将文件的下一行定位到数组中的下一个位置(如果是文件的第二行，则为`$error_Array[1]`)。你当然不希望使用`print_r`向用户显示结果(这不是很漂亮)。

但是，它是一个很好的工具，可以帮助您确保程序将所有东西都正确地放置在数组中。您可以在循环中添加代码来构建一个表。

`$logFile = fopen("Errors.log", "r");`

`$row_Count = 0;`

`echo "<table>";`

`while(!feof($logFile))`

`{        echo "<tr>";`

`$error_Array[$row_Count] = explode(' | ', fgets($logFile));`

`$displayString = "";`

`for($I=0; $I < 3; $I++)`

`{`

`echo "<td> " . $error_Array[$row_Count][$I] . " </td> ";`

`}`

`echo "</tr>";`

`$row_Count++;`

`}`

`echo "</table>";`

`fclose($logFile);`

一个`echo`语句位于打开 HTML 表格的`while`循环之前。一个额外的`echo`语句(`echo "<tr>"`)存在于`while`循环中，用于创建表中的一行。

> For more information about the `for` loop, please visit: Example: [`http://www.w3schools.com/php/php_looping_for.asp`](http://www.w3schools.com/php/php_looping_for.asp) Video: `https://www.thenewboston.com/videos.php?cat=11&video=17013`

同样在`while`循环中，已经创建了一个`for`循环来遍历该行的每一列。既然您知道有四列，那么`for`循环是一个不错的选择。当您确切知道要循环多少次时，可以使用`for`循环。`for`循环的第一个参数(在`;`之前)初始化计数变量(`$I=0`)。该变量(`$I`)用于计算每个循环。第二个参数(`$I < 3`)包括确定逻辑流是否将停留在循环中的比较。如果比较结果为`TRUE`，循环将继续。如果是`FALSE`，逻辑流程跳转到循环后的第一条语句(`echo "</tr>"`)。第三个参数(`$I++`)可以增加或减少计数变量。`for`循环通过在一行代码中要求所有信息来帮助程序员记住初始化变量、检查条件和增加变量。

`for`循环中的`echo`语句使用`$row_Count`和`$I`变量从当前行的每一列中提取信息。第一次循环时，`$row_Count`将为 0。`echo`语句将显示`$errorArray[0][0]`的内容。随着`for`循环的继续，将显示`$errorArray[0][1]`、`$errorArray[0][2]`和`$errorArray[0][3]`的内容。使用`<td>`和`</td>`标签将每个值放入表格的一个单元格中。一旦`for`循环完成，流程下降到循环以下并关闭行(回显`</tr>`)。然后`row_Count`变量递增。如果有更多行(文件中有更多记录)，则`while`循环将继续下一行的过程，直到文件中没有更多记录。一旦流程跳出`while`循环，工作台关闭(`echo "</table>"`)。然后文件被关闭。

文本(日志)文件是顺序文件。添加(追加)项目时，它们会被添加到列表的底部。您可能希望对信息进行排序，首先列出最新的信息。只需对代码稍加修改就可以实现这一点。

`$logFile = fopen("Errors.log", "r");`

`$row_Count = 0;`

`while(!feof($logFile))`

`{`

`$error_Array[$row_Count] = explode(' | ', fgets($logFile));`

`$row_Count++;`

`}`

`$row_Count--;`

`fclose($logFile);`

`echo "<table>";`

`for ($J=$row_Count; $J >= 0; $J--)`

`{         echo "<tr>";`

`$displayString = "";`

`for($I=0; $I < 3; $I++)`

`{`

`echo "<td> " . $error_Array[$J][$I] . " </td> ";`

`}`

`echo "</tr>";`

`}`

`echo "</table>";`

`while`循环现在用记录加载数组，并记录数组中的项数。在循环结束并且文件被关闭之后，一个`for`循环以相反的顺序遍历数组，回显表中的行。计数器变量`$J`从数组中的总行数开始(`$row_Count`)。在循环之前，从`$row_Count`中减去 1，因为在检索到最后一条记录之后，它在`while`循环中增加，这使得计数多了 1。然后`$J`对于每个循环递减(`$J--`)，直到值小于零。内部的`for`循环(`for($I=0;$I<3;$I++)`)没有改变，因为它仍然必须循环通过行的每一列来显示信息。

通过将记录加载到数组中，您可以根据需要修改它们。让我们假设您希望能够从日志中删除一条记录。只要知道要删除的行号，就可以从数组中删除该记录。然后，您可以用剩余的记录重新填充该文件。

首先，您将对已经完成的`echo`代码做一个小小的修改，在要删除的记录旁边添加一个链接。然后，您将添加一个`delete`方法，将显示代码移动到一个`display`方法(这样它可以在任何需要的时候被调用)，并创建一个`save changes`方法来更新日志文件。

Example 5-8\. The readerrorlog.php file

`<?php`

`function deleteRecord($recordNumber, &&#x0024;row_Count, &&#x0024;error_Array) {`

`for ($J=$recordNumber; $J < $row_Count - 1; $J++) {`

`for($I=0; $I < 3; $I++)`

`{ $error_Array[$J][$I] = $error_Array[$J + 1][$I]; }`

`}`

`Unset($error_Array[$row_Count]);`

`$row_Count--;`

`}`

`function saveChanges($row_Count,$error_Array,$log_File) {`

`$logFile = fopen($log_File, "w");`

`for($I=0; $I < $row_Count; $I++) {`

`$writeString = $error_Array[$I][0] . " | " . $error_Array[$I][1] . " | " . $error_Array[$I][2];`

`fwrite($logFile, $writeString);`

`}`

`fclose($logFile);`

`}`

`function displayRecords($row_Count, $error_Array) {`

`echo "<html><head>";`

`echo "<style> table { border: 2px solid #5c744d;}  </style>";`

`echo "</head><body><table>";`

`echo "<caption>Log File: " . ERROR_LOG . "</caption>";`

`echo "<tr><th></th><th>Date/Time</th><th>Error Type</th><th>Error Message</th></tr><tr>";`

`for ($J=$row_Count; $J >= 0; $J--) {`

`echo "<td><a href='readlogfilea.php?rn=$J'>Delete</a></td>";`

`for($I=0; $I < 3; $I++)  {`

`echo "<td> " . $error_Array[$J][$I] . " </td> ";`

`}`

`echo "</tr>";`

`}`

`echo "</table>";`

`echo "</body></html>";`

`} // main section`

`const ERROR_LOG = "Errors.log";`

`$logFile = fopen(ERROR_LOG, "r");`

`$row_Count = 0;`

`while(!feof($logFile))`

`{`

`$error_Array[$row_Count] = explode(' | ', fgets($logFile));`

`$row_Count++;`

`}`

`fclose($logFile);`

`if(isset($_GET['rn']))`

`{`

`deleteRecord($_GET['rn'], $row_Count, $error_Array);`

`saveChanges($row_Count,$error_Array,ERROR_LOG);`

`}`

`displayRecords($row_Count,$error_Array);`

`?>`

![A978-1-4842-1730-6_5_Fig2_HTML.jpg](A978-1-4842-1730-6_5_Fig2_HTML.jpg)

图 5-2。

The readerrorlog.php file with user errors

在示例 [5-8](#FPar10) 中，`displayRecords`方法包含了之前显示的大部分相同的代码。添加了额外的 CSS 代码，使显示更加专业。此外，显示的每条记录都包含一个 HTML `href`链接。该链接调用程序，传递用户想要删除的记录号。

“主要部分”中的代码集(执行的第一行代码)创建一个常量`ERROR_LOG`来定义日志文件的位置和名称。文件以与前面所示相同的方式打开并加载到数组中。

一旦加载了数组，程序就会检查它是否被每个记录的删除链接调用过。如果已经通过 HTTP `GET`传递了一个值，程序就会调用`deleteRecord`方法。一旦`deleteRecord`方法完成，程序就调用`saveChanges`方法。不管有没有值被传入程序，它都会执行最后一条语句，这条语句调用`displayRecords`方法。

> Note-The title line of `deleteRecords` method (function `deleteRecord($recordNumber, &&#x0024;row_Count, &&#x0024;error_Array)`) allows `$row_Count and $error_Array` to be updated in the method by reference rather than by value. By default, the parameters passed to the method cannot be changed by the method (by value). `&` indicates that the parameter is passed by reference. This allowed value is changed. `deleteRecords` You can adjust the number of rows in the array (`$row_Count`) and the information of the array itself (`$error_Array`). Pass the content (data) contained in the parameter to the method by value. Pass the memory address of the parameter to the method by reference, which allows the method to change the value of the parameter in memory.

`deleteRecords`方法接受要删除的记录号作为其参数之一。数组中该记录号以上的任何位置都保持不变。低于该记录的任何位置都必须上移一个位置。例如，如果一个数组有十个位置(0-9 ),第五个位置(4)将被删除，那么位置 5-9 现在必须变成位置 4-8。

在下面的例子中，对于要删除的`$recordNumber`之后的任何记录，位置`$J+1`被放入位置 J:

![A978-1-4842-1730-6_5_Figa_HTML.jpg](A978-1-4842-1730-6_5_Figa_HTML.jpg)

不再需要数组中的最后一个位置。释放数组的最后一个位置(使用`unset`)。这将通知操作系统不再需要内存空间。操作系统将调用其垃圾收集器来释放内存位置。当我们在后面的章节中讨论关联数组时，我们会发现一个更简单的方法来完成这个任务。一旦数组被重新配置，就会调用`saveChanges`方法来替换日志文件中的记录。显示的代码与本章前面的例子非常相似，只有一个例外。`fopen`方法使用参数“`w`”。“`w`”参数将删除文件中已经存在的任何内容，并用当前正在写入文件的内容替换它。在本例中，文件将被新的记录集更新(替换),该记录集不包括已删除的记录。在程序被调用的任何时候都会调用`displayRecords`方法(删除或不删除记录)。此方法显示日志文件的内容。

> Programming instructions-A program that retrieves data to be used in the whole program usually retrieves information at the initial stage of the code and places it in a data structure (array, list or data set). When the data in the program is updated, the information in the data structure is also updated. After the data processing is completed, the information will be returned to the original location (text file or database). Updating a text file or database is usually completed as the last stage of the program. The process of the user exiting the program will provide an event to indicate that the updated data should be saved.

### 做它

Download the code for Example [5-8](#FPar10) from the book’s web site. Add a `try` catch block to handle any unexpected problems (such as a nonexistent log file). Test and save your changes.   Adjust the Example [5-8](#FPar10) code from either #1 or the book’s web site to allow the users to select which log file to read. The program should allow the users to select either the user log file or the general system log file. Test and save your changes.  

## 章节术语

<colgroup><col> <col></colgroup> 
| 错误 | 例外 |
| try/catch 块 | $e->getMessage()： |
| 交换语句 | 嵌入式 if 语句 |
| 默认代码 | 延伸 |
| 异常类 | 遗产 |
| 子类别 | 父类 |
| 触发器 _ 错误 | 异常处理的层次结构 |
| 引发(抛出)异常 | 捕捉异常 |
| 代码的态度 | 推错误 |
| 找出错误 | 日志文件 |
| 默认 PHP 错误文件 | 错误日志 |
| 时间戳 | 日期.时区 |
| 应用程序日志文件 | 常数 |
| 电子邮件提醒 | 显示 _ 错误 |
| 文本文件 | 顺序文件 |
| 打开文件 | fwrite |
| 指针 | fclose(美国联邦航空局) |
| 从文件指针中读取一行 | while 循环 |
| 文件结尾判断 | ！操作员 |
| 引擎异常 | 激增 |
| 二维数组 | 排 |
| 圆柱 | 下标 |
| 动态数组 | 数组的第一行 |
| 打印 _f | 增量 |
| 减量 | for 循环 |
| HTML HREF | 复原 |

## 第二章问题和项目

多重选择

Which of the folowing is true about PHP program errors? They are used for all exceptional situations before PHP 5.0.   They are handled by the operating system.   They might be displayed to the users.   All of these.     Which of the folowing is true about PHP program exceptions? They are used for all exceptional situations after PHP 5.0.   They can be handled by the operating system.   They might be displayed to the users.   All of these.     The `try/catch` block is used to do which of the following? Capture all errors.   Capture only known errors.   Capture all exceptions.   Capture only known exceptions.     Inheritance does which of the following? Is part of object-oriented programming.   Allows the child class to use all the attributes of its parent class.   Allows the child to create its own methods or properties.   All of these.     Text files do which of the following? Are easy to use in PHP.   Are more secure than using databases.   Are non-sequential.   None of these.     PHP log files do which of the following? Are created by the `error_log` method.   Are updated by the `error_log` method.   Should be located in a different directory than the application.   All of these     Which of the following describes two-dimensional arrays? They are similar to HTML tables. They contain rows and columns.   They should be avoided at all costs. They are inefficient and difficult to use.   They require all columns to be loaded with data before rows.   None of these.     Which of the following describes the first position of a two-dimensional array? It has a subscript of 0.   It has a subscript of 1.   It has a default value.   None of these.     Application log files should include which of the folllowing?. User log files.   Error log files.   Informational log files.   All of these.     E-mails generated because of program exceptions should do what? Include all error information, including the error descriptions.   Include the code lines that caused the error to occur.   Include the date and time the error occurred.   All of these.    

对/错

All exceptions should be displayed to the users.   The `for` loop should be used when you know exactly how many loops will occur.   The `while` loop will continue to loop until the conditional statement becomes true.   `unset` can be used to release a position in an array.   All PHP arrays must be declared before being used.   A pointer points to the location in memory that an object resides.   The `!` operator reverses a `TRUE` result to a `FALSE` result.   `print_f` can be used to display the contents of an array.   `Try/Catch` blocks should reside in the business rules and data tiers but not the interface tier.   Only `Exceptions` intentionally thrown by program code should be caught.  

简答/短文

Explain how hierarchy of exception handling works with three-tier applications.   What is the difference between an error and an exception?   How do you correct the time zone if PHP is providing an incorrect timestamp?   How can PHP programmers try to capture errors so they can be treated as if they are exceptions?   Why is it important to have multiple log files produced by an application?  

项目

Adjust the code from project #1 (or #2) from [Chapter 4](4.html) to include exception handling and logging.   Create an application that will register contestants for your favorite game show. Include verification of the data entered using HTML5 and JavaScript. Also validate the data when it is passed to the application. The application should include an interface php program (interface tier) and a registration class (business rules tier). The registration class should include exception handling (both user exceptions and program exceptions). The interface program should handle the exceptions using `try/catch` blocks as shown in this chapter.  

学期项目

Update the ABC Computer Parts Warehouse Inventory application to include exception handling. The application should attempt to handle all exceptions, and errors, when possible. User exceptions should be logged to a user log. All other exceptions should be logged to a system log. If the exception is considered to be extreme (will cause the program to otherwise crash), an e-mail should be sent to the system administrator. Hint: The `Try/Catch` block should only exist in the interface tier.