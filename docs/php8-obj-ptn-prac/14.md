# 14.好的(和坏的)实践

到目前为止，在这本书里，我一直专注于编码，特别是设计在构建灵活的、可重用的工具和应用中的作用。然而，开发并没有随着代码而结束。有可能从书本和课程中获得对语言的扎实理解，但在运行和部署项目时仍然会遇到问题。

在这一章中，我将超越代码，介绍一些构成成功开发过程基础的工具和技术。本章将涵盖以下内容:

*   第三方软件包:从哪里获得，何时使用

*   *构建*:创建和部署包

*   版本控制:给开发过程带来和谐

*   *文档*:编写易于理解、使用和扩展的代码

*   单元测试:一个自动化缺陷检测和预防的工具

*   标准:为什么从众有时是好的

*   一个使用虚拟化的工具，这样所有的开发者都可以在一个类似于生产环境的系统中工作，不管他们的硬件或者操作系统是什么

*   持续集成(Continuous integration):使用这种实践和工具集来自动化项目构建和测试，并在出现问题时得到提醒

## 超越代码

当我第一次从独立工作中毕业并在一个开发团队中任职时，我惊讶于其他开发人员似乎必须知道这么多东西。善意的争论在看似至关重要的问题上无休止地酝酿着:哪个是最好的文本编辑器？团队应该标准化集成开发环境吗？我们应该强加一个编码标准吗？我们应该如何测试我们的代码？我们应该在开发的时候记录吗？有时，这些问题似乎比代码本身更重要，我的同事们似乎通过某种奇怪的渗透过程获得了该领域的百科知识。

我读过的关于 PHP、Perl 和 Java 的书当然没有在很大程度上偏离代码本身。正如我已经讨论过的，大多数关于编程平台的书籍很少偏离它们对代码设计中函数和语法的紧密关注。如果设计偏离了主题，你可以肯定，更广泛的问题，如版本控制和测试，很少被讨论。这不是批评——如果一本书声称涵盖了一种语言的主要特征，那么这就是它所做的一切也就不足为奇了。

然而，在学习代码的过程中，我发现我忽略了项目日常生活中的许多机制。我发现其中一些细节对我参与开发的项目的成败至关重要。在这一章中，以及在接下来的章节中的更详细的内容中，我将超越代码来探索一些工具和技术，你的项目的成功可能依赖于它们。

## 借一个轮子

当在项目中面临一个具有挑战性但又不连续的需求时(可能需要解析一种特定的格式，或者在与远程服务器的对话中使用一种新的协议)，构建一个满足这种需求的组件有很多好处。这也是学习手艺的最好方法之一。在创建包的过程中，您深入了解了一个问题，并将可能有更广泛应用的新技术归档。

你立刻投资于你的项目和你自己的技能。通过将功能保留在系统内部，您可以让用户不必下载第三方软件包。偶尔，你也可以回避棘手的许可问题。当你测试你自己设计的一个组件并发现，奇迹中的奇迹，它工作了——它完全按照你在罐子上写的那样工作时，没有什么比这更令人满意的了。

当然，这一切都有黑暗的一面。许多软件包代表了数千个工时的投资:一种您手头可能没有的资源。您可以通过只开发项目特别需要的功能来解决这个问题，而第三方工具也可以满足无数的其他需求。然而，问题仍然存在:如果一个免费的工具存在，为什么你要浪费你的天赋去复制它呢？您有时间和资源来开发、测试和调试您的包吗？这一次部署在别处不是更好吗？

说到轮子发明，我是最糟糕的罪犯之一。找出问题并发明解决方案是我们作为程序员的基本职责。与编写一些胶水将三四个现有组件粘在一起相比，着手一些严肃的架构是一个更有回报的前景。当这种诱惑来临时，我提醒自己过去的项目。尽管从零开始构建的选择在我的经历中从未扼杀过一个项目，但我看到它吞噬了时间表，扼杀了利润空间。我坐在那里，眼里闪着狂热的光芒，策划着情节，旋转着类图，当我沉迷于我的组件的细节时，没有注意到大画面已经成为遥远的记忆。

现在，当我规划一个项目时，我会试着对代码库中的内容和第三方需求有一个感觉。例如，您的应用可能会生成(或读取)一个 RSS 提要；您可能需要验证电子邮件地址并自动发送邮件、验证用户身份或读取标准格式的配置文件。所有这些需求都可以通过外包来满足。

在这本书的前几个版本中，我建议 PEAR (PHP 扩展和应用存储库)是软件包的发展方向。然而，时代变了，PHP 世界已经非常明确地转向了 Composer 依赖管理器及其默认的存储库 packagest([`https://packagist.org`](https://packagist.org))。因为 Composer 基于每个项目来管理包，所以它不太可能出现可怕的依赖地狱综合症(不同的包需要相同库的不兼容版本)。此外，所有动作都转移到了 Composer/Packagist，这意味着您更有可能在那里找到您想要的东西。此外，许多 PEAR 包都可以通过 Packagist(包装商)( [`https://packagist.org/packages/pear/`](https://packagist.org/packages/pear/) )获得。

所以，一旦你确定了你的需求，你的第一站应该是 Packagist 网站。然后，您可以使用 Composer 来安装您的软件包并管理软件包依赖性。我将在下一章更详细地介绍 Composer。

为了让您对使用 Composer 和 Packagist 可以做些什么有所了解，下面是您可以在那里找到的软件包可以做的一些事情:

*   使用`pear/cache_lite`缓存输出

*   使用`athletic/athletic`基准库测试代码的效率

*   用`doctrine/dbal`抽象数据库访问的细节

*   使用`simplepie/simplepie`提取 RSS 提要

*   用`pear/mail`发送带有附件的邮件

*   用`symfony/config`解析配置文件格式

*   用`league/uri`解析和操作 URL

Packagist 网站提供了一个强大的搜索工具。你可能会在那里找到满足你需求的软件包，或者你可能需要使用搜索引擎扩大搜索范围。无论哪种方式，您都应该在着手重新发明轮子之前花时间评估现有的包。

你们有一种需求——并且有解决这种需求的一揽子方案——这一事实不应成为你们审议的起点和终点。虽然最好使用一个包，这样可以节省不必要的开发，但是在某些情况下，它会增加开销而没有真正的好处。例如，您的客户需要您的应用发送邮件，这并不意味着您应该自动使用 pear/mail 包。PHP 提供了一个非常好的`mail()`函数，所以这可能是您的第一站。一旦您意识到您需要根据 RFC822 标准验证所有电子邮件地址，并且设计团队希望通过电子邮件发送图像附件，您就可以开始以不同的方式权衡这些选项。碰巧的是，pear/mail 支持这两个特性(后者与`mail_mime`结合使用)。

许多程序员，包括我自己，经常过分强调原始代码的创建，有时会损害他们的项目。

Note

不愿使用第三方工具和解决方案通常是机构层面的固有问题。这种以怀疑的态度对待外部产品的倾向有时被称为*不是这里发明的*综合症。作为进一步的说明，技术评论家和科幻迷保罗·特里戈指出*不是这里发明的*也是伊恩·M·班克斯文化系列中一艘船的名字。

这种对作者身份的强调可能是可重用代码的创造似乎多于实际使用的一个原因。

卓有成效的程序员将原始代码视为帮助他们设计项目成功结果的工具之一。这样的程序员看着他们手头的资源，并有效地部署它们。如果有一个方案可以承受一定的压力，那么这就是胜利。借用 Perl 世界的一句格言:好的程序员是懒惰的。

## 友好相处

萨特的名言“地狱是其他人”的真实性在一些软件项目中每天都得到证明。这可能描述了客户和开发人员之间的关系，这种关系的典型表现是缺乏沟通会导致特性的蔓延和优先级的扭曲。但是这个上限也适用于快乐交流和合作的团队成员，当谈到共享代码的时候。

一旦一个项目有多个开发人员，版本控制就成了一个问题。一个单独的编码员可能就地处理代码，在开发的关键点保存她的工作目录的副本。引入另一个程序员，这个策略在几分钟内就失效了。如果新的开发人员在同一个开发目录中工作，那么一个程序员在保存时很有可能会覆盖他同事的工作，除非两个人都非常小心地总是在不同的文件上工作。

或者，我们的两个开发人员可以各自开发一个版本的代码库。这很好，直到调和两个版本的时刻到来。除非开发人员已经处理了完全不同的文件集，否则合并两个或更多开发链的任务会变得非常令人头疼。

这就是 Git、Subversion 和类似工具的用武之地。使用版本控制系统，你可以检查出你自己版本的代码库，然后继续工作，直到你对结果满意为止。然后，您可以用同事所做的任何更改来更新您的版本。版本控制软件会自动将这些更改合并到您的文件中，并通知您它无法处理的任何冲突。一旦您测试了这个新的混合体，您就可以将它保存到中央存储库中，让其他开发人员可以使用它。

版本控制系统为您提供了其他好处。它们保存了项目所有阶段的完整记录，因此您可以回滚到项目生命周期中的任何一点，或者获取其快照。您还可以创建分支，这样您就可以在维护一个公开发布版本的同时维护一个前沿的开发版本。

一旦你在一个项目中使用了版本控制，你就不想在没有版本控制的情况下尝试另一个项目。同时处理一个项目的多个分支可能是一个概念性的挑战，尤其是在开始的时候，但是好处很快就变得明显了。版本控制太有用了，离不开它。我在第 17 章中介绍了 Git。

Note

这本书的当前版本是使用 Git 作为协作工具用纯文本编写和编辑的。

## 赋予你的代码翅膀

你见过你的代码因为太难构建而搁浅吗？对于就地开发的项目来说尤其如此。这样的项目融入到它们的上下文中，密码和目录、数据库以及助手应用调用都被编程到代码中。部署这类项目可能是一项艰巨的任务，程序员团队需要通过挑选源代码来修改设置，以便适应新的环境。

通过提供一个集中的配置文件或类，可以在一个地方更改设置，从而在一定程度上缓解这个问题。但即便如此，构建也可能是一件苦差事。安装的难易程度将对您发布的任何应用的受欢迎程度产生重大影响。它还会阻碍或鼓励开发过程中的多次频繁部署。

与任何重复且耗时的任务一样，构建应该是自动化的。构建工具可以确定安装位置的默认值、检查和更改权限、创建数据库、初始化变量以及其他任务。事实上，构建工具可以做您需要的任何事情，从发布到完全部署的源目录中获取应用。

当然，这并不能免除用户向代码中添加环境信息的责任，但是它可以使这个过程变得简单，只需回答几个问题或提供几个命令行开关。

亚马逊的 AWS Elastic Beanstalk 等云产品使得根据需要创建测试和试运行环境成为可能。为了充分利用这些资源，良好的构建和安装解决方案是必不可少的。如果您不能即时部署您的系统，那么自动配置服务器是没有用的。

开发人员可以使用各种构建工具。PEAR 和 Composer 都管理安装(PEAR 集中管理，Composer 管理本地`vendor`目录)。您可以为任一系统创建自己的包，然后用户可以轻松地下载和安装这些包。然而，构建不仅仅是将文件 A 放在位置 B 的过程。

在第 [19](19.html) 章，我会看一个叫 Phing 的应用。这个开源项目是流行的 Ant 构建工具的一个移植，它是用 Java 编写的，也是为 Java 编写的。Phing 是用 PHP 编写的，但它在架构上类似于 Ant，并为其构建文件使用相同的 XML 格式。

Composer 非常好地执行有限数量的任务，并提供尽可能简单的配置。Phing 一开始更令人生畏，但是它有着巨大的灵活性。您不仅可以使用 Phing 来自动化从文件复制到 XSLT 转换的任何事情，如果您需要扩展该工具，还可以轻松编写和合并您自己的任务。Phing 是使用 PHP 的面向对象特性编写的，其设计强调模块化和易于扩展。

构建工具和那些为包或依赖管理而设计的工具并不互相排斥。通常，在开发过程中使用构建工具来运行测试，执行项目内务管理，并准备最终通过 PEAR、Composer 甚至基于发行版的包管理系统(如 RPM 和 Apt)部署的包。

## 标准

我以前提到过，这本书已经把它的重点从梨转移到作曲家。这是因为 Composer 比 PEAR 好太多了吗？我确实喜欢很多关于 Composer 的东西，这些东西可能会影响我的决定。然而，这本书改变的主要原因是其他人都改变了。Composer 已经成为依赖管理的标准。这是至关重要的，因为这意味着当我在 Packagist 找到一个包时，我也有可能找到它的所有依赖项和相关包。我甚至会在那里找到很多梨包。

因此，为依赖关系管理选择一个标准可以确保可用性和互操作性。但是标准不仅仅适用于包和依赖，还适用于系统工作的方式和我们编码的方式。如果我们在协议上达成一致，那么我们的系统和团队可以无缝地相互集成。而且，随着越来越多的组件跨越来越多的系统混合，这变得越来越重要。

如果需要一种明确的处理方式，比如说日志记录，那么我们采用最好的协议显然是理想的。但是建议的质量(将规定格式、日志级别等。)可能没有我们都遵守它这一事实重要。如果只有你一个人在执行最好的标准，那是没有好处的。

在第 [15](15.html) 章中，我将更详细地讨论标准，特别是 PHP-FIG 小组管理的一组建议。这些 PSR(PHP 标准建议)涵盖了从缓存到安全的所有内容。在这一章中，我将关注 PSR-1 和 PSR-12，这两个建议解决了编码风格的棘手问题(你喜欢把括号放在哪里？你对别人告诉你改变做事方式有什么感觉？).然后我继续讨论 PSR-4 的绝对优势，包括自动加载(对 PSR-4 的支持是 Composer 擅长的另一个领域)。

## 无赖

你的团队使用什么操作系统？当然，有些组织要求特定的硬件和软件组合。不过，通常会有混合。一个开发人员可能有一台运行 Fedora 的开发机器。另一个人可能会信赖他的 MacBook，第三个人可能会坚持使用他的外星人 Windows box(他可能喜欢用它来玩游戏)。

很有可能制作系统将完全在别的东西上运行——也许是 CentOS。

让一个系统跨多个平台工作可能是一件痛苦的事情，如果这些平台都不像生产系统，这可能是一个风险。您真的不想在上线后发现与生产操作系统相关的问题。当然，在实践中，您可能会首先部署到一个临时环境。即便如此，早点抓住这些问题不是更好吗？

流浪者是一种利用虚拟化给所有团队成员一个尽可能接近生产的开发环境的技术。启动和运行应该像调用一两个命令一样简单，最棒的是，每个人都可以坚持使用他们最喜欢的机器和发行版(我是 Fedora 迷，请记住)。

我在第 [20 章](20.html)中讲述流浪者。

## 测试

当你创建一个类时，你可能非常确定它是有效的。毕竟，您将在开发过程中测试它的速度。您还将在组件就位的情况下运行您的系统，检查它是否集成良好，以及您的新功能是否可用并按预期执行。

你能确定你的班级会像预期的那样继续工作吗？这似乎是一个愚蠢的问题。毕竟，你已经检查过你的代码一次；为什么它要任意停止工作？嗯，当然不会；没有什么事情是随意发生的，如果您从不在系统中添加任何代码，您就可以轻松地呼吸了。另一方面，如果您的项目是活动的，那么不可避免的是，您的组件的上下文将会改变，并且组件本身很可能会以多种方式改变。

让我们依次来看这些问题。首先，改变一个组件的上下文是如何引入错误的？即使在一个组件彼此很好地解耦的系统中，它们仍然是相互依赖的。您的类使用的对象返回值、执行操作并接受数据。如果这些行为中的任何一个发生变化，对您的类的操作的影响可能会导致一种很容易捕捉到的错误——这种类型的错误，您的系统会显示一个方便的错误消息，其中包括文件名和行号。然而，更阴险的是，这种变化不会导致引擎级别的错误，但仍然会混淆您的组件。如果您的类基于另一个类的数据做出假设，该数据的变化可能会导致它做出错误的决策。您的类现在有错误，并且没有更改一行代码。

很可能你会继续改变你刚刚完成的课程。通常，这些变化是微小而明显的——事实上，如此微小，以至于您不需要仔细检查您在开发过程中执行的检查。不管怎样，你可能已经把它们都忘记了，除非你以某种方式保存它们(也许像我有时做的那样，在你的类文件的底部注释掉了)。然而，小的变化会导致大的意想不到的后果——如果您想在适当的地方放置一个测试工具，这些后果可能已经被发现了。

一个测试工具是一组自动化的测试，它可以被应用到你的系统中作为一个整体，也可以被应用到它的单独的类中。部署好了，测试工具可以帮助你防止错误的发生和重复出现。一个简单的改变可能导致一连串的错误，测试工具可以帮助您定位并消除这些错误。这意味着你可以自信地做出改变，不会破坏任何东西。对你的系统进行改进，然后看到一个失败测试的列表，这是非常令人满意的。这些都是可能在您的系统中传播的错误，但现在它不会再遭受这些错误了。

## 连续累计

你有没有制定过让一切都好起来的时间表？你从一个任务开始:也许是代码或者一个学校项目。又大又吓人，潜伏着失败。但是你拿出一张纸，把它分成容易处理的任务。你决定要读的书和要写的组件。也许你用不同的颜色突出显示任务。事实证明，就个人而言，没有一项任务真的那么可怕。渐渐地，随着你的计划，你征服了最后期限。只要每天做一点点，就没事了。你可以放松。

不过，有时候，这个时间表有一种魔力。你把它像盾牌一样举起来，保护自己免受怀疑和潜移默化的恐惧，也许这一次你会崩溃和燃烧。只有在几周之后，你才会意识到日程表本身并不神奇。你实际上也必须做这项工作。当然，到那时，在时间表令人安心的力量的催眠下，你已经让事情顺其自然了。除了制定一个新的时间表，别无他法。这一次，就不那么让人放心了。

测试和构建也是如此。你必须进行测试。你必须定期在新鲜的环境中构建你的项目；否则，魔法不起作用。

如果编写测试是一件痛苦的事情，那么运行测试也是一件苦差事，尤其是当它们变得越来越复杂，并且失败会打断你的计划的时候。当然，如果你更经常地运行它们，你可能会有更少的失败，并且那些你确实有过的失败会有很好的机会与你头脑中新鲜的新代码相关联。

在沙盒里很容易变得舒服。毕竟，您已经有了所有的玩具:让您的生活变得简单的小 scriptlets、开发工具和有用的库。问题是你的项目也可能在你的沙箱里太舒服了。它可能开始依赖于您在构建文件中遗漏的未提交代码或依赖项。这意味着除了你工作的地方，其他地方都坏了。

唯一的答案是建设，建设，再建设。每次都在一个相当原始的环境中进行。

当然，提出这样的建议当然很好；做这件事完全是另一回事。作为一个品种，程序员往往喜欢编码。他们想把会议和家务减到最少。这就是持续集成(CI)的用武之地。CI 既是一种实践，也是一套使实践尽可能简单的工具。理想情况下，构建和测试应该是完全自动的，或者至少可以通过一个命令或点击来启动。任何问题都会被跟踪，在问题变得太严重之前，您会得到通知。我会在第 [21 章](21.html)里多讲讲 CI。

## 摘要

开发人员的目标总是交付一个工作系统。写好代码是实现这一目标的重要部分，但不是全部。

在这一章中，我介绍了 Composer 和 Packagist 的依赖管理。我还讨论了协作的两大辅助工具:流浪者和版本控制。我介绍了为什么版本控制需要自动化构建，还介绍了 Phing，它是 Ant 的 PHP 实现，是一个 Java 构建工具。最后，我讨论了软件测试并介绍了 CI，这是一套自动化构建和测试的工具。